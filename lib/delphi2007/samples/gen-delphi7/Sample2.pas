(**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *)

unit Sample2;

interface

//{$I uDefine.inc}
{$ifdef CompilerVersion}
{$IF CompilerVersion >= 21}
{$DEFINE CompilerVersion_g21}
{$ELSE}
{$DEFINE CompilerVersion_l21}  
{$IFEND}
{$IF CompilerVersion >= 19} // From Tiburon / Delphi 2009 has support generic collection
{$DEFINE GEN_SUPPORT}
{$DEFINE YES_SCOPEDENUMS}
{$ELSE}
{$DEFINE GEN_NOSUPPORT} //No support Generic
{$DEFINE NO_TStringBuilder}//No Support TStringBuilder
{$DEFINE NO_SCOPEDENUMS}//No Support TStringBuilder
{$IFEND}
{$else}
{$DEFINE GEN_NOSUPPORT}
{$DEFINE NO_TStringBuilder}
{$DEFINE NO_SCOPEDENUMS}
{$DEFINE CompilerVersion_l21}  
{$endif}

uses
  Classes,
  SysUtils,
  uCollections,
  uTypes,
  Thrift,
  Thrift.Utils,
  Thrift.Protocol,
  Thrift.Transport;

const
  cSample2_Option_AnsiStr_Binary = False;
type

//{$SCOPEDENUMS ON}

  TOperation = (
    ADD = 1,
    SUBTRACT = 2,
    MULTIPLY = 3,
    DIVIDE = 4
  );

//{$SCOPEDENUMS OFF}

  TMyInteger = Integer;

  IWork = interface(IBase)
    function GetNum1: Integer;
    procedure SetNum1( const Value: Integer);
    function GetNum2: Integer;
    procedure SetNum2( const Value: Integer);
    function GetOp: TOperation;
    procedure SetOp( const Value: TOperation);
    function GetComment: string;
    procedure SetComment( const Value: string);

    property Num1: Integer read GetNum1 write SetNum1;
    property Num2: Integer read GetNum2 write SetNum2;
    property Op: TOperation read GetOp write SetOp;
    property Comment: string read GetComment write SetComment;

    function Get__isset_Num1: Boolean;
    function Get__isset_Num2: Boolean;
    function Get__isset_Op: Boolean;
    function Get__isset_Comment: Boolean;

    property __isset_Num1: Boolean read Get__isset_Num1;
    property __isset_Num2: Boolean read Get__isset_Num2;
    property __isset_Op: Boolean read Get__isset_Op;
    property __isset_Comment: Boolean read Get__isset_Comment;
  end;

  TWorkImpl = class(TInterfacedObject, IBase, IWork)
  private
    FNum1: Integer;
    FNum2: Integer;
    FOp: TOperation;
    FComment: string;
    
    F__isset_Num1: Boolean;
    F__isset_Num2: Boolean;
    F__isset_Op: Boolean;
    F__isset_Comment: Boolean;
    
    function GetNum1: Integer;
    procedure SetNum1( const Value: Integer);
    function GetNum2: Integer;
    procedure SetNum2( const Value: Integer);
    function GetOp: TOperation;
    procedure SetOp( const Value: TOperation);
    function GetComment: string;
    procedure SetComment( const Value: string);

    function Get__isset_Num1: Boolean;
    function Get__isset_Num2: Boolean;
    function Get__isset_Op: Boolean;
    function Get__isset_Comment: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property Num1: Integer read GetNum1 write SetNum1;
    property Num2: Integer read GetNum2 write SetNum2;
    property Op: TOperation read GetOp write SetOp;
    property Comment: string read GetComment write SetComment;

    // isset
    property __isset_Num1: Boolean read Get__isset_Num1;
    property __isset_Num2: Boolean read Get__isset_Num2;
    property __isset_Op: Boolean read Get__isset_Op;
    property __isset_Comment: Boolean read Get__isset_Comment;
  end;

  IXtruct = interface(IBase)
    function GetString_thing: string;
    procedure SetString_thing( const Value: string);
    function GetByte_thing: ShortInt;
    procedure SetByte_thing( const Value: ShortInt);
    function GetI32_thing: Integer;
    procedure SetI32_thing( const Value: Integer);
    function GetI64_thing: Int64;
    procedure SetI64_thing( const Value: Int64);

    property String_thing: string read GetString_thing write SetString_thing;
    property Byte_thing: ShortInt read GetByte_thing write SetByte_thing;
    property I32_thing: Integer read GetI32_thing write SetI32_thing;
    property I64_thing: Int64 read GetI64_thing write SetI64_thing;

    function Get__isset_String_thing: Boolean;
    function Get__isset_Byte_thing: Boolean;
    function Get__isset_I32_thing: Boolean;
    function Get__isset_I64_thing: Boolean;

    property __isset_String_thing: Boolean read Get__isset_String_thing;
    property __isset_Byte_thing: Boolean read Get__isset_Byte_thing;
    property __isset_I32_thing: Boolean read Get__isset_I32_thing;
    property __isset_I64_thing: Boolean read Get__isset_I64_thing;
  end;

  TXtructImpl = class(TInterfacedObject, IBase, IXtruct)
  private
    FString_thing: string;
    FByte_thing: ShortInt;
    FI32_thing: Integer;
    FI64_thing: Int64;
    
    F__isset_String_thing: Boolean;
    F__isset_Byte_thing: Boolean;
    F__isset_I32_thing: Boolean;
    F__isset_I64_thing: Boolean;
    
    function GetString_thing: string;
    procedure SetString_thing( const Value: string);
    function GetByte_thing: ShortInt;
    procedure SetByte_thing( const Value: ShortInt);
    function GetI32_thing: Integer;
    procedure SetI32_thing( const Value: Integer);
    function GetI64_thing: Int64;
    procedure SetI64_thing( const Value: Int64);

    function Get__isset_String_thing: Boolean;
    function Get__isset_Byte_thing: Boolean;
    function Get__isset_I32_thing: Boolean;
    function Get__isset_I64_thing: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property String_thing: string read GetString_thing write SetString_thing;
    property Byte_thing: ShortInt read GetByte_thing write SetByte_thing;
    property I32_thing: Integer read GetI32_thing write SetI32_thing;
    property I64_thing: Int64 read GetI64_thing write SetI64_thing;

    // isset
    property __isset_String_thing: Boolean read Get__isset_String_thing;
    property __isset_Byte_thing: Boolean read Get__isset_Byte_thing;
    property __isset_I32_thing: Boolean read Get__isset_I32_thing;
    property __isset_I64_thing: Boolean read Get__isset_I64_thing;
  end;

  TInvalidOperation = class(TException)
  public
    type
      IInvalidOperationFactory = interface(IBase)
        function GetWhat: Integer;
        procedure SetWhat( const Value: Integer);
        function GetWhy: string;
        procedure SetWhy( const Value: string);

        // Create Exception Object
        function CreateException: TInvalidOperation;

        property What: Integer read GetWhat write SetWhat;
        property Why: string read GetWhy write SetWhy;

        function Get__isset_What: Boolean;
        function Get__isset_Why: Boolean;

        property __isset_What: Boolean read Get__isset_What;
        property __isset_Why: Boolean read Get__isset_Why;
      end;

      TInvalidOperationFactoryImpl = class(TInterfacedObject, IBase, IInvalidOperationFactory)
      private
        FWhat: Integer;
        FWhy: string;
        
        F__isset_What: Boolean;
        F__isset_Why: Boolean;
        
        function GetWhat: Integer;
        procedure SetWhat( const Value: Integer);
        function GetWhy: string;
        procedure SetWhy( const Value: string);

        function Get__isset_What: Boolean;
        function Get__isset_Why: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Create Exception Object
        function CreateException: TInvalidOperation;

        // Properties
        property What: Integer read GetWhat write SetWhat;
        property Why: string read GetWhy write SetWhy;

        // isset
        property __isset_What: Boolean read Get__isset_What;
        property __isset_Why: Boolean read Get__isset_Why;
      end;

  private
    FInvalidOperationFactory :IInvalidOperationFactory;

    FWhat: Integer;
    FWhy: string;
    
    F__isset_What: Boolean;
    F__isset_Why: Boolean;
    
    function GetWhat: Integer;
    procedure SetWhat( const Value: Integer);
    function GetWhy: string;
    procedure SetWhy( const Value: string);

    function Get__isset_What: Boolean;
    function Get__isset_Why: Boolean;
  public
    constructor Create; overload;
    constructor Create( AWhat: Integer; const AWhy: string); overload;
    destructor Destroy; override;

    function ToString: string; {override}

    // Exception Factory
    property InvalidOperationFactory: IInvalidOperationFactory read FInvalidOperationFactory write FInvalidOperationFactory;

    // Properties
    property What: Integer read GetWhat write SetWhat;
    property Why: string read GetWhy write SetWhy;

    // isset
    property __isset_What: Boolean read Get__isset_What;
    property __isset_Why: Boolean read Get__isset_Why;
  end;

  TSample2 = class
  public
    type
      Iface = interface
        procedure ping();
        function add(num1: Integer; num2: Integer): Integer;
        function calculate(logid: Integer; const w: IWork): Integer;
        procedure echoVoid();
        function echoByte(arg: ShortInt): ShortInt;
        function echoI32(arg: Integer): Integer;
        function echoI64(const arg: Int64): Int64;
        function echoString(const arg: string): string;
        function echoXtruct(const arg: IXtruct): IXtruct;
        function echoList(const arg: IThriftList): IThriftList;
        function echoListXtruct(const arg: IThriftList): IThriftList;
        function echoSet(const arg: IHashSet): IHashSet;
        function echoMap(const arg: IThriftDictionary): IThriftDictionary;
        function echoMapXtruct(const arg: IThriftDictionary): IThriftDictionary;
        procedure zip();
      end;

      TClient = class( TInterfacedObject, Iface)
      public
        constructor Create( prot: IProtocol); overload;
        constructor Create( const iprot: IProtocol; const oprot: IProtocol); overload;
      protected
        iprot_: IProtocol;
        oprot_: IProtocol;
        seqid_: Integer;
      public
        property InputProtocol: IProtocol read iprot_;
        property OutputProtocol: IProtocol read oprot_;
      protected
        // Iface
        procedure ping();
        function add(num1: Integer; num2: Integer): Integer;
        function calculate(logid: Integer; const w: IWork): Integer;
        procedure echoVoid();
        function echoByte(arg: ShortInt): ShortInt;
        function echoI32(arg: Integer): Integer;
        function echoI64(const arg: Int64): Int64;
        function echoString(const arg: string): string;
        function echoXtruct(const arg: IXtruct): IXtruct;
        function echoList(const arg: IThriftList): IThriftList;
        function echoListXtruct(const arg: IThriftList): IThriftList;
        function echoSet(const arg: IHashSet): IHashSet;
        function echoMap(const arg: IThriftDictionary): IThriftDictionary;
        function echoMapXtruct(const arg: IThriftDictionary): IThriftDictionary;
        procedure zip();
      public
        procedure send_ping();
        procedure recv_ping();
        procedure send_add(num1: Integer; num2: Integer);
        function recv_add(): Integer;
        procedure send_calculate(logid: Integer; const w: IWork);
        function recv_calculate(): Integer;
        procedure send_echoVoid();
        procedure recv_echoVoid();
        procedure send_echoByte(arg: ShortInt);
        function recv_echoByte(): ShortInt;
        procedure send_echoI32(arg: Integer);
        function recv_echoI32(): Integer;
        procedure send_echoI64(const arg: Int64);
        function recv_echoI64(): Int64;
        procedure send_echoString(const arg: string);
        function recv_echoString(): string;
        procedure send_echoXtruct(const arg: IXtruct);
        function recv_echoXtruct(): IXtruct;
        procedure send_echoList(const arg: IThriftList);
        function recv_echoList(): IThriftList;
        procedure send_echoListXtruct(const arg: IThriftList);
        function recv_echoListXtruct(): IThriftList;
        procedure send_echoSet(const arg: IHashSet);
        function recv_echoSet(): IHashSet;
        procedure send_echoMap(const arg: IThriftDictionary);
        function recv_echoMap(): IThriftDictionary;
        procedure send_echoMapXtruct(const arg: IThriftDictionary);
        function recv_echoMapXtruct(): IThriftDictionary;
        procedure send_zip();
      end;

      TProcessorImpl = class( TInterfacedObject, IProcessor)
      public
        constructor Create( iface_: Iface );
        destructor Destroy; override;
      private
        iface_: Iface;
      protected
        type
          TProcessFunction = {reference to }procedure( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface) of object;
      protected
        processMap_: IThriftDictionary;{IThriftDictionary<string, TProcessFunction>;}
      public
        function Process( const iprot: IProtocol; const oprot: IProtocol): Boolean;
        procedure ping_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure add_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure calculate_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure echoVoid_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure echoByte_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure echoI32_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure echoI64_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure echoString_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure echoXtruct_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure echoList_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure echoListXtruct_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure echoSet_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure echoMap_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure echoMapXtruct_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure zip_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
      end;

      IPing_args = interface(IBase)
      end;

      TPing_argsImpl = class(TInterfacedObject, IBase, IPing_args)
      private
        
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);
      end;

      IPing_result = interface(IBase)
      end;

      TPing_resultImpl = class(TInterfacedObject, IBase, IPing_result)
      private
        
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);
      end;

      IAdd_args = interface(IBase)
        function GetNum1: Integer;
        procedure SetNum1( const Value: Integer);
        function GetNum2: Integer;
        procedure SetNum2( const Value: Integer);

        property Num1: Integer read GetNum1 write SetNum1;
        property Num2: Integer read GetNum2 write SetNum2;

        function Get__isset_Num1: Boolean;
        function Get__isset_Num2: Boolean;

        property __isset_Num1: Boolean read Get__isset_Num1;
        property __isset_Num2: Boolean read Get__isset_Num2;
      end;

      TAdd_argsImpl = class(TInterfacedObject, IBase, IAdd_args)
      private
        FNum1: Integer;
        FNum2: Integer;
        
        F__isset_Num1: Boolean;
        F__isset_Num2: Boolean;
        
        function GetNum1: Integer;
        procedure SetNum1( const Value: Integer);
        function GetNum2: Integer;
        procedure SetNum2( const Value: Integer);

        function Get__isset_Num1: Boolean;
        function Get__isset_Num2: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Num1: Integer read GetNum1 write SetNum1;
        property Num2: Integer read GetNum2 write SetNum2;

        // isset
        property __isset_Num1: Boolean read Get__isset_Num1;
        property __isset_Num2: Boolean read Get__isset_Num2;
      end;

      IAdd_result = interface(IBase)
        function GetSuccess: Integer;
        procedure SetSuccess( const Value: Integer);

        property Success: Integer read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TAdd_resultImpl = class(TInterfacedObject, IBase, IAdd_result)
      private
        FSuccess: Integer;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: Integer;
        procedure SetSuccess( const Value: Integer);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: Integer read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      ICalculate_args = interface(IBase)
        function GetLogid: Integer;
        procedure SetLogid( const Value: Integer);
        function GetW: IWork;
        procedure SetW( const Value: IWork);

        property Logid: Integer read GetLogid write SetLogid;
        property W: IWork read GetW write SetW;

        function Get__isset_Logid: Boolean;
        function Get__isset_W: Boolean;

        property __isset_Logid: Boolean read Get__isset_Logid;
        property __isset_W: Boolean read Get__isset_W;
      end;

      TCalculate_argsImpl = class(TInterfacedObject, IBase, ICalculate_args)
      private
        FLogid: Integer;
        FW: IWork;
        
        F__isset_Logid: Boolean;
        F__isset_W: Boolean;
        
        function GetLogid: Integer;
        procedure SetLogid( const Value: Integer);
        function GetW: IWork;
        procedure SetW( const Value: IWork);

        function Get__isset_Logid: Boolean;
        function Get__isset_W: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Logid: Integer read GetLogid write SetLogid;
        property W: IWork read GetW write SetW;

        // isset
        property __isset_Logid: Boolean read Get__isset_Logid;
        property __isset_W: Boolean read Get__isset_W;
      end;

      ICalculate_result = interface(IBase)
        function GetSuccess: Integer;
        procedure SetSuccess( const Value: Integer);
        function GetOuch: TInvalidOperation.IInvalidOperationFactory;
        procedure SetOuch( const Value: TInvalidOperation.IInvalidOperationFactory);

        property Success: Integer read GetSuccess write SetSuccess;
        property Ouch: TInvalidOperation.IInvalidOperationFactory read GetOuch write SetOuch;

        function Get__isset_Success: Boolean;
        function Get__isset_Ouch: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
        property __isset_Ouch: Boolean read Get__isset_Ouch;
      end;

      TCalculate_resultImpl = class(TInterfacedObject, IBase, ICalculate_result)
      private
        FSuccess: Integer;
        FOuch: TInvalidOperation.IInvalidOperationFactory;
        
        F__isset_Success: Boolean;
        F__isset_Ouch: Boolean;
        
        function GetSuccess: Integer;
        procedure SetSuccess( const Value: Integer);
        function GetOuch: TInvalidOperation.IInvalidOperationFactory;
        procedure SetOuch( const Value: TInvalidOperation.IInvalidOperationFactory);

        function Get__isset_Success: Boolean;
        function Get__isset_Ouch: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: Integer read GetSuccess write SetSuccess;
        property Ouch: TInvalidOperation.IInvalidOperationFactory read GetOuch write SetOuch;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
        property __isset_Ouch: Boolean read Get__isset_Ouch;
      end;

      IEchoVoid_args = interface(IBase)
      end;

      TEchoVoid_argsImpl = class(TInterfacedObject, IBase, IEchoVoid_args)
      private
        
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);
      end;

      IEchoVoid_result = interface(IBase)
      end;

      TEchoVoid_resultImpl = class(TInterfacedObject, IBase, IEchoVoid_result)
      private
        
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);
      end;

      IEchoByte_args = interface(IBase)
        function GetArg: ShortInt;
        procedure SetArg( const Value: ShortInt);

        property Arg: ShortInt read GetArg write SetArg;

        function Get__isset_Arg: Boolean;

        property __isset_Arg: Boolean read Get__isset_Arg;
      end;

      TEchoByte_argsImpl = class(TInterfacedObject, IBase, IEchoByte_args)
      private
        FArg: ShortInt;
        
        F__isset_Arg: Boolean;
        
        function GetArg: ShortInt;
        procedure SetArg( const Value: ShortInt);

        function Get__isset_Arg: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Arg: ShortInt read GetArg write SetArg;

        // isset
        property __isset_Arg: Boolean read Get__isset_Arg;
      end;

      IEchoByte_result = interface(IBase)
        function GetSuccess: ShortInt;
        procedure SetSuccess( const Value: ShortInt);

        property Success: ShortInt read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TEchoByte_resultImpl = class(TInterfacedObject, IBase, IEchoByte_result)
      private
        FSuccess: ShortInt;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: ShortInt;
        procedure SetSuccess( const Value: ShortInt);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: ShortInt read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      IEchoI32_args = interface(IBase)
        function GetArg: Integer;
        procedure SetArg( const Value: Integer);

        property Arg: Integer read GetArg write SetArg;

        function Get__isset_Arg: Boolean;

        property __isset_Arg: Boolean read Get__isset_Arg;
      end;

      TEchoI32_argsImpl = class(TInterfacedObject, IBase, IEchoI32_args)
      private
        FArg: Integer;
        
        F__isset_Arg: Boolean;
        
        function GetArg: Integer;
        procedure SetArg( const Value: Integer);

        function Get__isset_Arg: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Arg: Integer read GetArg write SetArg;

        // isset
        property __isset_Arg: Boolean read Get__isset_Arg;
      end;

      IEchoI32_result = interface(IBase)
        function GetSuccess: Integer;
        procedure SetSuccess( const Value: Integer);

        property Success: Integer read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TEchoI32_resultImpl = class(TInterfacedObject, IBase, IEchoI32_result)
      private
        FSuccess: Integer;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: Integer;
        procedure SetSuccess( const Value: Integer);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: Integer read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      IEchoI64_args = interface(IBase)
        function GetArg: Int64;
        procedure SetArg( const Value: Int64);

        property Arg: Int64 read GetArg write SetArg;

        function Get__isset_Arg: Boolean;

        property __isset_Arg: Boolean read Get__isset_Arg;
      end;

      TEchoI64_argsImpl = class(TInterfacedObject, IBase, IEchoI64_args)
      private
        FArg: Int64;
        
        F__isset_Arg: Boolean;
        
        function GetArg: Int64;
        procedure SetArg( const Value: Int64);

        function Get__isset_Arg: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Arg: Int64 read GetArg write SetArg;

        // isset
        property __isset_Arg: Boolean read Get__isset_Arg;
      end;

      IEchoI64_result = interface(IBase)
        function GetSuccess: Int64;
        procedure SetSuccess( const Value: Int64);

        property Success: Int64 read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TEchoI64_resultImpl = class(TInterfacedObject, IBase, IEchoI64_result)
      private
        FSuccess: Int64;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: Int64;
        procedure SetSuccess( const Value: Int64);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: Int64 read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      IEchoString_args = interface(IBase)
        function GetArg: string;
        procedure SetArg( const Value: string);

        property Arg: string read GetArg write SetArg;

        function Get__isset_Arg: Boolean;

        property __isset_Arg: Boolean read Get__isset_Arg;
      end;

      TEchoString_argsImpl = class(TInterfacedObject, IBase, IEchoString_args)
      private
        FArg: string;
        
        F__isset_Arg: Boolean;
        
        function GetArg: string;
        procedure SetArg( const Value: string);

        function Get__isset_Arg: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Arg: string read GetArg write SetArg;

        // isset
        property __isset_Arg: Boolean read Get__isset_Arg;
      end;

      IEchoString_result = interface(IBase)
        function GetSuccess: string;
        procedure SetSuccess( const Value: string);

        property Success: string read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TEchoString_resultImpl = class(TInterfacedObject, IBase, IEchoString_result)
      private
        FSuccess: string;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: string;
        procedure SetSuccess( const Value: string);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: string read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      IEchoXtruct_args = interface(IBase)
        function GetArg: IXtruct;
        procedure SetArg( const Value: IXtruct);

        property Arg: IXtruct read GetArg write SetArg;

        function Get__isset_Arg: Boolean;

        property __isset_Arg: Boolean read Get__isset_Arg;
      end;

      TEchoXtruct_argsImpl = class(TInterfacedObject, IBase, IEchoXtruct_args)
      private
        FArg: IXtruct;
        
        F__isset_Arg: Boolean;
        
        function GetArg: IXtruct;
        procedure SetArg( const Value: IXtruct);

        function Get__isset_Arg: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Arg: IXtruct read GetArg write SetArg;

        // isset
        property __isset_Arg: Boolean read Get__isset_Arg;
      end;

      IEchoXtruct_result = interface(IBase)
        function GetSuccess: IXtruct;
        procedure SetSuccess( const Value: IXtruct);

        property Success: IXtruct read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TEchoXtruct_resultImpl = class(TInterfacedObject, IBase, IEchoXtruct_result)
      private
        FSuccess: IXtruct;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: IXtruct;
        procedure SetSuccess( const Value: IXtruct);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: IXtruct read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      IEchoList_args = interface(IBase)
        function GetArg: IThriftList;
        procedure SetArg( const Value: IThriftList);

        property Arg: IThriftList read GetArg write SetArg;

        function Get__isset_Arg: Boolean;

        property __isset_Arg: Boolean read Get__isset_Arg;
      end;

      TEchoList_argsImpl = class(TInterfacedObject, IBase, IEchoList_args)
      private
        FArg: IThriftList;
        
        F__isset_Arg: Boolean;
        
        function GetArg: IThriftList;
        procedure SetArg( const Value: IThriftList);

        function Get__isset_Arg: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Arg: IThriftList read GetArg write SetArg;

        // isset
        property __isset_Arg: Boolean read Get__isset_Arg;
      end;

      IEchoList_result = interface(IBase)
        function GetSuccess: IThriftList;
        procedure SetSuccess( const Value: IThriftList);

        property Success: IThriftList read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TEchoList_resultImpl = class(TInterfacedObject, IBase, IEchoList_result)
      private
        FSuccess: IThriftList;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: IThriftList;
        procedure SetSuccess( const Value: IThriftList);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: IThriftList read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      IEchoListXtruct_args = interface(IBase)
        function GetArg: IThriftList;
        procedure SetArg( const Value: IThriftList);

        property Arg: IThriftList read GetArg write SetArg;

        function Get__isset_Arg: Boolean;

        property __isset_Arg: Boolean read Get__isset_Arg;
      end;

      TEchoListXtruct_argsImpl = class(TInterfacedObject, IBase, IEchoListXtruct_args)
      private
        FArg: IThriftList;
        
        F__isset_Arg: Boolean;
        
        function GetArg: IThriftList;
        procedure SetArg( const Value: IThriftList);

        function Get__isset_Arg: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Arg: IThriftList read GetArg write SetArg;

        // isset
        property __isset_Arg: Boolean read Get__isset_Arg;
      end;

      IEchoListXtruct_result = interface(IBase)
        function GetSuccess: IThriftList;
        procedure SetSuccess( const Value: IThriftList);

        property Success: IThriftList read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TEchoListXtruct_resultImpl = class(TInterfacedObject, IBase, IEchoListXtruct_result)
      private
        FSuccess: IThriftList;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: IThriftList;
        procedure SetSuccess( const Value: IThriftList);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: IThriftList read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      IEchoSet_args = interface(IBase)
        function GetArg: IHashSet;
        procedure SetArg( const Value: IHashSet);

        property Arg: IHashSet read GetArg write SetArg;

        function Get__isset_Arg: Boolean;

        property __isset_Arg: Boolean read Get__isset_Arg;
      end;

      TEchoSet_argsImpl = class(TInterfacedObject, IBase, IEchoSet_args)
      private
        FArg: IHashSet;
        
        F__isset_Arg: Boolean;
        
        function GetArg: IHashSet;
        procedure SetArg( const Value: IHashSet);

        function Get__isset_Arg: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Arg: IHashSet read GetArg write SetArg;

        // isset
        property __isset_Arg: Boolean read Get__isset_Arg;
      end;

      IEchoSet_result = interface(IBase)
        function GetSuccess: IHashSet;
        procedure SetSuccess( const Value: IHashSet);

        property Success: IHashSet read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TEchoSet_resultImpl = class(TInterfacedObject, IBase, IEchoSet_result)
      private
        FSuccess: IHashSet;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: IHashSet;
        procedure SetSuccess( const Value: IHashSet);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: IHashSet read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      IEchoMap_args = interface(IBase)
        function GetArg: IThriftDictionary;
        procedure SetArg( const Value: IThriftDictionary);

        property Arg: IThriftDictionary read GetArg write SetArg;

        function Get__isset_Arg: Boolean;

        property __isset_Arg: Boolean read Get__isset_Arg;
      end;

      TEchoMap_argsImpl = class(TInterfacedObject, IBase, IEchoMap_args)
      private
        FArg: IThriftDictionary;
        
        F__isset_Arg: Boolean;
        
        function GetArg: IThriftDictionary;
        procedure SetArg( const Value: IThriftDictionary);

        function Get__isset_Arg: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Arg: IThriftDictionary read GetArg write SetArg;

        // isset
        property __isset_Arg: Boolean read Get__isset_Arg;
      end;

      IEchoMap_result = interface(IBase)
        function GetSuccess: IThriftDictionary;
        procedure SetSuccess( const Value: IThriftDictionary);

        property Success: IThriftDictionary read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TEchoMap_resultImpl = class(TInterfacedObject, IBase, IEchoMap_result)
      private
        FSuccess: IThriftDictionary;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: IThriftDictionary;
        procedure SetSuccess( const Value: IThriftDictionary);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: IThriftDictionary read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      IEchoMapXtruct_args = interface(IBase)
        function GetArg: IThriftDictionary;
        procedure SetArg( const Value: IThriftDictionary);

        property Arg: IThriftDictionary read GetArg write SetArg;

        function Get__isset_Arg: Boolean;

        property __isset_Arg: Boolean read Get__isset_Arg;
      end;

      TEchoMapXtruct_argsImpl = class(TInterfacedObject, IBase, IEchoMapXtruct_args)
      private
        FArg: IThriftDictionary;
        
        F__isset_Arg: Boolean;
        
        function GetArg: IThriftDictionary;
        procedure SetArg( const Value: IThriftDictionary);

        function Get__isset_Arg: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Arg: IThriftDictionary read GetArg write SetArg;

        // isset
        property __isset_Arg: Boolean read Get__isset_Arg;
      end;

      IEchoMapXtruct_result = interface(IBase)
        function GetSuccess: IThriftDictionary;
        procedure SetSuccess( const Value: IThriftDictionary);

        property Success: IThriftDictionary read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TEchoMapXtruct_resultImpl = class(TInterfacedObject, IBase, IEchoMapXtruct_result)
      private
        FSuccess: IThriftDictionary;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: IThriftDictionary;
        procedure SetSuccess( const Value: IThriftDictionary);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: IThriftDictionary read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      IZip_args = interface(IBase)
      end;

      TZip_argsImpl = class(TInterfacedObject, IBase, IZip_args)
      private
        
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);
      end;

  end;
  
  TConstants = class
  private
    class var FINT32CONSTANT: Integer;
    class var FMAPCONSTANT: IThriftDictionary;
  public
    class property INT32CONSTANT: Integer read FINT32CONSTANT;
    class property MAPCONSTANT: IThriftDictionary read FMAPCONSTANT;
    //{$IF CompilerVersion >= 21.0}
    {$IFDEF CompilerVersion_g21}
    class constructor Create;
    class destructor Destroy;
    {$ENDIF}
  end;

implementation

constructor TWorkImpl.Create;
begin
  inherited;
  FNum1 := LongInt( 0);
  F__isset_Num1 := True;
end;

destructor TWorkImpl.Destroy;
begin
  inherited;
end;

function TWorkImpl.GetNum1: Integer;
begin
  Result := FNum1;
end;

procedure TWorkImpl.SetNum1( const Value: Integer);
begin
  F__isset_Num1 := True;
  FNum1 := Value;
end;

function TWorkImpl.Get__isset_Num1: Boolean;
begin
  Result := F__isset_Num1;
end;

function TWorkImpl.GetNum2: Integer;
begin
  Result := FNum2;
end;

procedure TWorkImpl.SetNum2( const Value: Integer);
begin
  F__isset_Num2 := True;
  FNum2 := Value;
end;

function TWorkImpl.Get__isset_Num2: Boolean;
begin
  Result := F__isset_Num2;
end;

function TWorkImpl.GetOp: TOperation;
begin
  Result := FOp;
end;

procedure TWorkImpl.SetOp( const Value: TOperation);
begin
  F__isset_Op := True;
  FOp := Value;
end;

function TWorkImpl.Get__isset_Op: Boolean;
begin
  Result := F__isset_Op;
end;

function TWorkImpl.GetComment: string;
begin
  Result := FComment;
end;

procedure TWorkImpl.SetComment( const Value: string);
begin
  F__isset_Comment := True;
  FComment := Value;
end;

function TWorkImpl.Get__isset_Comment: Boolean;
begin
  Result := F__isset_Comment;
end;

procedure TWorkImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            Num1 := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            Num2 := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        3: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            Op := TOperation(iprot.ReadI32());
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        4: begin
          if (field_.Type_ = {TType.}String_) then
          begin
            Comment := iprot.ReadString();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TWorkImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('Work');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Num1) then
  begin
    field_.Name := 'num1';
    field_.Type_  := {TType.}I32;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Num1);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Num2) then
  begin
    field_.Name := 'num2';
    field_.Type_  := {TType.}I32;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Num2);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Op) then
  begin
    field_.Name := 'op';
    field_.Type_  := {TType.}I32;
    field_.ID := 3;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Integer(Op));
    oprot.WriteFieldEnd();
  end;
  if (__isset_Comment) then
  begin
    field_.Name := 'comment';
    field_.Type_  := {TType.}String_;
    field_.ID := 4;
    oprot.WriteFieldBegin(field_);
    oprot.WriteString(Comment);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TWorkImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Num1: ');
    sb.Append(Num1);
    sb.Append(',Num2: ');
    sb.Append(Num2);
    sb.Append(',Op: ');
    sb.Append(Integer(Op));
    sb.Append(',Comment: ');
    sb.Append(Comment);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TXtructImpl.Create;
begin
  inherited;
end;

destructor TXtructImpl.Destroy;
begin
  inherited;
end;

function TXtructImpl.GetString_thing: string;
begin
  Result := FString_thing;
end;

procedure TXtructImpl.SetString_thing( const Value: string);
begin
  F__isset_String_thing := True;
  FString_thing := Value;
end;

function TXtructImpl.Get__isset_String_thing: Boolean;
begin
  Result := F__isset_String_thing;
end;

function TXtructImpl.GetByte_thing: ShortInt;
begin
  Result := FByte_thing;
end;

procedure TXtructImpl.SetByte_thing( const Value: ShortInt);
begin
  F__isset_Byte_thing := True;
  FByte_thing := Value;
end;

function TXtructImpl.Get__isset_Byte_thing: Boolean;
begin
  Result := F__isset_Byte_thing;
end;

function TXtructImpl.GetI32_thing: Integer;
begin
  Result := FI32_thing;
end;

procedure TXtructImpl.SetI32_thing( const Value: Integer);
begin
  F__isset_I32_thing := True;
  FI32_thing := Value;
end;

function TXtructImpl.Get__isset_I32_thing: Boolean;
begin
  Result := F__isset_I32_thing;
end;

function TXtructImpl.GetI64_thing: Int64;
begin
  Result := FI64_thing;
end;

procedure TXtructImpl.SetI64_thing( const Value: Int64);
begin
  F__isset_I64_thing := True;
  FI64_thing := Value;
end;

function TXtructImpl.Get__isset_I64_thing: Boolean;
begin
  Result := F__isset_I64_thing;
end;

procedure TXtructImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}String_) then
          begin
            String_thing := iprot.ReadString();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        4: begin
          if (field_.Type_ = {TType.}Byte_) then
          begin
            Byte_thing := iprot.ReadByte();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        9: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            I32_thing := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        11: begin
          if (field_.Type_ = {TType.}I64) then
          begin
            I64_thing := iprot.ReadI64();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TXtructImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('Xtruct');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_String_thing) then
  begin
    field_.Name := 'string_thing';
    field_.Type_  := {TType.}String_;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteString(String_thing);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Byte_thing) then
  begin
    field_.Name := 'byte_thing';
    field_.Type_  := {TType.}Byte_;
    field_.ID := 4;
    oprot.WriteFieldBegin(field_);
    oprot.WriteByte(Byte_thing);
    oprot.WriteFieldEnd();
  end;
  if (__isset_I32_thing) then
  begin
    field_.Name := 'i32_thing';
    field_.Type_  := {TType.}I32;
    field_.ID := 9;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(I32_thing);
    oprot.WriteFieldEnd();
  end;
  if (__isset_I64_thing) then
  begin
    field_.Name := 'i64_thing';
    field_.Type_  := {TType.}I64;
    field_.ID := 11;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI64(I64_thing);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TXtructImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('String_thing: ');
    sb.Append(String_thing);
    sb.Append(',Byte_thing: ');
    sb.Append(Byte_thing);
    sb.Append(',I32_thing: ');
    sb.Append(I32_thing);
    sb.Append(',I64_thing: ');
    sb.Append(I64_thing);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TInvalidOperation.TInvalidOperationFactoryImpl.Create;
begin
  inherited;
end;

destructor TInvalidOperation.TInvalidOperationFactoryImpl.Destroy;
begin
  inherited;
end;

function TInvalidOperation.TInvalidOperationFactoryImpl.GetWhat: Integer;
begin
  Result := FWhat;
end;

procedure TInvalidOperation.TInvalidOperationFactoryImpl.SetWhat( const Value: Integer);
begin
  F__isset_What := True;
  FWhat := Value;
end;

function TInvalidOperation.TInvalidOperationFactoryImpl.Get__isset_What: Boolean;
begin
  Result := F__isset_What;
end;

function TInvalidOperation.TInvalidOperationFactoryImpl.GetWhy: string;
begin
  Result := FWhy;
end;

procedure TInvalidOperation.TInvalidOperationFactoryImpl.SetWhy( const Value: string);
begin
  F__isset_Why := True;
  FWhy := Value;
end;

function TInvalidOperation.TInvalidOperationFactoryImpl.Get__isset_Why: Boolean;
begin
  Result := F__isset_Why;
end;

procedure TInvalidOperation.TInvalidOperationFactoryImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            What := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = {TType.}String_) then
          begin
            Why := iprot.ReadString();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TInvalidOperation.TInvalidOperationFactoryImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('InvalidOperation');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_What) then
  begin
    field_.Name := 'what';
    field_.Type_  := {TType.}I32;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(What);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Why) then
  begin
    field_.Name := 'why';
    field_.Type_  := {TType.}String_;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    oprot.WriteString(Why);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TInvalidOperation.TInvalidOperationFactoryImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('What: ');
    sb.Append(What);
    sb.Append(',Why: ');
    sb.Append(Why);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

function TInvalidOperation.TInvalidOperationFactoryImpl.CreateException: TInvalidOperation;
begin
  Result := TInvalidOperation.Create;
  Result.InvalidOperationFactory := Self;
  if __isset_What then
  begin
    Result.What := What;
  end;
  if __isset_Why then
  begin
    Result.Why := Why;
  end;
  Result.UpdateMessageProperty;
end;

constructor TInvalidOperation.Create;
begin
  inherited Create('');
  FInvalidOperationFactory := TInvalidOperationFactoryImpl.Create;
end;

constructor TInvalidOperation.Create( AWhat: Integer; const AWhy: string);
begin
  Create;
  What := AWhat;
  Why := AWhy;
  UpdateMessageProperty;
end;

destructor TInvalidOperation.Destroy;
begin
  inherited;
end;

function TInvalidOperation.GetWhat: Integer;
begin
  Result := FWhat;
end;

procedure TInvalidOperation.SetWhat( const Value: Integer);
begin
  F__isset_What := True;
  FWhat := Value;
  FInvalidOperationFactory.What := Value;
end;

function TInvalidOperation.Get__isset_What: Boolean;
begin
  Result := F__isset_What;
end;

function TInvalidOperation.GetWhy: string;
begin
  Result := FWhy;
end;

procedure TInvalidOperation.SetWhy( const Value: string);
begin
  F__isset_Why := True;
  FWhy := Value;
  FInvalidOperationFactory.Why := Value;
end;

function TInvalidOperation.Get__isset_Why: Boolean;
begin
  Result := F__isset_Why;
end;

function TInvalidOperation.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('What: ');
    sb.Append(What);
    sb.Append(',Why: ');
    sb.Append(Why);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TSample2.TClient.Create( prot: IProtocol);
begin
  Create( prot, prot );
end;

constructor TSample2.TClient.Create( const iprot: IProtocol; const oprot: IProtocol);
begin
  iprot_ := iprot;
  oprot_ := oprot;
end;

procedure TSample2.TClient.ping();
begin
  send_ping();
  recv_ping();
end;

procedure TSample2.TClient.send_ping();
var
  args : IPing_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('ping', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TPing_argsImpl.Create();
  args.Write(oprot_);
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

procedure TSample2.TClient.recv_ping();
var
  msg : IMessage;
  x : TApplicationException;
  ret : IPing_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TPing_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
end;

function TSample2.TClient.add(num1: Integer; num2: Integer): Integer;
begin
  send_add(num1, num2);
  Result := recv_add();
end;

procedure TSample2.TClient.send_add(num1: Integer; num2: Integer);
var
  args : IAdd_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('add', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TAdd_argsImpl.Create();
  args.Num1 := num1;
  args.Num2 := num2;
  args.Write(oprot_);
  args.Num1 := 0;
  args.Num2 := 0;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TSample2.TClient.recv_add(): Integer;
var
  msg : IMessage;
  x : TApplicationException;
  ret : IAdd_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TAdd_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'add failed: unknown result');
end;

function TSample2.TClient.calculate(logid: Integer; const w: IWork): Integer;
begin
  send_calculate(logid, w);
  Result := recv_calculate();
end;

procedure TSample2.TClient.send_calculate(logid: Integer; const w: IWork);
var
  args : ICalculate_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('calculate', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TCalculate_argsImpl.Create();
  args.Logid := logid;
  args.W := w;
  args.Write(oprot_);
  args.Logid := 0;
  args.W := nil;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TSample2.TClient.recv_calculate(): Integer;
var
  msg : IMessage;
  ex : Sysutils.Exception;
  x : TApplicationException;
  ret : ICalculate_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TCalculate_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    Exit;
  end;
  if (ret.__isset_Ouch) then
  begin
    ex := ret.Ouch.CreateException;
    raise ex;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'calculate failed: unknown result');
end;

procedure TSample2.TClient.echoVoid();
begin
  send_echoVoid();
  recv_echoVoid();
end;

procedure TSample2.TClient.send_echoVoid();
var
  args : IEchoVoid_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('echoVoid', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TEchoVoid_argsImpl.Create();
  args.Write(oprot_);
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

procedure TSample2.TClient.recv_echoVoid();
var
  msg : IMessage;
  x : TApplicationException;
  ret : IEchoVoid_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TEchoVoid_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
end;

function TSample2.TClient.echoByte(arg: ShortInt): ShortInt;
begin
  send_echoByte(arg);
  Result := recv_echoByte();
end;

procedure TSample2.TClient.send_echoByte(arg: ShortInt);
var
  args : IEchoByte_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('echoByte', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TEchoByte_argsImpl.Create();
  args.Arg := arg;
  args.Write(oprot_);
  args.Arg := 0;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TSample2.TClient.recv_echoByte(): ShortInt;
var
  msg : IMessage;
  x : TApplicationException;
  ret : IEchoByte_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TEchoByte_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'echoByte failed: unknown result');
end;

function TSample2.TClient.echoI32(arg: Integer): Integer;
begin
  send_echoI32(arg);
  Result := recv_echoI32();
end;

procedure TSample2.TClient.send_echoI32(arg: Integer);
var
  args : IEchoI32_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('echoI32', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TEchoI32_argsImpl.Create();
  args.Arg := arg;
  args.Write(oprot_);
  args.Arg := 0;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TSample2.TClient.recv_echoI32(): Integer;
var
  msg : IMessage;
  x : TApplicationException;
  ret : IEchoI32_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TEchoI32_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'echoI32 failed: unknown result');
end;

function TSample2.TClient.echoI64(const arg: Int64): Int64;
begin
  send_echoI64(arg);
  Result := recv_echoI64();
end;

procedure TSample2.TClient.send_echoI64(const arg: Int64);
var
  args : IEchoI64_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('echoI64', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TEchoI64_argsImpl.Create();
  args.Arg := arg;
  args.Write(oprot_);
  args.Arg := 0;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TSample2.TClient.recv_echoI64(): Int64;
var
  msg : IMessage;
  x : TApplicationException;
  ret : IEchoI64_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TEchoI64_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'echoI64 failed: unknown result');
end;

function TSample2.TClient.echoString(const arg: string): string;
begin
  send_echoString(arg);
  Result := recv_echoString();
end;

procedure TSample2.TClient.send_echoString(const arg: string);
var
  args : IEchoString_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('echoString', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TEchoString_argsImpl.Create();
  args.Arg := arg;
  args.Write(oprot_);
  args.Arg := '';
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TSample2.TClient.recv_echoString(): string;
var
  msg : IMessage;
  x : TApplicationException;
  ret : IEchoString_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TEchoString_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'echoString failed: unknown result');
end;

function TSample2.TClient.echoXtruct(const arg: IXtruct): IXtruct;
begin
  send_echoXtruct(arg);
  Result := recv_echoXtruct();
end;

procedure TSample2.TClient.send_echoXtruct(const arg: IXtruct);
var
  args : IEchoXtruct_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('echoXtruct', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TEchoXtruct_argsImpl.Create();
  args.Arg := arg;
  args.Write(oprot_);
  args.Arg := nil;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TSample2.TClient.recv_echoXtruct(): IXtruct;
var
  msg : IMessage;
  x : TApplicationException;
  ret : IEchoXtruct_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TEchoXtruct_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    ret.Success := nil;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'echoXtruct failed: unknown result');
end;

function TSample2.TClient.echoList(const arg: IThriftList): IThriftList;
begin
  send_echoList(arg);
  Result := recv_echoList();
end;

procedure TSample2.TClient.send_echoList(const arg: IThriftList);
var
  args : IEchoList_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('echoList', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TEchoList_argsImpl.Create();
  args.Arg := arg;
  args.Write(oprot_);
  args.Arg := nil;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TSample2.TClient.recv_echoList(): IThriftList;
var
  msg : IMessage;
  x : TApplicationException;
  ret : IEchoList_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TEchoList_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    ret.Success := nil;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'echoList failed: unknown result');
end;

function TSample2.TClient.echoListXtruct(const arg: IThriftList): IThriftList;
begin
  send_echoListXtruct(arg);
  Result := recv_echoListXtruct();
end;

procedure TSample2.TClient.send_echoListXtruct(const arg: IThriftList);
var
  args : IEchoListXtruct_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('echoListXtruct', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TEchoListXtruct_argsImpl.Create();
  args.Arg := arg;
  args.Write(oprot_);
  args.Arg := nil;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TSample2.TClient.recv_echoListXtruct(): IThriftList;
var
  msg : IMessage;
  x : TApplicationException;
  ret : IEchoListXtruct_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TEchoListXtruct_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    ret.Success := nil;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'echoListXtruct failed: unknown result');
end;

function TSample2.TClient.echoSet(const arg: IHashSet): IHashSet;
begin
  send_echoSet(arg);
  Result := recv_echoSet();
end;

procedure TSample2.TClient.send_echoSet(const arg: IHashSet);
var
  args : IEchoSet_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('echoSet', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TEchoSet_argsImpl.Create();
  args.Arg := arg;
  args.Write(oprot_);
  args.Arg := nil;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TSample2.TClient.recv_echoSet(): IHashSet;
var
  msg : IMessage;
  x : TApplicationException;
  ret : IEchoSet_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TEchoSet_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    ret.Success := nil;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'echoSet failed: unknown result');
end;

function TSample2.TClient.echoMap(const arg: IThriftDictionary): IThriftDictionary;
begin
  send_echoMap(arg);
  Result := recv_echoMap();
end;

procedure TSample2.TClient.send_echoMap(const arg: IThriftDictionary);
var
  args : IEchoMap_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('echoMap', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TEchoMap_argsImpl.Create();
  args.Arg := arg;
  args.Write(oprot_);
  args.Arg := nil;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TSample2.TClient.recv_echoMap(): IThriftDictionary;
var
  msg : IMessage;
  x : TApplicationException;
  ret : IEchoMap_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TEchoMap_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    ret.Success := nil;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'echoMap failed: unknown result');
end;

function TSample2.TClient.echoMapXtruct(const arg: IThriftDictionary): IThriftDictionary;
begin
  send_echoMapXtruct(arg);
  Result := recv_echoMapXtruct();
end;

procedure TSample2.TClient.send_echoMapXtruct(const arg: IThriftDictionary);
var
  args : IEchoMapXtruct_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('echoMapXtruct', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TEchoMapXtruct_argsImpl.Create();
  args.Arg := arg;
  args.Write(oprot_);
  args.Arg := nil;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TSample2.TClient.recv_echoMapXtruct(): IThriftDictionary;
var
  msg : IMessage;
  x : TApplicationException;
  ret : IEchoMapXtruct_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TEchoMapXtruct_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    ret.Success := nil;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'echoMapXtruct failed: unknown result');
end;

procedure TSample2.TClient.zip();
begin
  send_zip();
end;

procedure TSample2.TClient.send_zip();
var
  args : IZip_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('zip', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TZip_argsImpl.Create();
  args.Write(oprot_);
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

constructor TSample2.TProcessorImpl.Create( iface_: Iface );
var
tmpmethod:TProcessFunction;
begin
  inherited Create;
  Self.iface_ := iface_;
  processMap_ := TThriftDictionaryImpl{<string, TProcessFunction>}.Create;
  //processMap_.AddOrSetValue( 'ping', ping_Process);
  tmpmethod:=Self.ping_Process;
  processMap_.AddOrSetValue( 'ping',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'add', add_Process);
  tmpmethod:=Self.add_Process;
  processMap_.AddOrSetValue( 'add',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'calculate', calculate_Process);
  tmpmethod:=Self.calculate_Process;
  processMap_.AddOrSetValue( 'calculate',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'echoVoid', echoVoid_Process);
  tmpmethod:=Self.echoVoid_Process;
  processMap_.AddOrSetValue( 'echoVoid',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'echoByte', echoByte_Process);
  tmpmethod:=Self.echoByte_Process;
  processMap_.AddOrSetValue( 'echoByte',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'echoI32', echoI32_Process);
  tmpmethod:=Self.echoI32_Process;
  processMap_.AddOrSetValue( 'echoI32',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'echoI64', echoI64_Process);
  tmpmethod:=Self.echoI64_Process;
  processMap_.AddOrSetValue( 'echoI64',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'echoString', echoString_Process);
  tmpmethod:=Self.echoString_Process;
  processMap_.AddOrSetValue( 'echoString',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'echoXtruct', echoXtruct_Process);
  tmpmethod:=Self.echoXtruct_Process;
  processMap_.AddOrSetValue( 'echoXtruct',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'echoList', echoList_Process);
  tmpmethod:=Self.echoList_Process;
  processMap_.AddOrSetValue( 'echoList',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'echoListXtruct', echoListXtruct_Process);
  tmpmethod:=Self.echoListXtruct_Process;
  processMap_.AddOrSetValue( 'echoListXtruct',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'echoSet', echoSet_Process);
  tmpmethod:=Self.echoSet_Process;
  processMap_.AddOrSetValue( 'echoSet',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'echoMap', echoMap_Process);
  tmpmethod:=Self.echoMap_Process;
  processMap_.AddOrSetValue( 'echoMap',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'echoMapXtruct', echoMapXtruct_Process);
  tmpmethod:=Self.echoMapXtruct_Process;
  processMap_.AddOrSetValue( 'echoMapXtruct',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'zip', zip_Process);
  tmpmethod:=Self.zip_Process;
  processMap_.AddOrSetValue( 'zip',Pointer(@tmpmethod));
end;

destructor TSample2.TProcessorImpl.Destroy;
begin
  inherited;
end;

function TSample2.TProcessorImpl.Process( const iprot: IProtocol; const oprot: IProtocol): Boolean;
var
  msg : IMessage;
  fn : TProcessFunction;
  fnp : Pointer;
  x : TApplicationException;
begin
  try
    msg := iprot.ReadMessageBegin();
    fn := nil;
    if (not processMap_.TryGetValuePointer(msg.Name, fnp))
    or (fnp=nil) then
    begin
      TProtocolUtil.Skip(iprot, {TType.}Struct);
      iprot.ReadMessageEnd();
      x := TApplicationException.Create({TApplicationException.TExceptionType.}UnknownMethod, 'Invalid method name: ''' + msg.Name + '''');
      msg := TMessageImpl.Create(msg.Name, {TMessageType.}Exception_, msg.SeqID);
      oprot.WriteMessageBegin( msg);
      x.Write(oprot);
      oprot.WriteMessageEnd();
      oprot.Transport.Flush();
      Result := True;
      Exit;
    end;
    //fn:=TProcessFunction(fnp);
    PCardinal(@fn):=fnp;
    fn(msg.SeqID, iprot, oprot,iface_);
  except
    Result := False;
    Exit;
  end;
  Result := True;
end;

// both way processor
procedure TSample2.TProcessorImpl.ping_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: IPing_args;
  msg: IMessage;
  ret: IPing_result;
begin
  args := TPing_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TPing_resultImpl.Create;
  miface_.ping();
  msg := TMessageImpl.Create('ping', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TSample2.TProcessorImpl.add_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: IAdd_args;
  msg: IMessage;
  ret: IAdd_result;
begin
  args := TAdd_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TAdd_resultImpl.Create;
  ret.Success := miface_.add(args.Num1, args.Num2);
  args.Num1 := 0;
  args.Num2 := 0;
  msg := TMessageImpl.Create('add', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TSample2.TProcessorImpl.calculate_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ICalculate_args;
  msg: IMessage;
  ret: ICalculate_result;
begin
  args := TCalculate_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TCalculate_resultImpl.Create;
  try
    ret.Success := miface_.calculate(args.Logid, args.W);
    args.Logid := 0;
    args.W := nil;
  except
    on E: TInvalidOperation do
    begin
      ret.Ouch := E.InvalidOperationFactory;
    end;
  end;
  msg := TMessageImpl.Create('calculate', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TSample2.TProcessorImpl.echoVoid_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: IEchoVoid_args;
  msg: IMessage;
  ret: IEchoVoid_result;
begin
  args := TEchoVoid_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TEchoVoid_resultImpl.Create;
  miface_.echoVoid();
  msg := TMessageImpl.Create('echoVoid', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TSample2.TProcessorImpl.echoByte_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: IEchoByte_args;
  msg: IMessage;
  ret: IEchoByte_result;
begin
  args := TEchoByte_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TEchoByte_resultImpl.Create;
  ret.Success := miface_.echoByte(args.Arg);
  args.Arg := 0;
  msg := TMessageImpl.Create('echoByte', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TSample2.TProcessorImpl.echoI32_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: IEchoI32_args;
  msg: IMessage;
  ret: IEchoI32_result;
begin
  args := TEchoI32_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TEchoI32_resultImpl.Create;
  ret.Success := miface_.echoI32(args.Arg);
  args.Arg := 0;
  msg := TMessageImpl.Create('echoI32', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TSample2.TProcessorImpl.echoI64_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: IEchoI64_args;
  msg: IMessage;
  ret: IEchoI64_result;
begin
  args := TEchoI64_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TEchoI64_resultImpl.Create;
  ret.Success := miface_.echoI64(args.Arg);
  args.Arg := 0;
  msg := TMessageImpl.Create('echoI64', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TSample2.TProcessorImpl.echoString_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: IEchoString_args;
  msg: IMessage;
  ret: IEchoString_result;
begin
  args := TEchoString_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TEchoString_resultImpl.Create;
  ret.Success := miface_.echoString(args.Arg);
  args.Arg := '';
  msg := TMessageImpl.Create('echoString', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TSample2.TProcessorImpl.echoXtruct_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: IEchoXtruct_args;
  msg: IMessage;
  ret: IEchoXtruct_result;
begin
  args := TEchoXtruct_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TEchoXtruct_resultImpl.Create;
  ret.Success := miface_.echoXtruct(args.Arg);
  args.Arg := nil;
  msg := TMessageImpl.Create('echoXtruct', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TSample2.TProcessorImpl.echoList_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: IEchoList_args;
  msg: IMessage;
  ret: IEchoList_result;
begin
  args := TEchoList_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TEchoList_resultImpl.Create;
  ret.Success := miface_.echoList(args.Arg);
  args.Arg := nil;
  msg := TMessageImpl.Create('echoList', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TSample2.TProcessorImpl.echoListXtruct_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: IEchoListXtruct_args;
  msg: IMessage;
  ret: IEchoListXtruct_result;
begin
  args := TEchoListXtruct_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TEchoListXtruct_resultImpl.Create;
  ret.Success := miface_.echoListXtruct(args.Arg);
  args.Arg := nil;
  msg := TMessageImpl.Create('echoListXtruct', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TSample2.TProcessorImpl.echoSet_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: IEchoSet_args;
  msg: IMessage;
  ret: IEchoSet_result;
begin
  args := TEchoSet_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TEchoSet_resultImpl.Create;
  ret.Success := miface_.echoSet(args.Arg);
  args.Arg := nil;
  msg := TMessageImpl.Create('echoSet', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TSample2.TProcessorImpl.echoMap_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: IEchoMap_args;
  msg: IMessage;
  ret: IEchoMap_result;
begin
  args := TEchoMap_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TEchoMap_resultImpl.Create;
  ret.Success := miface_.echoMap(args.Arg);
  args.Arg := nil;
  msg := TMessageImpl.Create('echoMap', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TSample2.TProcessorImpl.echoMapXtruct_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: IEchoMapXtruct_args;
  msg: IMessage;
  ret: IEchoMapXtruct_result;
begin
  args := TEchoMapXtruct_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TEchoMapXtruct_resultImpl.Create;
  ret.Success := miface_.echoMapXtruct(args.Arg);
  args.Arg := nil;
  msg := TMessageImpl.Create('echoMapXtruct', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// one way processor
procedure TSample2.TProcessorImpl.zip_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: IZip_args;
begin
  args := TZip_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  miface_.zip();
end;

constructor TSample2.TPing_argsImpl.Create;
begin
  inherited;
end;

destructor TSample2.TPing_argsImpl.Destroy;
begin
  inherited;
end;

procedure TSample2.TPing_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      TProtocolUtil.Skip(iprot, field_.Type_);
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TSample2.TPing_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
begin
  struc := TStructImpl.Create('ping_args');
  oprot.WriteStructBegin(struc);
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TSample2.TPing_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TSample2.TPing_resultImpl.Create;
begin
  inherited;
end;

destructor TSample2.TPing_resultImpl.Destroy;
begin
  inherited;
end;

procedure TSample2.TPing_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      TProtocolUtil.Skip(iprot, field_.Type_);
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TSample2.TPing_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
begin
  struc := TStructImpl.Create('ping_result');
  oprot.WriteStructBegin(struc);
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TSample2.TPing_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TSample2.TAdd_argsImpl.Create;
begin
  inherited;
end;

destructor TSample2.TAdd_argsImpl.Destroy;
begin
  inherited;
end;

function TSample2.TAdd_argsImpl.GetNum1: Integer;
begin
  Result := FNum1;
end;

procedure TSample2.TAdd_argsImpl.SetNum1( const Value: Integer);
begin
  F__isset_Num1 := True;
  FNum1 := Value;
end;

function TSample2.TAdd_argsImpl.Get__isset_Num1: Boolean;
begin
  Result := F__isset_Num1;
end;

function TSample2.TAdd_argsImpl.GetNum2: Integer;
begin
  Result := FNum2;
end;

procedure TSample2.TAdd_argsImpl.SetNum2( const Value: Integer);
begin
  F__isset_Num2 := True;
  FNum2 := Value;
end;

function TSample2.TAdd_argsImpl.Get__isset_Num2: Boolean;
begin
  Result := F__isset_Num2;
end;

procedure TSample2.TAdd_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            Num1 := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            Num2 := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TSample2.TAdd_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('add_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Num1) then
  begin
    field_.Name := 'num1';
    field_.Type_  := {TType.}I32;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Num1);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Num2) then
  begin
    field_.Name := 'num2';
    field_.Type_  := {TType.}I32;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Num2);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TSample2.TAdd_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Num1: ');
    sb.Append(Num1);
    sb.Append(',Num2: ');
    sb.Append(Num2);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TSample2.TAdd_resultImpl.Create;
begin
  inherited;
end;

destructor TSample2.TAdd_resultImpl.Destroy;
begin
  inherited;
end;

function TSample2.TAdd_resultImpl.GetSuccess: Integer;
begin
  Result := FSuccess;
end;

procedure TSample2.TAdd_resultImpl.SetSuccess( const Value: Integer);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TSample2.TAdd_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TSample2.TAdd_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            Success := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TSample2.TAdd_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('add_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Success) then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}I32;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Success);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TSample2.TAdd_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    sb.Append(Success);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TSample2.TCalculate_argsImpl.Create;
begin
  inherited;
end;

destructor TSample2.TCalculate_argsImpl.Destroy;
begin
  inherited;
end;

function TSample2.TCalculate_argsImpl.GetLogid: Integer;
begin
  Result := FLogid;
end;

procedure TSample2.TCalculate_argsImpl.SetLogid( const Value: Integer);
begin
  F__isset_Logid := True;
  FLogid := Value;
end;

function TSample2.TCalculate_argsImpl.Get__isset_Logid: Boolean;
begin
  Result := F__isset_Logid;
end;

function TSample2.TCalculate_argsImpl.GetW: IWork;
begin
  Result := FW;
end;

procedure TSample2.TCalculate_argsImpl.SetW( const Value: IWork);
begin
  F__isset_W := True;
  FW := Value;
end;

function TSample2.TCalculate_argsImpl.Get__isset_W: Boolean;
begin
  Result := F__isset_W;
end;

procedure TSample2.TCalculate_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            Logid := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            W := TWorkImpl.Create;
            W.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TSample2.TCalculate_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('calculate_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Logid) then
  begin
    field_.Name := 'logid';
    field_.Type_  := {TType.}I32;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Logid);
    oprot.WriteFieldEnd();
  end;
  if (W <> nil) and __isset_W then
  begin
    field_.Name := 'w';
    field_.Type_  := {TType.}Struct;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    W.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TSample2.TCalculate_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Logid: ');
    sb.Append(Logid);
    sb.Append(',W: ');
    if (W = nil) then sb.Append('<null>') else sb.Append(W.ToString());
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TSample2.TCalculate_resultImpl.Create;
begin
  inherited;
end;

destructor TSample2.TCalculate_resultImpl.Destroy;
begin
  inherited;
end;

function TSample2.TCalculate_resultImpl.GetSuccess: Integer;
begin
  Result := FSuccess;
end;

procedure TSample2.TCalculate_resultImpl.SetSuccess( const Value: Integer);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TSample2.TCalculate_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

function TSample2.TCalculate_resultImpl.GetOuch: TInvalidOperation.IInvalidOperationFactory;
begin
  Result := FOuch;
end;

procedure TSample2.TCalculate_resultImpl.SetOuch( const Value: TInvalidOperation.IInvalidOperationFactory);
begin
  F__isset_Ouch := True;
  FOuch := Value;
end;

function TSample2.TCalculate_resultImpl.Get__isset_Ouch: Boolean;
begin
  Result := F__isset_Ouch;
end;

procedure TSample2.TCalculate_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            Success := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        1: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            Ouch := TInvalidOperation.TInvalidOperationFactoryImpl.Create;
            Ouch.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TSample2.TCalculate_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('calculate_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Success) then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}I32;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Success);
    oprot.WriteFieldEnd();
  end;
  if (Ouch <> nil) and __isset_Ouch then
  begin
    field_.Name := 'ouch';
    field_.Type_  := {TType.}Struct;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    Ouch.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TSample2.TCalculate_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    sb.Append(Success);
    sb.Append(',Ouch: ');
    if (Ouch = nil) then sb.Append('<null>') else sb.Append(Ouch.ToString());
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TSample2.TEchoVoid_argsImpl.Create;
begin
  inherited;
end;

destructor TSample2.TEchoVoid_argsImpl.Destroy;
begin
  inherited;
end;

procedure TSample2.TEchoVoid_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      TProtocolUtil.Skip(iprot, field_.Type_);
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TSample2.TEchoVoid_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
begin
  struc := TStructImpl.Create('echoVoid_args');
  oprot.WriteStructBegin(struc);
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TSample2.TEchoVoid_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TSample2.TEchoVoid_resultImpl.Create;
begin
  inherited;
end;

destructor TSample2.TEchoVoid_resultImpl.Destroy;
begin
  inherited;
end;

procedure TSample2.TEchoVoid_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      TProtocolUtil.Skip(iprot, field_.Type_);
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TSample2.TEchoVoid_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
begin
  struc := TStructImpl.Create('echoVoid_result');
  oprot.WriteStructBegin(struc);
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TSample2.TEchoVoid_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TSample2.TEchoByte_argsImpl.Create;
begin
  inherited;
end;

destructor TSample2.TEchoByte_argsImpl.Destroy;
begin
  inherited;
end;

function TSample2.TEchoByte_argsImpl.GetArg: ShortInt;
begin
  Result := FArg;
end;

procedure TSample2.TEchoByte_argsImpl.SetArg( const Value: ShortInt);
begin
  F__isset_Arg := True;
  FArg := Value;
end;

function TSample2.TEchoByte_argsImpl.Get__isset_Arg: Boolean;
begin
  Result := F__isset_Arg;
end;

procedure TSample2.TEchoByte_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}Byte_) then
          begin
            Arg := iprot.ReadByte();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TSample2.TEchoByte_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('echoByte_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Arg) then
  begin
    field_.Name := 'arg';
    field_.Type_  := {TType.}Byte_;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteByte(Arg);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TSample2.TEchoByte_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Arg: ');
    sb.Append(Arg);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TSample2.TEchoByte_resultImpl.Create;
begin
  inherited;
end;

destructor TSample2.TEchoByte_resultImpl.Destroy;
begin
  inherited;
end;

function TSample2.TEchoByte_resultImpl.GetSuccess: ShortInt;
begin
  Result := FSuccess;
end;

procedure TSample2.TEchoByte_resultImpl.SetSuccess( const Value: ShortInt);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TSample2.TEchoByte_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TSample2.TEchoByte_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}Byte_) then
          begin
            Success := iprot.ReadByte();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TSample2.TEchoByte_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('echoByte_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Success) then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}Byte_;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    oprot.WriteByte(Success);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TSample2.TEchoByte_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    sb.Append(Success);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TSample2.TEchoI32_argsImpl.Create;
begin
  inherited;
end;

destructor TSample2.TEchoI32_argsImpl.Destroy;
begin
  inherited;
end;

function TSample2.TEchoI32_argsImpl.GetArg: Integer;
begin
  Result := FArg;
end;

procedure TSample2.TEchoI32_argsImpl.SetArg( const Value: Integer);
begin
  F__isset_Arg := True;
  FArg := Value;
end;

function TSample2.TEchoI32_argsImpl.Get__isset_Arg: Boolean;
begin
  Result := F__isset_Arg;
end;

procedure TSample2.TEchoI32_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            Arg := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TSample2.TEchoI32_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('echoI32_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Arg) then
  begin
    field_.Name := 'arg';
    field_.Type_  := {TType.}I32;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Arg);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TSample2.TEchoI32_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Arg: ');
    sb.Append(Arg);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TSample2.TEchoI32_resultImpl.Create;
begin
  inherited;
end;

destructor TSample2.TEchoI32_resultImpl.Destroy;
begin
  inherited;
end;

function TSample2.TEchoI32_resultImpl.GetSuccess: Integer;
begin
  Result := FSuccess;
end;

procedure TSample2.TEchoI32_resultImpl.SetSuccess( const Value: Integer);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TSample2.TEchoI32_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TSample2.TEchoI32_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            Success := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TSample2.TEchoI32_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('echoI32_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Success) then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}I32;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Success);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TSample2.TEchoI32_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    sb.Append(Success);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TSample2.TEchoI64_argsImpl.Create;
begin
  inherited;
end;

destructor TSample2.TEchoI64_argsImpl.Destroy;
begin
  inherited;
end;

function TSample2.TEchoI64_argsImpl.GetArg: Int64;
begin
  Result := FArg;
end;

procedure TSample2.TEchoI64_argsImpl.SetArg( const Value: Int64);
begin
  F__isset_Arg := True;
  FArg := Value;
end;

function TSample2.TEchoI64_argsImpl.Get__isset_Arg: Boolean;
begin
  Result := F__isset_Arg;
end;

procedure TSample2.TEchoI64_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}I64) then
          begin
            Arg := iprot.ReadI64();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TSample2.TEchoI64_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('echoI64_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Arg) then
  begin
    field_.Name := 'arg';
    field_.Type_  := {TType.}I64;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI64(Arg);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TSample2.TEchoI64_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Arg: ');
    sb.Append(Arg);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TSample2.TEchoI64_resultImpl.Create;
begin
  inherited;
end;

destructor TSample2.TEchoI64_resultImpl.Destroy;
begin
  inherited;
end;

function TSample2.TEchoI64_resultImpl.GetSuccess: Int64;
begin
  Result := FSuccess;
end;

procedure TSample2.TEchoI64_resultImpl.SetSuccess( const Value: Int64);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TSample2.TEchoI64_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TSample2.TEchoI64_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}I64) then
          begin
            Success := iprot.ReadI64();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TSample2.TEchoI64_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('echoI64_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Success) then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}I64;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI64(Success);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TSample2.TEchoI64_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    sb.Append(Success);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TSample2.TEchoString_argsImpl.Create;
begin
  inherited;
end;

destructor TSample2.TEchoString_argsImpl.Destroy;
begin
  inherited;
end;

function TSample2.TEchoString_argsImpl.GetArg: string;
begin
  Result := FArg;
end;

procedure TSample2.TEchoString_argsImpl.SetArg( const Value: string);
begin
  F__isset_Arg := True;
  FArg := Value;
end;

function TSample2.TEchoString_argsImpl.Get__isset_Arg: Boolean;
begin
  Result := F__isset_Arg;
end;

procedure TSample2.TEchoString_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}String_) then
          begin
            Arg := iprot.ReadString();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TSample2.TEchoString_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('echoString_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Arg) then
  begin
    field_.Name := 'arg';
    field_.Type_  := {TType.}String_;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteString(Arg);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TSample2.TEchoString_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Arg: ');
    sb.Append(Arg);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TSample2.TEchoString_resultImpl.Create;
begin
  inherited;
end;

destructor TSample2.TEchoString_resultImpl.Destroy;
begin
  inherited;
end;

function TSample2.TEchoString_resultImpl.GetSuccess: string;
begin
  Result := FSuccess;
end;

procedure TSample2.TEchoString_resultImpl.SetSuccess( const Value: string);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TSample2.TEchoString_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TSample2.TEchoString_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}String_) then
          begin
            Success := iprot.ReadString();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TSample2.TEchoString_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('echoString_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Success) then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}String_;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    oprot.WriteString(Success);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TSample2.TEchoString_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    sb.Append(Success);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TSample2.TEchoXtruct_argsImpl.Create;
begin
  inherited;
end;

destructor TSample2.TEchoXtruct_argsImpl.Destroy;
begin
  inherited;
end;

function TSample2.TEchoXtruct_argsImpl.GetArg: IXtruct;
begin
  Result := FArg;
end;

procedure TSample2.TEchoXtruct_argsImpl.SetArg( const Value: IXtruct);
begin
  F__isset_Arg := True;
  FArg := Value;
end;

function TSample2.TEchoXtruct_argsImpl.Get__isset_Arg: Boolean;
begin
  Result := F__isset_Arg;
end;

procedure TSample2.TEchoXtruct_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            Arg := TXtructImpl.Create;
            Arg.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TSample2.TEchoXtruct_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('echoXtruct_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Arg <> nil) and __isset_Arg then
  begin
    field_.Name := 'arg';
    field_.Type_  := {TType.}Struct;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    Arg.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TSample2.TEchoXtruct_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Arg: ');
    if (Arg = nil) then sb.Append('<null>') else sb.Append(Arg.ToString());
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TSample2.TEchoXtruct_resultImpl.Create;
begin
  inherited;
end;

destructor TSample2.TEchoXtruct_resultImpl.Destroy;
begin
  inherited;
end;

function TSample2.TEchoXtruct_resultImpl.GetSuccess: IXtruct;
begin
  Result := FSuccess;
end;

procedure TSample2.TEchoXtruct_resultImpl.SetSuccess( const Value: IXtruct);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TSample2.TEchoXtruct_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TSample2.TEchoXtruct_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            Success := TXtructImpl.Create;
            Success.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TSample2.TEchoXtruct_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('echoXtruct_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Success <> nil) and __isset_Success then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}Struct;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    Success.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TSample2.TEchoXtruct_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    if (Success = nil) then sb.Append('<null>') else sb.Append(Success.ToString());
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TSample2.TEchoList_argsImpl.Create;
begin
  inherited;
end;

destructor TSample2.TEchoList_argsImpl.Destroy;
begin
  inherited;
end;

function TSample2.TEchoList_argsImpl.GetArg: IThriftList;
begin
  Result := FArg;
end;

procedure TSample2.TEchoList_argsImpl.SetArg( const Value: IThriftList);
begin
  F__isset_Arg := True;
  FArg := Value;
end;

function TSample2.TEchoList_argsImpl.Get__isset_Arg: Boolean;
begin
  Result := F__isset_Arg;
end;

procedure TSample2.TEchoList_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _list0: IList;
  _i1: Integer;
  _elem2: ShortInt;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}List) then
          begin
            Arg := TThriftListImpl.Create;
            _list0 := iprot.ReadListBegin();
            for _i1 := 0 to _list0.Count - 1 do
            begin
              _elem2 := iprot.ReadByte();
              Arg.Add(_elem2);
            end;
            iprot.ReadListEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TSample2.TEchoList_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  list_3 : IList;
  ik6:integer;
  ikn7:integer;
  _iter4:Variant;
begin
  struc := TStructImpl.Create('echoList_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Arg <> nil) and __isset_Arg then
  begin
    field_.Name := 'arg';
    field_.Type_  := {TType.}List;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    list_3 := TListImpl.Create({TType.}Byte_, Arg.Count);
    oprot.WriteListBegin( list_3);
    ikn7:=Arg.Count-1;
    for ik6:=0 to ikn7 do 
    begin
    _iter4:=Arg.Items[ik6].Value;
      oprot.WriteByte(_iter4);
    end;
    oprot.WriteListEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TSample2.TEchoList_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Arg: ');
    sb.Append(Arg);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TSample2.TEchoList_resultImpl.Create;
begin
  inherited;
end;

destructor TSample2.TEchoList_resultImpl.Destroy;
begin
  inherited;
end;

function TSample2.TEchoList_resultImpl.GetSuccess: IThriftList;
begin
  Result := FSuccess;
end;

procedure TSample2.TEchoList_resultImpl.SetSuccess( const Value: IThriftList);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TSample2.TEchoList_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TSample2.TEchoList_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _list8: IList;
  _i9: Integer;
  _elem10: ShortInt;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}List) then
          begin
            Success := TThriftListImpl.Create;
            _list8 := iprot.ReadListBegin();
            for _i9 := 0 to _list8.Count - 1 do
            begin
              _elem10 := iprot.ReadByte();
              Success.Add(_elem10);
            end;
            iprot.ReadListEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TSample2.TEchoList_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  list_11 : IList;
  ik14:integer;
  ikn15:integer;
  _iter12:Variant;
begin
  struc := TStructImpl.Create('echoList_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Success <> nil) and __isset_Success then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}List;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    list_11 := TListImpl.Create({TType.}Byte_, Success.Count);
    oprot.WriteListBegin( list_11);
    ikn15:=Success.Count-1;
    for ik14:=0 to ikn15 do 
    begin
    _iter12:=Success.Items[ik14].Value;
      oprot.WriteByte(_iter12);
    end;
    oprot.WriteListEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TSample2.TEchoList_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    sb.Append(Success);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TSample2.TEchoListXtruct_argsImpl.Create;
begin
  inherited;
end;

destructor TSample2.TEchoListXtruct_argsImpl.Destroy;
begin
  inherited;
end;

function TSample2.TEchoListXtruct_argsImpl.GetArg: IThriftList;
begin
  Result := FArg;
end;

procedure TSample2.TEchoListXtruct_argsImpl.SetArg( const Value: IThriftList);
begin
  F__isset_Arg := True;
  FArg := Value;
end;

function TSample2.TEchoListXtruct_argsImpl.Get__isset_Arg: Boolean;
begin
  Result := F__isset_Arg;
end;

procedure TSample2.TEchoListXtruct_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _list16: IList;
  _i17: Integer;
  _elem18: IXtruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}List) then
          begin
            Arg := TThriftListImpl.Create;
            _list16 := iprot.ReadListBegin();
            for _i17 := 0 to _list16.Count - 1 do
            begin
              _elem18 := TXtructImpl.Create;
              _elem18.Read(iprot);
              Arg.Add(_elem18);
            end;
            iprot.ReadListEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TSample2.TEchoListXtruct_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  list_19 : IList;
  ik22:integer;
  ikn23:integer;
  _iter20: IXtruct;
begin
  struc := TStructImpl.Create('echoListXtruct_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Arg <> nil) and __isset_Arg then
  begin
    field_.Name := 'arg';
    field_.Type_  := {TType.}List;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    list_19 := TListImpl.Create({TType.}Struct, Arg.Count);
    oprot.WriteListBegin( list_19);
    ikn23:=Arg.Count-1;
    for ik22:=0 to ikn23 do 
    begin
    _iter20:=IXtruct(Arg.Items[ik22].AsIntf);
      _iter20.Write(oprot);
    end;
    oprot.WriteListEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TSample2.TEchoListXtruct_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Arg: ');
    sb.Append(Arg);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TSample2.TEchoListXtruct_resultImpl.Create;
begin
  inherited;
end;

destructor TSample2.TEchoListXtruct_resultImpl.Destroy;
begin
  inherited;
end;

function TSample2.TEchoListXtruct_resultImpl.GetSuccess: IThriftList;
begin
  Result := FSuccess;
end;

procedure TSample2.TEchoListXtruct_resultImpl.SetSuccess( const Value: IThriftList);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TSample2.TEchoListXtruct_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TSample2.TEchoListXtruct_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _list24: IList;
  _i25: Integer;
  _elem26: IXtruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}List) then
          begin
            Success := TThriftListImpl.Create;
            _list24 := iprot.ReadListBegin();
            for _i25 := 0 to _list24.Count - 1 do
            begin
              _elem26 := TXtructImpl.Create;
              _elem26.Read(iprot);
              Success.Add(_elem26);
            end;
            iprot.ReadListEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TSample2.TEchoListXtruct_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  list_27 : IList;
  ik30:integer;
  ikn31:integer;
  _iter28: IXtruct;
begin
  struc := TStructImpl.Create('echoListXtruct_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Success <> nil) and __isset_Success then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}List;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    list_27 := TListImpl.Create({TType.}Struct, Success.Count);
    oprot.WriteListBegin( list_27);
    ikn31:=Success.Count-1;
    for ik30:=0 to ikn31 do 
    begin
    _iter28:=IXtruct(Success.Items[ik30].AsIntf);
      _iter28.Write(oprot);
    end;
    oprot.WriteListEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TSample2.TEchoListXtruct_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    sb.Append(Success);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TSample2.TEchoSet_argsImpl.Create;
begin
  inherited;
end;

destructor TSample2.TEchoSet_argsImpl.Destroy;
begin
  inherited;
end;

function TSample2.TEchoSet_argsImpl.GetArg: IHashSet;
begin
  Result := FArg;
end;

procedure TSample2.TEchoSet_argsImpl.SetArg( const Value: IHashSet);
begin
  F__isset_Arg := True;
  FArg := Value;
end;

function TSample2.TEchoSet_argsImpl.Get__isset_Arg: Boolean;
begin
  Result := F__isset_Arg;
end;

procedure TSample2.TEchoSet_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _set32: ISet;
  _i33: Integer;
  _elem34: ShortInt;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}Set_) then
          begin
            Arg := THashSetImpl.Create;
            _set32 := iprot.ReadSetBegin();
            for _i33 := 0 to _set32.Count - 1 do
            begin
              _elem34 := iprot.ReadByte();
              Arg.Add(_elem34);
            end;
            iprot.ReadSetEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TSample2.TEchoSet_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  set_35 : ISet;
  ik38:integer;
  ikn39:integer;
  _iter36:Variant;
begin
  struc := TStructImpl.Create('echoSet_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Arg <> nil) and __isset_Arg then
  begin
    field_.Name := 'arg';
    field_.Type_  := {TType.}Set_;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    set_35 := TSetImpl.Create({TType.}Byte_, Arg.Count);
    oprot.WriteSetBegin( set_35);
    ikn39:=Arg.Count-1;
    for ik38:=0 to ikn39 do 
    begin
    _iter36:=Arg.Items[ik38].Value;
      oprot.WriteByte(_iter36);
    end;
    oprot.WriteSetEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TSample2.TEchoSet_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Arg: ');
    sb.Append(Arg);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TSample2.TEchoSet_resultImpl.Create;
begin
  inherited;
end;

destructor TSample2.TEchoSet_resultImpl.Destroy;
begin
  inherited;
end;

function TSample2.TEchoSet_resultImpl.GetSuccess: IHashSet;
begin
  Result := FSuccess;
end;

procedure TSample2.TEchoSet_resultImpl.SetSuccess( const Value: IHashSet);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TSample2.TEchoSet_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TSample2.TEchoSet_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _set40: ISet;
  _i41: Integer;
  _elem42: ShortInt;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}Set_) then
          begin
            Success := THashSetImpl.Create;
            _set40 := iprot.ReadSetBegin();
            for _i41 := 0 to _set40.Count - 1 do
            begin
              _elem42 := iprot.ReadByte();
              Success.Add(_elem42);
            end;
            iprot.ReadSetEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TSample2.TEchoSet_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  set_43 : ISet;
  ik46:integer;
  ikn47:integer;
  _iter44:Variant;
begin
  struc := TStructImpl.Create('echoSet_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Success <> nil) and __isset_Success then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}Set_;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    set_43 := TSetImpl.Create({TType.}Byte_, Success.Count);
    oprot.WriteSetBegin( set_43);
    ikn47:=Success.Count-1;
    for ik46:=0 to ikn47 do 
    begin
    _iter44:=Success.Items[ik46].Value;
      oprot.WriteByte(_iter44);
    end;
    oprot.WriteSetEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TSample2.TEchoSet_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    sb.Append(Success);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TSample2.TEchoMap_argsImpl.Create;
begin
  inherited;
end;

destructor TSample2.TEchoMap_argsImpl.Destroy;
begin
  inherited;
end;

function TSample2.TEchoMap_argsImpl.GetArg: IThriftDictionary;
begin
  Result := FArg;
end;

procedure TSample2.TEchoMap_argsImpl.SetArg( const Value: IThriftDictionary);
begin
  F__isset_Arg := True;
  FArg := Value;
end;

function TSample2.TEchoMap_argsImpl.Get__isset_Arg: Boolean;
begin
  Result := F__isset_Arg;
end;

procedure TSample2.TEchoMap_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _map48: IMap;
  _i49: Integer;
  _key50: ShortInt;
  _val51: ShortInt;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}Map) then
          begin
            Arg := TThriftDictionaryImpl.Create;
            _map48 := iprot.ReadMapBegin();
            for _i49 := 0 to _map48.Count - 1 do
            begin
              _key50 := iprot.ReadByte();
              _val51 := iprot.ReadByte();
              Arg.AddOrSetValue( _key50, _val51);
            end;
            iprot.ReadMapEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TSample2.TEchoMap_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  map52 : IMap;
  ik55:integer;
  ikn56:integer;
  _iter53:Variant;
  _iterv54:Variant;
begin
  struc := TStructImpl.Create('echoMap_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Arg <> nil) and __isset_Arg then
  begin
    field_.Name := 'arg';
    field_.Type_  := {TType.}Map;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    map52 := TMapImpl.Create( {TType.}Byte_, {TType.}Byte_, Arg.Count);
    oprot.WriteMapBegin( map52);
    ikn56:=Arg.Count-1;
    for ik55:=0 to ikn56 do 
    begin
    _iter53:=Arg.Keys[ik55].Value;
    _iterv54:=Arg.Values[ik55].Value;
      oprot.WriteByte(_iter53);
      oprot.WriteByte(_iterv54);
    end;
    oprot.WriteMapEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TSample2.TEchoMap_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Arg: ');
    sb.Append(Arg);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TSample2.TEchoMap_resultImpl.Create;
begin
  inherited;
end;

destructor TSample2.TEchoMap_resultImpl.Destroy;
begin
  inherited;
end;

function TSample2.TEchoMap_resultImpl.GetSuccess: IThriftDictionary;
begin
  Result := FSuccess;
end;

procedure TSample2.TEchoMap_resultImpl.SetSuccess( const Value: IThriftDictionary);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TSample2.TEchoMap_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TSample2.TEchoMap_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _map57: IMap;
  _i58: Integer;
  _key59: ShortInt;
  _val60: ShortInt;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}Map) then
          begin
            Success := TThriftDictionaryImpl.Create;
            _map57 := iprot.ReadMapBegin();
            for _i58 := 0 to _map57.Count - 1 do
            begin
              _key59 := iprot.ReadByte();
              _val60 := iprot.ReadByte();
              Success.AddOrSetValue( _key59, _val60);
            end;
            iprot.ReadMapEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TSample2.TEchoMap_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  map61 : IMap;
  ik64:integer;
  ikn65:integer;
  _iter62:Variant;
  _iterv63:Variant;
begin
  struc := TStructImpl.Create('echoMap_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Success <> nil) and __isset_Success then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}Map;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    map61 := TMapImpl.Create( {TType.}Byte_, {TType.}Byte_, Success.Count);
    oprot.WriteMapBegin( map61);
    ikn65:=Success.Count-1;
    for ik64:=0 to ikn65 do 
    begin
    _iter62:=Success.Keys[ik64].Value;
    _iterv63:=Success.Values[ik64].Value;
      oprot.WriteByte(_iter62);
      oprot.WriteByte(_iterv63);
    end;
    oprot.WriteMapEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TSample2.TEchoMap_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    sb.Append(Success);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TSample2.TEchoMapXtruct_argsImpl.Create;
begin
  inherited;
end;

destructor TSample2.TEchoMapXtruct_argsImpl.Destroy;
begin
  inherited;
end;

function TSample2.TEchoMapXtruct_argsImpl.GetArg: IThriftDictionary;
begin
  Result := FArg;
end;

procedure TSample2.TEchoMapXtruct_argsImpl.SetArg( const Value: IThriftDictionary);
begin
  F__isset_Arg := True;
  FArg := Value;
end;

function TSample2.TEchoMapXtruct_argsImpl.Get__isset_Arg: Boolean;
begin
  Result := F__isset_Arg;
end;

procedure TSample2.TEchoMapXtruct_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _map66: IMap;
  _i67: Integer;
  _key68: ShortInt;
  _val69: IXtruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}Map) then
          begin
            Arg := TThriftDictionaryImpl.Create;
            _map66 := iprot.ReadMapBegin();
            for _i67 := 0 to _map66.Count - 1 do
            begin
              _key68 := iprot.ReadByte();
              _val69 := TXtructImpl.Create;
              _val69.Read(iprot);
              Arg.AddOrSetValue( _key68, _val69);
            end;
            iprot.ReadMapEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TSample2.TEchoMapXtruct_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  map70 : IMap;
  ik73:integer;
  ikn74:integer;
  _iter71:Variant;
  _iterv72: IXtruct;
begin
  struc := TStructImpl.Create('echoMapXtruct_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Arg <> nil) and __isset_Arg then
  begin
    field_.Name := 'arg';
    field_.Type_  := {TType.}Map;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    map70 := TMapImpl.Create( {TType.}Byte_, {TType.}Struct, Arg.Count);
    oprot.WriteMapBegin( map70);
    ikn74:=Arg.Count-1;
    for ik73:=0 to ikn74 do 
    begin
    _iter71:=Arg.Keys[ik73].Value;
    _iterv72:=IXtruct(Arg.Values[ik73].AsIntf);
      oprot.WriteByte(_iter71);
      _iterv72.Write(oprot);
    end;
    oprot.WriteMapEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TSample2.TEchoMapXtruct_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Arg: ');
    sb.Append(Arg);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TSample2.TEchoMapXtruct_resultImpl.Create;
begin
  inherited;
end;

destructor TSample2.TEchoMapXtruct_resultImpl.Destroy;
begin
  inherited;
end;

function TSample2.TEchoMapXtruct_resultImpl.GetSuccess: IThriftDictionary;
begin
  Result := FSuccess;
end;

procedure TSample2.TEchoMapXtruct_resultImpl.SetSuccess( const Value: IThriftDictionary);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TSample2.TEchoMapXtruct_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TSample2.TEchoMapXtruct_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _map75: IMap;
  _i76: Integer;
  _key77: ShortInt;
  _val78: IXtruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}Map) then
          begin
            Success := TThriftDictionaryImpl.Create;
            _map75 := iprot.ReadMapBegin();
            for _i76 := 0 to _map75.Count - 1 do
            begin
              _key77 := iprot.ReadByte();
              _val78 := TXtructImpl.Create;
              _val78.Read(iprot);
              Success.AddOrSetValue( _key77, _val78);
            end;
            iprot.ReadMapEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TSample2.TEchoMapXtruct_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  map79 : IMap;
  ik82:integer;
  ikn83:integer;
  _iter80:Variant;
  _iterv81: IXtruct;
begin
  struc := TStructImpl.Create('echoMapXtruct_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Success <> nil) and __isset_Success then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}Map;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    map79 := TMapImpl.Create( {TType.}Byte_, {TType.}Struct, Success.Count);
    oprot.WriteMapBegin( map79);
    ikn83:=Success.Count-1;
    for ik82:=0 to ikn83 do 
    begin
    _iter80:=Success.Keys[ik82].Value;
    _iterv81:=IXtruct(Success.Values[ik82].AsIntf);
      oprot.WriteByte(_iter80);
      _iterv81.Write(oprot);
    end;
    oprot.WriteMapEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TSample2.TEchoMapXtruct_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    sb.Append(Success);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TSample2.TZip_argsImpl.Create;
begin
  inherited;
end;

destructor TSample2.TZip_argsImpl.Destroy;
begin
  inherited;
end;

procedure TSample2.TZip_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      TProtocolUtil.Skip(iprot, field_.Type_);
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TSample2.TZip_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
begin
  struc := TStructImpl.Create('zip_args');
  oprot.WriteStructBegin(struc);
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TSample2.TZip_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

//{$IF CompilerVersion >= 21.0}
{$IFDEF CompilerVersion_g21}
class constructor TConstants.Create;
begin
  FINT32CONSTANT := LongInt( 9853);
  FMAPCONSTANT := TThriftDictionaryImpl.Create;
  FMAPCONSTANT['hello'] := 'world';
  FMAPCONSTANT['goodnight'] := 'moon';
end;

class destructor TConstants.Destroy;
begin
  inherited;
end;
{$ELSE}
procedure TConstants_Initialize;
begin
  TConstants.FINT32CONSTANT := LongInt( 9853);
  TConstants.FMAPCONSTANT := TThriftDictionaryImpl.Create;
  TConstants.FMAPCONSTANT['hello'] := 'world';
  TConstants.FMAPCONSTANT['goodnight'] := 'moon';
end;

procedure TConstants_Finalize;
begin
end;
{$ENDIF}

//{$IFEND}


initialization
//{$IF CompilerVersion < 21.0}
{$IFDEF CompilerVersion_l21}
  TConstants_Initialize;
{$ENDIF}
//{$IFEND}

finalization
//{$IF CompilerVersion < 21.0}
{$IFDEF CompilerVersion_l21}
  TConstants_Finalize;
{$ENDIF}
//{$IFEND}


end.
