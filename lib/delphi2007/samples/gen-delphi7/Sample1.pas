(**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *)

unit Sample1;

interface

//{$I uDefine.inc}
{$ifdef CompilerVersion}
{$IF CompilerVersion >= 21}
{$DEFINE CompilerVersion_g21}
{$ELSE}
{$DEFINE CompilerVersion_l21}  
{$IFEND}
{$IF CompilerVersion >= 19} // From Tiburon / Delphi 2009 has support generic collection
{$DEFINE GEN_SUPPORT}
{$DEFINE YES_SCOPEDENUMS}
{$ELSE}
{$DEFINE GEN_NOSUPPORT} //No support Generic
{$DEFINE NO_TStringBuilder}//No Support TStringBuilder
{$DEFINE NO_SCOPEDENUMS}//No Support TStringBuilder
{$IFEND}
{$else}
{$DEFINE GEN_NOSUPPORT}
{$DEFINE NO_TStringBuilder}
{$DEFINE NO_SCOPEDENUMS}
{$DEFINE CompilerVersion_l21}  
{$endif}

uses
  Classes,
  SysUtils,
  uCollections,
  uTypes,
  Thrift,
  Thrift.Utils,
  Thrift.Protocol,
  Thrift.Transport;

const
  cSample1_Option_AnsiStr_Binary = False;
type
  TSample1 = class
  public
    type
      Iface = interface
        procedure ping();
        function add(num1: Integer; num2: Integer): Integer;
      end;

      TClient = class( TInterfacedObject, Iface)
      public
        constructor Create( prot: IProtocol); overload;
        constructor Create( const iprot: IProtocol; const oprot: IProtocol); overload;
      protected
        iprot_: IProtocol;
        oprot_: IProtocol;
        seqid_: Integer;
      public
        property InputProtocol: IProtocol read iprot_;
        property OutputProtocol: IProtocol read oprot_;
      protected
        // Iface
        procedure ping();
        function add(num1: Integer; num2: Integer): Integer;
      public
        procedure send_ping();
        procedure recv_ping();
        procedure send_add(num1: Integer; num2: Integer);
        function recv_add(): Integer;
      end;

      TProcessorImpl = class( TInterfacedObject, IProcessor)
      public
        constructor Create( iface_: Iface );
        destructor Destroy; override;
      private
        iface_: Iface;
      protected
        type
          TProcessFunction = {reference to }procedure( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface) of object;
      protected
        processMap_: IThriftDictionary;{IThriftDictionary<string, TProcessFunction>;}
      public
        function Process( const iprot: IProtocol; const oprot: IProtocol): Boolean;
        procedure ping_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure add_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
      end;

      IPing_args = interface(IBase)
      end;

      TPing_argsImpl = class(TInterfacedObject, IBase, IPing_args)
      private
        
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);
      end;

      IPing_result = interface(IBase)
      end;

      TPing_resultImpl = class(TInterfacedObject, IBase, IPing_result)
      private
        
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);
      end;

      IAdd_args = interface(IBase)
        function GetNum1: Integer;
        procedure SetNum1( const Value: Integer);
        function GetNum2: Integer;
        procedure SetNum2( const Value: Integer);

        property Num1: Integer read GetNum1 write SetNum1;
        property Num2: Integer read GetNum2 write SetNum2;

        function Get__isset_Num1: Boolean;
        function Get__isset_Num2: Boolean;

        property __isset_Num1: Boolean read Get__isset_Num1;
        property __isset_Num2: Boolean read Get__isset_Num2;
      end;

      TAdd_argsImpl = class(TInterfacedObject, IBase, IAdd_args)
      private
        FNum1: Integer;
        FNum2: Integer;
        
        F__isset_Num1: Boolean;
        F__isset_Num2: Boolean;
        
        function GetNum1: Integer;
        procedure SetNum1( const Value: Integer);
        function GetNum2: Integer;
        procedure SetNum2( const Value: Integer);

        function Get__isset_Num1: Boolean;
        function Get__isset_Num2: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Num1: Integer read GetNum1 write SetNum1;
        property Num2: Integer read GetNum2 write SetNum2;

        // isset
        property __isset_Num1: Boolean read Get__isset_Num1;
        property __isset_Num2: Boolean read Get__isset_Num2;
      end;

      IAdd_result = interface(IBase)
        function GetSuccess: Integer;
        procedure SetSuccess( const Value: Integer);

        property Success: Integer read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TAdd_resultImpl = class(TInterfacedObject, IBase, IAdd_result)
      private
        FSuccess: Integer;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: Integer;
        procedure SetSuccess( const Value: Integer);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: Integer read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

  end;
  
implementation

constructor TSample1.TClient.Create( prot: IProtocol);
begin
  Create( prot, prot );
end;

constructor TSample1.TClient.Create( const iprot: IProtocol; const oprot: IProtocol);
begin
  iprot_ := iprot;
  oprot_ := oprot;
end;

procedure TSample1.TClient.ping();
begin
  send_ping();
  recv_ping();
end;

procedure TSample1.TClient.send_ping();
var
  args : IPing_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('ping', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TPing_argsImpl.Create();
  args.Write(oprot_);
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

procedure TSample1.TClient.recv_ping();
var
  msg : IMessage;
  x : TApplicationException;
  ret : IPing_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TPing_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
end;

function TSample1.TClient.add(num1: Integer; num2: Integer): Integer;
begin
  send_add(num1, num2);
  Result := recv_add();
end;

procedure TSample1.TClient.send_add(num1: Integer; num2: Integer);
var
  args : IAdd_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('add', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TAdd_argsImpl.Create();
  args.Num1 := num1;
  args.Num2 := num2;
  args.Write(oprot_);
  args.Num1 := 0;
  args.Num2 := 0;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TSample1.TClient.recv_add(): Integer;
var
  msg : IMessage;
  x : TApplicationException;
  ret : IAdd_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TAdd_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'add failed: unknown result');
end;

constructor TSample1.TProcessorImpl.Create( iface_: Iface );
var
tmpmethod:TProcessFunction;
begin
  inherited Create;
  Self.iface_ := iface_;
  processMap_ := TThriftDictionaryImpl{<string, TProcessFunction>}.Create;
  //processMap_.AddOrSetValue( 'ping', ping_Process);
  tmpmethod:=Self.ping_Process;
  processMap_.AddOrSetValue( 'ping',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'add', add_Process);
  tmpmethod:=Self.add_Process;
  processMap_.AddOrSetValue( 'add',Pointer(@tmpmethod));
end;

destructor TSample1.TProcessorImpl.Destroy;
begin
  inherited;
end;

function TSample1.TProcessorImpl.Process( const iprot: IProtocol; const oprot: IProtocol): Boolean;
var
  msg : IMessage;
  fn : TProcessFunction;
  fnp : Pointer;
  x : TApplicationException;
begin
  try
    msg := iprot.ReadMessageBegin();
    fn := nil;
    if (not processMap_.TryGetValuePointer(msg.Name, fnp))
    or (fnp=nil) then
    begin
      TProtocolUtil.Skip(iprot, {TType.}Struct);
      iprot.ReadMessageEnd();
      x := TApplicationException.Create({TApplicationException.TExceptionType.}UnknownMethod, 'Invalid method name: ''' + msg.Name + '''');
      msg := TMessageImpl.Create(msg.Name, {TMessageType.}Exception_, msg.SeqID);
      oprot.WriteMessageBegin( msg);
      x.Write(oprot);
      oprot.WriteMessageEnd();
      oprot.Transport.Flush();
      Result := True;
      Exit;
    end;
    //fn:=TProcessFunction(fnp);
    PCardinal(@fn):=fnp;
    fn(msg.SeqID, iprot, oprot,iface_);
  except
    Result := False;
    Exit;
  end;
  Result := True;
end;

// both way processor
procedure TSample1.TProcessorImpl.ping_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: IPing_args;
  msg: IMessage;
  ret: IPing_result;
begin
  args := TPing_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TPing_resultImpl.Create;
  miface_.ping();
  msg := TMessageImpl.Create('ping', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TSample1.TProcessorImpl.add_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: IAdd_args;
  msg: IMessage;
  ret: IAdd_result;
begin
  args := TAdd_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TAdd_resultImpl.Create;
  ret.Success := miface_.add(args.Num1, args.Num2);
  args.Num1 := 0;
  args.Num2 := 0;
  msg := TMessageImpl.Create('add', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

constructor TSample1.TPing_argsImpl.Create;
begin
  inherited;
end;

destructor TSample1.TPing_argsImpl.Destroy;
begin
  inherited;
end;

procedure TSample1.TPing_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      TProtocolUtil.Skip(iprot, field_.Type_);
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TSample1.TPing_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
begin
  struc := TStructImpl.Create('ping_args');
  oprot.WriteStructBegin(struc);
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TSample1.TPing_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TSample1.TPing_resultImpl.Create;
begin
  inherited;
end;

destructor TSample1.TPing_resultImpl.Destroy;
begin
  inherited;
end;

procedure TSample1.TPing_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      TProtocolUtil.Skip(iprot, field_.Type_);
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TSample1.TPing_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
begin
  struc := TStructImpl.Create('ping_result');
  oprot.WriteStructBegin(struc);
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TSample1.TPing_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TSample1.TAdd_argsImpl.Create;
begin
  inherited;
end;

destructor TSample1.TAdd_argsImpl.Destroy;
begin
  inherited;
end;

function TSample1.TAdd_argsImpl.GetNum1: Integer;
begin
  Result := FNum1;
end;

procedure TSample1.TAdd_argsImpl.SetNum1( const Value: Integer);
begin
  F__isset_Num1 := True;
  FNum1 := Value;
end;

function TSample1.TAdd_argsImpl.Get__isset_Num1: Boolean;
begin
  Result := F__isset_Num1;
end;

function TSample1.TAdd_argsImpl.GetNum2: Integer;
begin
  Result := FNum2;
end;

procedure TSample1.TAdd_argsImpl.SetNum2( const Value: Integer);
begin
  F__isset_Num2 := True;
  FNum2 := Value;
end;

function TSample1.TAdd_argsImpl.Get__isset_Num2: Boolean;
begin
  Result := F__isset_Num2;
end;

procedure TSample1.TAdd_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            Num1 := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            Num2 := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TSample1.TAdd_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('add_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Num1) then
  begin
    field_.Name := 'num1';
    field_.Type_  := {TType.}I32;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Num1);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Num2) then
  begin
    field_.Name := 'num2';
    field_.Type_  := {TType.}I32;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Num2);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TSample1.TAdd_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Num1: ');
    sb.Append(Num1);
    sb.Append(',Num2: ');
    sb.Append(Num2);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TSample1.TAdd_resultImpl.Create;
begin
  inherited;
end;

destructor TSample1.TAdd_resultImpl.Destroy;
begin
  inherited;
end;

function TSample1.TAdd_resultImpl.GetSuccess: Integer;
begin
  Result := FSuccess;
end;

procedure TSample1.TAdd_resultImpl.SetSuccess( const Value: Integer);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TSample1.TAdd_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TSample1.TAdd_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            Success := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TSample1.TAdd_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('add_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Success) then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}I32;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Success);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TSample1.TAdd_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    sb.Append(Success);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;


initialization

finalization


end.
