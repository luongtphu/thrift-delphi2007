(**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *)

unit Thrift.Test;

interface

//{$I uDefine.inc}
{$ifdef CompilerVersion}
{$IF CompilerVersion >= 21}
{$DEFINE CompilerVersion_g21}
{$ELSE}
{$DEFINE CompilerVersion_l21}  
{$IFEND}
{$IF CompilerVersion >= 19} // From Tiburon / Delphi 2009 has support generic collection
{$DEFINE GEN_SUPPORT}
{$DEFINE YES_SCOPEDENUMS}
{$ELSE}
{$DEFINE GEN_NOSUPPORT} //No support Generic
{$DEFINE NO_TStringBuilder}//No Support TStringBuilder
{$DEFINE NO_SCOPEDENUMS}//No Support TStringBuilder
{$IFEND}
{$else}
{$DEFINE GEN_NOSUPPORT}
{$DEFINE NO_TStringBuilder}
{$DEFINE NO_SCOPEDENUMS}
{$DEFINE CompilerVersion_l21}  
{$endif}

uses
  Classes,
  SysUtils,
  uCollections,
  uTypes,
  Thrift,
  Thrift.Utils,
  Thrift.Protocol,
  Thrift.Transport;

const
  cThrift_Test_Option_AnsiStr_Binary = False;
type

//{$SCOPEDENUMS ON}

  TNumberz = (
    ONE = 1,
    TWO = 2,
    THREE = 3,
    FIVE = 5,
    SIX = 6,
    EIGHT = 8
  );

//{$SCOPEDENUMS OFF}

  TUserId = Int64;

  IBonk = interface(IBase)
    function GetMessage: string;
    procedure SetMessage( const Value: string);
    function GetType_: Integer;
    procedure SetType_( const Value: Integer);

    property Message: string read GetMessage write SetMessage;
    property Type_: Integer read GetType_ write SetType_;

    function Get__isset_Message: Boolean;
    function Get__isset_Type_: Boolean;

    property __isset_Message: Boolean read Get__isset_Message;
    property __isset_Type_: Boolean read Get__isset_Type_;
  end;

  TBonkImpl = class(TInterfacedObject, IBase, IBonk)
  private
    FMessage: string;
    FType_: Integer;
    
    F__isset_Message: Boolean;
    F__isset_Type_: Boolean;
    
    function GetMessage: string;
    procedure SetMessage( const Value: string);
    function GetType_: Integer;
    procedure SetType_( const Value: Integer);

    function Get__isset_Message: Boolean;
    function Get__isset_Type_: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property Message: string read GetMessage write SetMessage;
    property Type_: Integer read GetType_ write SetType_;

    // isset
    property __isset_Message: Boolean read Get__isset_Message;
    property __isset_Type_: Boolean read Get__isset_Type_;
  end;

  TMapType = IThriftDictionary;

  IBools = interface(IBase)
    function GetIm_true: Boolean;
    procedure SetIm_true( const Value: Boolean);
    function GetIm_false: Boolean;
    procedure SetIm_false( const Value: Boolean);

    property Im_true: Boolean read GetIm_true write SetIm_true;
    property Im_false: Boolean read GetIm_false write SetIm_false;

    function Get__isset_Im_true: Boolean;
    function Get__isset_Im_false: Boolean;

    property __isset_Im_true: Boolean read Get__isset_Im_true;
    property __isset_Im_false: Boolean read Get__isset_Im_false;
  end;

  TBoolsImpl = class(TInterfacedObject, IBase, IBools)
  private
    FIm_true: Boolean;
    FIm_false: Boolean;
    
    F__isset_Im_true: Boolean;
    F__isset_Im_false: Boolean;
    
    function GetIm_true: Boolean;
    procedure SetIm_true( const Value: Boolean);
    function GetIm_false: Boolean;
    procedure SetIm_false( const Value: Boolean);

    function Get__isset_Im_true: Boolean;
    function Get__isset_Im_false: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property Im_true: Boolean read GetIm_true write SetIm_true;
    property Im_false: Boolean read GetIm_false write SetIm_false;

    // isset
    property __isset_Im_true: Boolean read Get__isset_Im_true;
    property __isset_Im_false: Boolean read Get__isset_Im_false;
  end;

  IXtruct = interface(IBase)
    function GetString_thing: string;
    procedure SetString_thing( const Value: string);
    function GetByte_thing: ShortInt;
    procedure SetByte_thing( const Value: ShortInt);
    function GetI32_thing: Integer;
    procedure SetI32_thing( const Value: Integer);
    function GetI64_thing: Int64;
    procedure SetI64_thing( const Value: Int64);

    property String_thing: string read GetString_thing write SetString_thing;
    property Byte_thing: ShortInt read GetByte_thing write SetByte_thing;
    property I32_thing: Integer read GetI32_thing write SetI32_thing;
    property I64_thing: Int64 read GetI64_thing write SetI64_thing;

    function Get__isset_String_thing: Boolean;
    function Get__isset_Byte_thing: Boolean;
    function Get__isset_I32_thing: Boolean;
    function Get__isset_I64_thing: Boolean;

    property __isset_String_thing: Boolean read Get__isset_String_thing;
    property __isset_Byte_thing: Boolean read Get__isset_Byte_thing;
    property __isset_I32_thing: Boolean read Get__isset_I32_thing;
    property __isset_I64_thing: Boolean read Get__isset_I64_thing;
  end;

  TXtructImpl = class(TInterfacedObject, IBase, IXtruct)
  private
    FString_thing: string;
    FByte_thing: ShortInt;
    FI32_thing: Integer;
    FI64_thing: Int64;
    
    F__isset_String_thing: Boolean;
    F__isset_Byte_thing: Boolean;
    F__isset_I32_thing: Boolean;
    F__isset_I64_thing: Boolean;
    
    function GetString_thing: string;
    procedure SetString_thing( const Value: string);
    function GetByte_thing: ShortInt;
    procedure SetByte_thing( const Value: ShortInt);
    function GetI32_thing: Integer;
    procedure SetI32_thing( const Value: Integer);
    function GetI64_thing: Int64;
    procedure SetI64_thing( const Value: Int64);

    function Get__isset_String_thing: Boolean;
    function Get__isset_Byte_thing: Boolean;
    function Get__isset_I32_thing: Boolean;
    function Get__isset_I64_thing: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property String_thing: string read GetString_thing write SetString_thing;
    property Byte_thing: ShortInt read GetByte_thing write SetByte_thing;
    property I32_thing: Integer read GetI32_thing write SetI32_thing;
    property I64_thing: Int64 read GetI64_thing write SetI64_thing;

    // isset
    property __isset_String_thing: Boolean read Get__isset_String_thing;
    property __isset_Byte_thing: Boolean read Get__isset_Byte_thing;
    property __isset_I32_thing: Boolean read Get__isset_I32_thing;
    property __isset_I64_thing: Boolean read Get__isset_I64_thing;
  end;

  IXtruct2 = interface(IBase)
    function GetByte_thing: ShortInt;
    procedure SetByte_thing( const Value: ShortInt);
    function GetStruct_thing: IXtruct;
    procedure SetStruct_thing( const Value: IXtruct);
    function GetI32_thing: Integer;
    procedure SetI32_thing( const Value: Integer);

    property Byte_thing: ShortInt read GetByte_thing write SetByte_thing;
    property Struct_thing: IXtruct read GetStruct_thing write SetStruct_thing;
    property I32_thing: Integer read GetI32_thing write SetI32_thing;

    function Get__isset_Byte_thing: Boolean;
    function Get__isset_Struct_thing: Boolean;
    function Get__isset_I32_thing: Boolean;

    property __isset_Byte_thing: Boolean read Get__isset_Byte_thing;
    property __isset_Struct_thing: Boolean read Get__isset_Struct_thing;
    property __isset_I32_thing: Boolean read Get__isset_I32_thing;
  end;

  TXtruct2Impl = class(TInterfacedObject, IBase, IXtruct2)
  private
    FByte_thing: ShortInt;
    FStruct_thing: IXtruct;
    FI32_thing: Integer;
    
    F__isset_Byte_thing: Boolean;
    F__isset_Struct_thing: Boolean;
    F__isset_I32_thing: Boolean;
    
    function GetByte_thing: ShortInt;
    procedure SetByte_thing( const Value: ShortInt);
    function GetStruct_thing: IXtruct;
    procedure SetStruct_thing( const Value: IXtruct);
    function GetI32_thing: Integer;
    procedure SetI32_thing( const Value: Integer);

    function Get__isset_Byte_thing: Boolean;
    function Get__isset_Struct_thing: Boolean;
    function Get__isset_I32_thing: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property Byte_thing: ShortInt read GetByte_thing write SetByte_thing;
    property Struct_thing: IXtruct read GetStruct_thing write SetStruct_thing;
    property I32_thing: Integer read GetI32_thing write SetI32_thing;

    // isset
    property __isset_Byte_thing: Boolean read Get__isset_Byte_thing;
    property __isset_Struct_thing: Boolean read Get__isset_Struct_thing;
    property __isset_I32_thing: Boolean read Get__isset_I32_thing;
  end;

  IXtruct3 = interface(IBase)
    function GetString_thing: string;
    procedure SetString_thing( const Value: string);
    function GetChanged: Integer;
    procedure SetChanged( const Value: Integer);
    function GetI32_thing: Integer;
    procedure SetI32_thing( const Value: Integer);
    function GetI64_thing: Int64;
    procedure SetI64_thing( const Value: Int64);

    property String_thing: string read GetString_thing write SetString_thing;
    property Changed: Integer read GetChanged write SetChanged;
    property I32_thing: Integer read GetI32_thing write SetI32_thing;
    property I64_thing: Int64 read GetI64_thing write SetI64_thing;

    function Get__isset_String_thing: Boolean;
    function Get__isset_Changed: Boolean;
    function Get__isset_I32_thing: Boolean;
    function Get__isset_I64_thing: Boolean;

    property __isset_String_thing: Boolean read Get__isset_String_thing;
    property __isset_Changed: Boolean read Get__isset_Changed;
    property __isset_I32_thing: Boolean read Get__isset_I32_thing;
    property __isset_I64_thing: Boolean read Get__isset_I64_thing;
  end;

  TXtruct3Impl = class(TInterfacedObject, IBase, IXtruct3)
  private
    FString_thing: string;
    FChanged: Integer;
    FI32_thing: Integer;
    FI64_thing: Int64;
    
    F__isset_String_thing: Boolean;
    F__isset_Changed: Boolean;
    F__isset_I32_thing: Boolean;
    F__isset_I64_thing: Boolean;
    
    function GetString_thing: string;
    procedure SetString_thing( const Value: string);
    function GetChanged: Integer;
    procedure SetChanged( const Value: Integer);
    function GetI32_thing: Integer;
    procedure SetI32_thing( const Value: Integer);
    function GetI64_thing: Int64;
    procedure SetI64_thing( const Value: Int64);

    function Get__isset_String_thing: Boolean;
    function Get__isset_Changed: Boolean;
    function Get__isset_I32_thing: Boolean;
    function Get__isset_I64_thing: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property String_thing: string read GetString_thing write SetString_thing;
    property Changed: Integer read GetChanged write SetChanged;
    property I32_thing: Integer read GetI32_thing write SetI32_thing;
    property I64_thing: Int64 read GetI64_thing write SetI64_thing;

    // isset
    property __isset_String_thing: Boolean read Get__isset_String_thing;
    property __isset_Changed: Boolean read Get__isset_Changed;
    property __isset_I32_thing: Boolean read Get__isset_I32_thing;
    property __isset_I64_thing: Boolean read Get__isset_I64_thing;
  end;

  IInsanity = interface(IBase)
    function GetUserMap: IThriftDictionary;
    procedure SetUserMap( const Value: IThriftDictionary);
    function GetXtructs: IThriftList;
    procedure SetXtructs( const Value: IThriftList);

    property UserMap: IThriftDictionary read GetUserMap write SetUserMap;
    property Xtructs: IThriftList read GetXtructs write SetXtructs;

    function Get__isset_UserMap: Boolean;
    function Get__isset_Xtructs: Boolean;

    property __isset_UserMap: Boolean read Get__isset_UserMap;
    property __isset_Xtructs: Boolean read Get__isset_Xtructs;
  end;

  TInsanityImpl = class(TInterfacedObject, IBase, IInsanity)
  private
    FUserMap: IThriftDictionary;
    FXtructs: IThriftList;
    
    F__isset_UserMap: Boolean;
    F__isset_Xtructs: Boolean;
    
    function GetUserMap: IThriftDictionary;
    procedure SetUserMap( const Value: IThriftDictionary);
    function GetXtructs: IThriftList;
    procedure SetXtructs( const Value: IThriftList);

    function Get__isset_UserMap: Boolean;
    function Get__isset_Xtructs: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property UserMap: IThriftDictionary read GetUserMap write SetUserMap;
    property Xtructs: IThriftList read GetXtructs write SetXtructs;

    // isset
    property __isset_UserMap: Boolean read Get__isset_UserMap;
    property __isset_Xtructs: Boolean read Get__isset_Xtructs;
  end;

  ICrazyNesting = interface(IBase)
    function GetString_field: string;
    procedure SetString_field( const Value: string);
    function GetSet_field: IHashSet;
    procedure SetSet_field( const Value: IHashSet);
    function GetList_field: IThriftList;
    procedure SetList_field( const Value: IThriftList);
    function GetBinary_field: TBytes;
    procedure SetBinary_field( const Value: TBytes);

    property String_field: string read GetString_field write SetString_field;
    property Set_field: IHashSet read GetSet_field write SetSet_field;
    property List_field: IThriftList read GetList_field write SetList_field;
    property Binary_field: TBytes read GetBinary_field write SetBinary_field;

    function Get__isset_String_field: Boolean;
    function Get__isset_Set_field: Boolean;
    function Get__isset_Binary_field: Boolean;

    property __isset_String_field: Boolean read Get__isset_String_field;
    property __isset_Set_field: Boolean read Get__isset_Set_field;
    property __isset_Binary_field: Boolean read Get__isset_Binary_field;
  end;

  TCrazyNestingImpl = class(TInterfacedObject, IBase, ICrazyNesting)
  private
    FString_field: string;
    FSet_field: IHashSet;
    FList_field: IThriftList;
    FBinary_field: TBytes;
    
    F__isset_String_field: Boolean;
    F__isset_Set_field: Boolean;
    F__isset_Binary_field: Boolean;
    
    function GetString_field: string;
    procedure SetString_field( const Value: string);
    function GetSet_field: IHashSet;
    procedure SetSet_field( const Value: IHashSet);
    function GetList_field: IThriftList;
    procedure SetList_field( const Value: IThriftList);
    function GetBinary_field: TBytes;
    procedure SetBinary_field( const Value: TBytes);

    function Get__isset_String_field: Boolean;
    function Get__isset_Set_field: Boolean;
    function Get__isset_Binary_field: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property String_field: string read GetString_field write SetString_field;
    property Set_field: IHashSet read GetSet_field write SetSet_field;
    property List_field: IThriftList read GetList_field write SetList_field;
    property Binary_field: TBytes read GetBinary_field write SetBinary_field;

    // isset
    property __isset_String_field: Boolean read Get__isset_String_field;
    property __isset_Set_field: Boolean read Get__isset_Set_field;
    property __isset_Binary_field: Boolean read Get__isset_Binary_field;
  end;

  TXception = class(TException)
  public
    type
      IXceptionFactory = interface(IBase)
        function GetErrorCode: Integer;
        procedure SetErrorCode( const Value: Integer);
        function GetMessage_: string;
        procedure SetMessage_( const Value: string);

        // Create Exception Object
        function CreateException: TXception;

        property ErrorCode: Integer read GetErrorCode write SetErrorCode;
        property Message_: string read GetMessage_ write SetMessage_;

        function Get__isset_ErrorCode: Boolean;
        function Get__isset_Message_: Boolean;

        property __isset_ErrorCode: Boolean read Get__isset_ErrorCode;
        property __isset_Message_: Boolean read Get__isset_Message_;
      end;

      TXceptionFactoryImpl = class(TInterfacedObject, IBase, IXceptionFactory)
      private
        FErrorCode: Integer;
        FMessage_: string;
        
        F__isset_ErrorCode: Boolean;
        F__isset_Message_: Boolean;
        
        function GetErrorCode: Integer;
        procedure SetErrorCode( const Value: Integer);
        function GetMessage_: string;
        procedure SetMessage_( const Value: string);

        function Get__isset_ErrorCode: Boolean;
        function Get__isset_Message_: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Create Exception Object
        function CreateException: TXception;

        // Properties
        property ErrorCode: Integer read GetErrorCode write SetErrorCode;
        property Message_: string read GetMessage_ write SetMessage_;

        // isset
        property __isset_ErrorCode: Boolean read Get__isset_ErrorCode;
        property __isset_Message_: Boolean read Get__isset_Message_;
      end;

  private
    FXceptionFactory :IXceptionFactory;

    FErrorCode: Integer;
    FMessage_: string;
    
    F__isset_ErrorCode: Boolean;
    F__isset_Message_: Boolean;
    
    function GetErrorCode: Integer;
    procedure SetErrorCode( const Value: Integer);
    function GetMessage_: string;
    procedure SetMessage_( const Value: string);

    function Get__isset_ErrorCode: Boolean;
    function Get__isset_Message_: Boolean;
  public
    constructor Create; overload;
    constructor Create( AErrorCode: Integer; const AMessage: string); overload;
    destructor Destroy; override;

    function ToString: string; {override}

    // Exception Factory
    property XceptionFactory: IXceptionFactory read FXceptionFactory write FXceptionFactory;

    // Properties
    property ErrorCode: Integer read GetErrorCode write SetErrorCode;
    property Message_: string read GetMessage_ write SetMessage_;

    // isset
    property __isset_ErrorCode: Boolean read Get__isset_ErrorCode;
    property __isset_Message_: Boolean read Get__isset_Message_;
  end;

  TXception2 = class(TException)
  public
    type
      IXception2Factory = interface(IBase)
        function GetErrorCode: Integer;
        procedure SetErrorCode( const Value: Integer);
        function GetStruct_thing: IXtruct;
        procedure SetStruct_thing( const Value: IXtruct);

        // Create Exception Object
        function CreateException: TXception2;

        property ErrorCode: Integer read GetErrorCode write SetErrorCode;
        property Struct_thing: IXtruct read GetStruct_thing write SetStruct_thing;

        function Get__isset_ErrorCode: Boolean;
        function Get__isset_Struct_thing: Boolean;

        property __isset_ErrorCode: Boolean read Get__isset_ErrorCode;
        property __isset_Struct_thing: Boolean read Get__isset_Struct_thing;
      end;

      TXception2FactoryImpl = class(TInterfacedObject, IBase, IXception2Factory)
      private
        FErrorCode: Integer;
        FStruct_thing: IXtruct;
        
        F__isset_ErrorCode: Boolean;
        F__isset_Struct_thing: Boolean;
        
        function GetErrorCode: Integer;
        procedure SetErrorCode( const Value: Integer);
        function GetStruct_thing: IXtruct;
        procedure SetStruct_thing( const Value: IXtruct);

        function Get__isset_ErrorCode: Boolean;
        function Get__isset_Struct_thing: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Create Exception Object
        function CreateException: TXception2;

        // Properties
        property ErrorCode: Integer read GetErrorCode write SetErrorCode;
        property Struct_thing: IXtruct read GetStruct_thing write SetStruct_thing;

        // isset
        property __isset_ErrorCode: Boolean read Get__isset_ErrorCode;
        property __isset_Struct_thing: Boolean read Get__isset_Struct_thing;
      end;

  private
    FXception2Factory :IXception2Factory;

    FErrorCode: Integer;
    FStruct_thing: IXtruct;
    
    F__isset_ErrorCode: Boolean;
    F__isset_Struct_thing: Boolean;
    
    function GetErrorCode: Integer;
    procedure SetErrorCode( const Value: Integer);
    function GetStruct_thing: IXtruct;
    procedure SetStruct_thing( const Value: IXtruct);

    function Get__isset_ErrorCode: Boolean;
    function Get__isset_Struct_thing: Boolean;
  public
    constructor Create; overload;
    constructor Create( AErrorCode: Integer; const AStruct_thing: IXtruct); overload;
    destructor Destroy; override;

    function ToString: string; {override}

    // Exception Factory
    property Xception2Factory: IXception2Factory read FXception2Factory write FXception2Factory;

    // Properties
    property ErrorCode: Integer read GetErrorCode write SetErrorCode;
    property Struct_thing: IXtruct read GetStruct_thing write SetStruct_thing;

    // isset
    property __isset_ErrorCode: Boolean read Get__isset_ErrorCode;
    property __isset_Struct_thing: Boolean read Get__isset_Struct_thing;
  end;

  IEmptyStruct = interface(IBase)
  end;

  TEmptyStructImpl = class(TInterfacedObject, IBase, IEmptyStruct)
  private
    
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);
  end;

  IOneField = interface(IBase)
    function GetField: IEmptyStruct;
    procedure SetField( const Value: IEmptyStruct);

    property Field: IEmptyStruct read GetField write SetField;

    function Get__isset_Field: Boolean;

    property __isset_Field: Boolean read Get__isset_Field;
  end;

  TOneFieldImpl = class(TInterfacedObject, IBase, IOneField)
  private
    FField: IEmptyStruct;
    
    F__isset_Field: Boolean;
    
    function GetField: IEmptyStruct;
    procedure SetField( const Value: IEmptyStruct);

    function Get__isset_Field: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property Field: IEmptyStruct read GetField write SetField;

    // isset
    property __isset_Field: Boolean read Get__isset_Field;
  end;

  IVersioningTestV1 = interface(IBase)
    function GetBegin_in_both: Integer;
    procedure SetBegin_in_both( const Value: Integer);
    function GetOld_string: string;
    procedure SetOld_string( const Value: string);
    function GetEnd_in_both: Integer;
    procedure SetEnd_in_both( const Value: Integer);

    property Begin_in_both: Integer read GetBegin_in_both write SetBegin_in_both;
    property Old_string: string read GetOld_string write SetOld_string;
    property End_in_both: Integer read GetEnd_in_both write SetEnd_in_both;

    function Get__isset_Begin_in_both: Boolean;
    function Get__isset_Old_string: Boolean;
    function Get__isset_End_in_both: Boolean;

    property __isset_Begin_in_both: Boolean read Get__isset_Begin_in_both;
    property __isset_Old_string: Boolean read Get__isset_Old_string;
    property __isset_End_in_both: Boolean read Get__isset_End_in_both;
  end;

  TVersioningTestV1Impl = class(TInterfacedObject, IBase, IVersioningTestV1)
  private
    FBegin_in_both: Integer;
    FOld_string: string;
    FEnd_in_both: Integer;
    
    F__isset_Begin_in_both: Boolean;
    F__isset_Old_string: Boolean;
    F__isset_End_in_both: Boolean;
    
    function GetBegin_in_both: Integer;
    procedure SetBegin_in_both( const Value: Integer);
    function GetOld_string: string;
    procedure SetOld_string( const Value: string);
    function GetEnd_in_both: Integer;
    procedure SetEnd_in_both( const Value: Integer);

    function Get__isset_Begin_in_both: Boolean;
    function Get__isset_Old_string: Boolean;
    function Get__isset_End_in_both: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property Begin_in_both: Integer read GetBegin_in_both write SetBegin_in_both;
    property Old_string: string read GetOld_string write SetOld_string;
    property End_in_both: Integer read GetEnd_in_both write SetEnd_in_both;

    // isset
    property __isset_Begin_in_both: Boolean read Get__isset_Begin_in_both;
    property __isset_Old_string: Boolean read Get__isset_Old_string;
    property __isset_End_in_both: Boolean read Get__isset_End_in_both;
  end;

  IVersioningTestV2 = interface(IBase)
    function GetBegin_in_both: Integer;
    procedure SetBegin_in_both( const Value: Integer);
    function GetNewint: Integer;
    procedure SetNewint( const Value: Integer);
    function GetNewbyte: ShortInt;
    procedure SetNewbyte( const Value: ShortInt);
    function GetNewshort: SmallInt;
    procedure SetNewshort( const Value: SmallInt);
    function GetNewlong: Int64;
    procedure SetNewlong( const Value: Int64);
    function GetNewdouble: Double;
    procedure SetNewdouble( const Value: Double);
    function GetNewstruct: IBonk;
    procedure SetNewstruct( const Value: IBonk);
    function GetNewlist: IThriftList;
    procedure SetNewlist( const Value: IThriftList);
    function GetNewset: IHashSet;
    procedure SetNewset( const Value: IHashSet);
    function GetNewmap: IThriftDictionary;
    procedure SetNewmap( const Value: IThriftDictionary);
    function GetNewstring: string;
    procedure SetNewstring( const Value: string);
    function GetEnd_in_both: Integer;
    procedure SetEnd_in_both( const Value: Integer);

    property Begin_in_both: Integer read GetBegin_in_both write SetBegin_in_both;
    property Newint: Integer read GetNewint write SetNewint;
    property Newbyte: ShortInt read GetNewbyte write SetNewbyte;
    property Newshort: SmallInt read GetNewshort write SetNewshort;
    property Newlong: Int64 read GetNewlong write SetNewlong;
    property Newdouble: Double read GetNewdouble write SetNewdouble;
    property Newstruct: IBonk read GetNewstruct write SetNewstruct;
    property Newlist: IThriftList read GetNewlist write SetNewlist;
    property Newset: IHashSet read GetNewset write SetNewset;
    property Newmap: IThriftDictionary read GetNewmap write SetNewmap;
    property Newstring: string read GetNewstring write SetNewstring;
    property End_in_both: Integer read GetEnd_in_both write SetEnd_in_both;

    function Get__isset_Begin_in_both: Boolean;
    function Get__isset_Newint: Boolean;
    function Get__isset_Newbyte: Boolean;
    function Get__isset_Newshort: Boolean;
    function Get__isset_Newlong: Boolean;
    function Get__isset_Newdouble: Boolean;
    function Get__isset_Newstruct: Boolean;
    function Get__isset_Newlist: Boolean;
    function Get__isset_Newset: Boolean;
    function Get__isset_Newmap: Boolean;
    function Get__isset_Newstring: Boolean;
    function Get__isset_End_in_both: Boolean;

    property __isset_Begin_in_both: Boolean read Get__isset_Begin_in_both;
    property __isset_Newint: Boolean read Get__isset_Newint;
    property __isset_Newbyte: Boolean read Get__isset_Newbyte;
    property __isset_Newshort: Boolean read Get__isset_Newshort;
    property __isset_Newlong: Boolean read Get__isset_Newlong;
    property __isset_Newdouble: Boolean read Get__isset_Newdouble;
    property __isset_Newstruct: Boolean read Get__isset_Newstruct;
    property __isset_Newlist: Boolean read Get__isset_Newlist;
    property __isset_Newset: Boolean read Get__isset_Newset;
    property __isset_Newmap: Boolean read Get__isset_Newmap;
    property __isset_Newstring: Boolean read Get__isset_Newstring;
    property __isset_End_in_both: Boolean read Get__isset_End_in_both;
  end;

  TVersioningTestV2Impl = class(TInterfacedObject, IBase, IVersioningTestV2)
  private
    FBegin_in_both: Integer;
    FNewint: Integer;
    FNewbyte: ShortInt;
    FNewshort: SmallInt;
    FNewlong: Int64;
    FNewdouble: Double;
    FNewstruct: IBonk;
    FNewlist: IThriftList;
    FNewset: IHashSet;
    FNewmap: IThriftDictionary;
    FNewstring: string;
    FEnd_in_both: Integer;
    
    F__isset_Begin_in_both: Boolean;
    F__isset_Newint: Boolean;
    F__isset_Newbyte: Boolean;
    F__isset_Newshort: Boolean;
    F__isset_Newlong: Boolean;
    F__isset_Newdouble: Boolean;
    F__isset_Newstruct: Boolean;
    F__isset_Newlist: Boolean;
    F__isset_Newset: Boolean;
    F__isset_Newmap: Boolean;
    F__isset_Newstring: Boolean;
    F__isset_End_in_both: Boolean;
    
    function GetBegin_in_both: Integer;
    procedure SetBegin_in_both( const Value: Integer);
    function GetNewint: Integer;
    procedure SetNewint( const Value: Integer);
    function GetNewbyte: ShortInt;
    procedure SetNewbyte( const Value: ShortInt);
    function GetNewshort: SmallInt;
    procedure SetNewshort( const Value: SmallInt);
    function GetNewlong: Int64;
    procedure SetNewlong( const Value: Int64);
    function GetNewdouble: Double;
    procedure SetNewdouble( const Value: Double);
    function GetNewstruct: IBonk;
    procedure SetNewstruct( const Value: IBonk);
    function GetNewlist: IThriftList;
    procedure SetNewlist( const Value: IThriftList);
    function GetNewset: IHashSet;
    procedure SetNewset( const Value: IHashSet);
    function GetNewmap: IThriftDictionary;
    procedure SetNewmap( const Value: IThriftDictionary);
    function GetNewstring: string;
    procedure SetNewstring( const Value: string);
    function GetEnd_in_both: Integer;
    procedure SetEnd_in_both( const Value: Integer);

    function Get__isset_Begin_in_both: Boolean;
    function Get__isset_Newint: Boolean;
    function Get__isset_Newbyte: Boolean;
    function Get__isset_Newshort: Boolean;
    function Get__isset_Newlong: Boolean;
    function Get__isset_Newdouble: Boolean;
    function Get__isset_Newstruct: Boolean;
    function Get__isset_Newlist: Boolean;
    function Get__isset_Newset: Boolean;
    function Get__isset_Newmap: Boolean;
    function Get__isset_Newstring: Boolean;
    function Get__isset_End_in_both: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property Begin_in_both: Integer read GetBegin_in_both write SetBegin_in_both;
    property Newint: Integer read GetNewint write SetNewint;
    property Newbyte: ShortInt read GetNewbyte write SetNewbyte;
    property Newshort: SmallInt read GetNewshort write SetNewshort;
    property Newlong: Int64 read GetNewlong write SetNewlong;
    property Newdouble: Double read GetNewdouble write SetNewdouble;
    property Newstruct: IBonk read GetNewstruct write SetNewstruct;
    property Newlist: IThriftList read GetNewlist write SetNewlist;
    property Newset: IHashSet read GetNewset write SetNewset;
    property Newmap: IThriftDictionary read GetNewmap write SetNewmap;
    property Newstring: string read GetNewstring write SetNewstring;
    property End_in_both: Integer read GetEnd_in_both write SetEnd_in_both;

    // isset
    property __isset_Begin_in_both: Boolean read Get__isset_Begin_in_both;
    property __isset_Newint: Boolean read Get__isset_Newint;
    property __isset_Newbyte: Boolean read Get__isset_Newbyte;
    property __isset_Newshort: Boolean read Get__isset_Newshort;
    property __isset_Newlong: Boolean read Get__isset_Newlong;
    property __isset_Newdouble: Boolean read Get__isset_Newdouble;
    property __isset_Newstruct: Boolean read Get__isset_Newstruct;
    property __isset_Newlist: Boolean read Get__isset_Newlist;
    property __isset_Newset: Boolean read Get__isset_Newset;
    property __isset_Newmap: Boolean read Get__isset_Newmap;
    property __isset_Newstring: Boolean read Get__isset_Newstring;
    property __isset_End_in_both: Boolean read Get__isset_End_in_both;
  end;

  IListTypeVersioningV1 = interface(IBase)
    function GetMyints: IThriftList;
    procedure SetMyints( const Value: IThriftList);
    function GetHello: string;
    procedure SetHello( const Value: string);

    property Myints: IThriftList read GetMyints write SetMyints;
    property Hello: string read GetHello write SetHello;

    function Get__isset_Myints: Boolean;
    function Get__isset_Hello: Boolean;

    property __isset_Myints: Boolean read Get__isset_Myints;
    property __isset_Hello: Boolean read Get__isset_Hello;
  end;

  TListTypeVersioningV1Impl = class(TInterfacedObject, IBase, IListTypeVersioningV1)
  private
    FMyints: IThriftList;
    FHello: string;
    
    F__isset_Myints: Boolean;
    F__isset_Hello: Boolean;
    
    function GetMyints: IThriftList;
    procedure SetMyints( const Value: IThriftList);
    function GetHello: string;
    procedure SetHello( const Value: string);

    function Get__isset_Myints: Boolean;
    function Get__isset_Hello: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property Myints: IThriftList read GetMyints write SetMyints;
    property Hello: string read GetHello write SetHello;

    // isset
    property __isset_Myints: Boolean read Get__isset_Myints;
    property __isset_Hello: Boolean read Get__isset_Hello;
  end;

  IListTypeVersioningV2 = interface(IBase)
    function GetStrings: IThriftList;
    procedure SetStrings( const Value: IThriftList);
    function GetHello: string;
    procedure SetHello( const Value: string);

    property Strings: IThriftList read GetStrings write SetStrings;
    property Hello: string read GetHello write SetHello;

    function Get__isset_Strings: Boolean;
    function Get__isset_Hello: Boolean;

    property __isset_Strings: Boolean read Get__isset_Strings;
    property __isset_Hello: Boolean read Get__isset_Hello;
  end;

  TListTypeVersioningV2Impl = class(TInterfacedObject, IBase, IListTypeVersioningV2)
  private
    FStrings: IThriftList;
    FHello: string;
    
    F__isset_Strings: Boolean;
    F__isset_Hello: Boolean;
    
    function GetStrings: IThriftList;
    procedure SetStrings( const Value: IThriftList);
    function GetHello: string;
    procedure SetHello( const Value: string);

    function Get__isset_Strings: Boolean;
    function Get__isset_Hello: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property Strings: IThriftList read GetStrings write SetStrings;
    property Hello: string read GetHello write SetHello;

    // isset
    property __isset_Strings: Boolean read Get__isset_Strings;
    property __isset_Hello: Boolean read Get__isset_Hello;
  end;

  IGuessProtocolStruct = interface(IBase)
    function GetMap_field: IThriftDictionary;
    procedure SetMap_field( const Value: IThriftDictionary);

    property Map_field: IThriftDictionary read GetMap_field write SetMap_field;

    function Get__isset_Map_field: Boolean;

    property __isset_Map_field: Boolean read Get__isset_Map_field;
  end;

  TGuessProtocolStructImpl = class(TInterfacedObject, IBase, IGuessProtocolStruct)
  private
    FMap_field: IThriftDictionary;
    
    F__isset_Map_field: Boolean;
    
    function GetMap_field: IThriftDictionary;
    procedure SetMap_field( const Value: IThriftDictionary);

    function Get__isset_Map_field: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property Map_field: IThriftDictionary read GetMap_field write SetMap_field;

    // isset
    property __isset_Map_field: Boolean read Get__isset_Map_field;
  end;

  ILargeDeltas = interface(IBase)
    function GetB1: IBools;
    procedure SetB1( const Value: IBools);
    function GetB10: IBools;
    procedure SetB10( const Value: IBools);
    function GetB100: IBools;
    procedure SetB100( const Value: IBools);
    function GetCheck_true: Boolean;
    procedure SetCheck_true( const Value: Boolean);
    function GetB1000: IBools;
    procedure SetB1000( const Value: IBools);
    function GetCheck_false: Boolean;
    procedure SetCheck_false( const Value: Boolean);
    function GetVertwo2000: IVersioningTestV2;
    procedure SetVertwo2000( const Value: IVersioningTestV2);
    function GetA_set2500: IHashSet;
    procedure SetA_set2500( const Value: IHashSet);
    function GetVertwo3000: IVersioningTestV2;
    procedure SetVertwo3000( const Value: IVersioningTestV2);
    function GetBig_numbers: IThriftList;
    procedure SetBig_numbers( const Value: IThriftList);

    property B1: IBools read GetB1 write SetB1;
    property B10: IBools read GetB10 write SetB10;
    property B100: IBools read GetB100 write SetB100;
    property Check_true: Boolean read GetCheck_true write SetCheck_true;
    property B1000: IBools read GetB1000 write SetB1000;
    property Check_false: Boolean read GetCheck_false write SetCheck_false;
    property Vertwo2000: IVersioningTestV2 read GetVertwo2000 write SetVertwo2000;
    property A_set2500: IHashSet read GetA_set2500 write SetA_set2500;
    property Vertwo3000: IVersioningTestV2 read GetVertwo3000 write SetVertwo3000;
    property Big_numbers: IThriftList read GetBig_numbers write SetBig_numbers;

    function Get__isset_B1: Boolean;
    function Get__isset_B10: Boolean;
    function Get__isset_B100: Boolean;
    function Get__isset_Check_true: Boolean;
    function Get__isset_B1000: Boolean;
    function Get__isset_Check_false: Boolean;
    function Get__isset_Vertwo2000: Boolean;
    function Get__isset_A_set2500: Boolean;
    function Get__isset_Vertwo3000: Boolean;
    function Get__isset_Big_numbers: Boolean;

    property __isset_B1: Boolean read Get__isset_B1;
    property __isset_B10: Boolean read Get__isset_B10;
    property __isset_B100: Boolean read Get__isset_B100;
    property __isset_Check_true: Boolean read Get__isset_Check_true;
    property __isset_B1000: Boolean read Get__isset_B1000;
    property __isset_Check_false: Boolean read Get__isset_Check_false;
    property __isset_Vertwo2000: Boolean read Get__isset_Vertwo2000;
    property __isset_A_set2500: Boolean read Get__isset_A_set2500;
    property __isset_Vertwo3000: Boolean read Get__isset_Vertwo3000;
    property __isset_Big_numbers: Boolean read Get__isset_Big_numbers;
  end;

  TLargeDeltasImpl = class(TInterfacedObject, IBase, ILargeDeltas)
  private
    FB1: IBools;
    FB10: IBools;
    FB100: IBools;
    FCheck_true: Boolean;
    FB1000: IBools;
    FCheck_false: Boolean;
    FVertwo2000: IVersioningTestV2;
    FA_set2500: IHashSet;
    FVertwo3000: IVersioningTestV2;
    FBig_numbers: IThriftList;
    
    F__isset_B1: Boolean;
    F__isset_B10: Boolean;
    F__isset_B100: Boolean;
    F__isset_Check_true: Boolean;
    F__isset_B1000: Boolean;
    F__isset_Check_false: Boolean;
    F__isset_Vertwo2000: Boolean;
    F__isset_A_set2500: Boolean;
    F__isset_Vertwo3000: Boolean;
    F__isset_Big_numbers: Boolean;
    
    function GetB1: IBools;
    procedure SetB1( const Value: IBools);
    function GetB10: IBools;
    procedure SetB10( const Value: IBools);
    function GetB100: IBools;
    procedure SetB100( const Value: IBools);
    function GetCheck_true: Boolean;
    procedure SetCheck_true( const Value: Boolean);
    function GetB1000: IBools;
    procedure SetB1000( const Value: IBools);
    function GetCheck_false: Boolean;
    procedure SetCheck_false( const Value: Boolean);
    function GetVertwo2000: IVersioningTestV2;
    procedure SetVertwo2000( const Value: IVersioningTestV2);
    function GetA_set2500: IHashSet;
    procedure SetA_set2500( const Value: IHashSet);
    function GetVertwo3000: IVersioningTestV2;
    procedure SetVertwo3000( const Value: IVersioningTestV2);
    function GetBig_numbers: IThriftList;
    procedure SetBig_numbers( const Value: IThriftList);

    function Get__isset_B1: Boolean;
    function Get__isset_B10: Boolean;
    function Get__isset_B100: Boolean;
    function Get__isset_Check_true: Boolean;
    function Get__isset_B1000: Boolean;
    function Get__isset_Check_false: Boolean;
    function Get__isset_Vertwo2000: Boolean;
    function Get__isset_A_set2500: Boolean;
    function Get__isset_Vertwo3000: Boolean;
    function Get__isset_Big_numbers: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property B1: IBools read GetB1 write SetB1;
    property B10: IBools read GetB10 write SetB10;
    property B100: IBools read GetB100 write SetB100;
    property Check_true: Boolean read GetCheck_true write SetCheck_true;
    property B1000: IBools read GetB1000 write SetB1000;
    property Check_false: Boolean read GetCheck_false write SetCheck_false;
    property Vertwo2000: IVersioningTestV2 read GetVertwo2000 write SetVertwo2000;
    property A_set2500: IHashSet read GetA_set2500 write SetA_set2500;
    property Vertwo3000: IVersioningTestV2 read GetVertwo3000 write SetVertwo3000;
    property Big_numbers: IThriftList read GetBig_numbers write SetBig_numbers;

    // isset
    property __isset_B1: Boolean read Get__isset_B1;
    property __isset_B10: Boolean read Get__isset_B10;
    property __isset_B100: Boolean read Get__isset_B100;
    property __isset_Check_true: Boolean read Get__isset_Check_true;
    property __isset_B1000: Boolean read Get__isset_B1000;
    property __isset_Check_false: Boolean read Get__isset_Check_false;
    property __isset_Vertwo2000: Boolean read Get__isset_Vertwo2000;
    property __isset_A_set2500: Boolean read Get__isset_A_set2500;
    property __isset_Vertwo3000: Boolean read Get__isset_Vertwo3000;
    property __isset_Big_numbers: Boolean read Get__isset_Big_numbers;
  end;

  INestedListsI32x2 = interface(IBase)
    function GetIntegerlist: IThriftList;
    procedure SetIntegerlist( const Value: IThriftList);

    property Integerlist: IThriftList read GetIntegerlist write SetIntegerlist;

    function Get__isset_Integerlist: Boolean;

    property __isset_Integerlist: Boolean read Get__isset_Integerlist;
  end;

  TNestedListsI32x2Impl = class(TInterfacedObject, IBase, INestedListsI32x2)
  private
    FIntegerlist: IThriftList;
    
    F__isset_Integerlist: Boolean;
    
    function GetIntegerlist: IThriftList;
    procedure SetIntegerlist( const Value: IThriftList);

    function Get__isset_Integerlist: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property Integerlist: IThriftList read GetIntegerlist write SetIntegerlist;

    // isset
    property __isset_Integerlist: Boolean read Get__isset_Integerlist;
  end;

  INestedListsI32x3 = interface(IBase)
    function GetIntegerlist: IThriftList;
    procedure SetIntegerlist( const Value: IThriftList);

    property Integerlist: IThriftList read GetIntegerlist write SetIntegerlist;

    function Get__isset_Integerlist: Boolean;

    property __isset_Integerlist: Boolean read Get__isset_Integerlist;
  end;

  TNestedListsI32x3Impl = class(TInterfacedObject, IBase, INestedListsI32x3)
  private
    FIntegerlist: IThriftList;
    
    F__isset_Integerlist: Boolean;
    
    function GetIntegerlist: IThriftList;
    procedure SetIntegerlist( const Value: IThriftList);

    function Get__isset_Integerlist: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property Integerlist: IThriftList read GetIntegerlist write SetIntegerlist;

    // isset
    property __isset_Integerlist: Boolean read Get__isset_Integerlist;
  end;

  INestedMixedx2 = interface(IBase)
    function GetInt_set_list: IThriftList;
    procedure SetInt_set_list( const Value: IThriftList);
    function GetMap_int_strset: IThriftDictionary;
    procedure SetMap_int_strset( const Value: IThriftDictionary);
    function GetMap_int_strset_list: IThriftList;
    procedure SetMap_int_strset_list( const Value: IThriftList);

    property Int_set_list: IThriftList read GetInt_set_list write SetInt_set_list;
    property Map_int_strset: IThriftDictionary read GetMap_int_strset write SetMap_int_strset;
    property Map_int_strset_list: IThriftList read GetMap_int_strset_list write SetMap_int_strset_list;

    function Get__isset_Int_set_list: Boolean;
    function Get__isset_Map_int_strset: Boolean;
    function Get__isset_Map_int_strset_list: Boolean;

    property __isset_Int_set_list: Boolean read Get__isset_Int_set_list;
    property __isset_Map_int_strset: Boolean read Get__isset_Map_int_strset;
    property __isset_Map_int_strset_list: Boolean read Get__isset_Map_int_strset_list;
  end;

  TNestedMixedx2Impl = class(TInterfacedObject, IBase, INestedMixedx2)
  private
    FInt_set_list: IThriftList;
    FMap_int_strset: IThriftDictionary;
    FMap_int_strset_list: IThriftList;
    
    F__isset_Int_set_list: Boolean;
    F__isset_Map_int_strset: Boolean;
    F__isset_Map_int_strset_list: Boolean;
    
    function GetInt_set_list: IThriftList;
    procedure SetInt_set_list( const Value: IThriftList);
    function GetMap_int_strset: IThriftDictionary;
    procedure SetMap_int_strset( const Value: IThriftDictionary);
    function GetMap_int_strset_list: IThriftList;
    procedure SetMap_int_strset_list( const Value: IThriftList);

    function Get__isset_Int_set_list: Boolean;
    function Get__isset_Map_int_strset: Boolean;
    function Get__isset_Map_int_strset_list: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property Int_set_list: IThriftList read GetInt_set_list write SetInt_set_list;
    property Map_int_strset: IThriftDictionary read GetMap_int_strset write SetMap_int_strset;
    property Map_int_strset_list: IThriftList read GetMap_int_strset_list write SetMap_int_strset_list;

    // isset
    property __isset_Int_set_list: Boolean read Get__isset_Int_set_list;
    property __isset_Map_int_strset: Boolean read Get__isset_Map_int_strset;
    property __isset_Map_int_strset_list: Boolean read Get__isset_Map_int_strset_list;
  end;

  IListBonks = interface(IBase)
    function GetBonk: IThriftList;
    procedure SetBonk( const Value: IThriftList);

    property Bonk: IThriftList read GetBonk write SetBonk;

    function Get__isset_Bonk: Boolean;

    property __isset_Bonk: Boolean read Get__isset_Bonk;
  end;

  TListBonksImpl = class(TInterfacedObject, IBase, IListBonks)
  private
    FBonk: IThriftList;
    
    F__isset_Bonk: Boolean;
    
    function GetBonk: IThriftList;
    procedure SetBonk( const Value: IThriftList);

    function Get__isset_Bonk: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property Bonk: IThriftList read GetBonk write SetBonk;

    // isset
    property __isset_Bonk: Boolean read Get__isset_Bonk;
  end;

  INestedListsBonk = interface(IBase)
    function GetBonk: IThriftList;
    procedure SetBonk( const Value: IThriftList);

    property Bonk: IThriftList read GetBonk write SetBonk;

    function Get__isset_Bonk: Boolean;

    property __isset_Bonk: Boolean read Get__isset_Bonk;
  end;

  TNestedListsBonkImpl = class(TInterfacedObject, IBase, INestedListsBonk)
  private
    FBonk: IThriftList;
    
    F__isset_Bonk: Boolean;
    
    function GetBonk: IThriftList;
    procedure SetBonk( const Value: IThriftList);

    function Get__isset_Bonk: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property Bonk: IThriftList read GetBonk write SetBonk;

    // isset
    property __isset_Bonk: Boolean read Get__isset_Bonk;
  end;

  IBoolTest = interface(IBase)
    function GetB: Boolean;
    procedure SetB( const Value: Boolean);
    function GetS: string;
    procedure SetS( const Value: string);

    property B: Boolean read GetB write SetB;
    property S: string read GetS write SetS;

    function Get__isset_B: Boolean;
    function Get__isset_S: Boolean;

    property __isset_B: Boolean read Get__isset_B;
    property __isset_S: Boolean read Get__isset_S;
  end;

  TBoolTestImpl = class(TInterfacedObject, IBase, IBoolTest)
  private
    FB: Boolean;
    FS: string;
    
    F__isset_B: Boolean;
    F__isset_S: Boolean;
    
    function GetB: Boolean;
    procedure SetB( const Value: Boolean);
    function GetS: string;
    procedure SetS( const Value: string);

    function Get__isset_B: Boolean;
    function Get__isset_S: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property B: Boolean read GetB write SetB;
    property S: string read GetS write SetS;

    // isset
    property __isset_B: Boolean read Get__isset_B;
    property __isset_S: Boolean read Get__isset_S;
  end;

  IStructA = interface(IBase)
    function GetS: string;
    procedure SetS( const Value: string);

    property S: string read GetS write SetS;


  end;

  TStructAImpl = class(TInterfacedObject, IBase, IStructA)
  private
    FS: string;
    
    
    function GetS: string;
    procedure SetS( const Value: string);

  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property S: string read GetS write SetS;

    // isset
  end;

  IStructB = interface(IBase)
    function GetAa: IStructA;
    procedure SetAa( const Value: IStructA);
    function GetAb: IStructA;
    procedure SetAb( const Value: IStructA);

    property Aa: IStructA read GetAa write SetAa;
    property Ab: IStructA read GetAb write SetAb;

    function Get__isset_Aa: Boolean;

    property __isset_Aa: Boolean read Get__isset_Aa;
  end;

  TStructBImpl = class(TInterfacedObject, IBase, IStructB)
  private
    FAa: IStructA;
    FAb: IStructA;
    
    F__isset_Aa: Boolean;
    
    function GetAa: IStructA;
    procedure SetAa( const Value: IStructA);
    function GetAb: IStructA;
    procedure SetAb( const Value: IStructA);

    function Get__isset_Aa: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property Aa: IStructA read GetAa write SetAa;
    property Ab: IStructA read GetAb write SetAb;

    // isset
    property __isset_Aa: Boolean read Get__isset_Aa;
  end;

  TThriftTest = class
  public
    type
      Iface = interface
        procedure testVoid();
        function testString(const thing: string): string;
        function testByte(thing: ShortInt): ShortInt;
        function testI32(thing: Integer): Integer;
        function testI64(const thing: Int64): Int64;
        function testDouble(const thing: Double): Double;
        function testStruct(const thing: IXtruct): IXtruct;
        function testNest(const thing: IXtruct2): IXtruct2;
        function testMap(const thing: IThriftDictionary): IThriftDictionary;
        function testStringMap(const thing: IThriftDictionary): IThriftDictionary;
        function testSet(const thing: IHashSet): IHashSet;
        function testList(const thing: IThriftList): IThriftList;
        function testEnum(thing: TNumberz): TNumberz;
        function testTypedef(const thing: TUserId): TUserId;
        function testMapMap(hello: Integer): IThriftDictionary;
        function testInsanity(const argument: IInsanity): IThriftDictionary;
        function testMulti(arg0: ShortInt; arg1: Integer; const arg2: Int64; const arg3: IThriftDictionary; arg4: TNumberz; const arg5: TUserId): IXtruct;
        procedure testException(const arg: string);
        function testMultiException(const arg0: string; const arg1: string): IXtruct;
        procedure testOneway(secondsToSleep: Integer);
      end;

      TClient = class( TInterfacedObject, Iface)
      public
        constructor Create( prot: IProtocol); overload;
        constructor Create( const iprot: IProtocol; const oprot: IProtocol); overload;
      protected
        iprot_: IProtocol;
        oprot_: IProtocol;
        seqid_: Integer;
      public
        property InputProtocol: IProtocol read iprot_;
        property OutputProtocol: IProtocol read oprot_;
      protected
        // Iface
        procedure testVoid();
        function testString(const thing: string): string;
        function testByte(thing: ShortInt): ShortInt;
        function testI32(thing: Integer): Integer;
        function testI64(const thing: Int64): Int64;
        function testDouble(const thing: Double): Double;
        function testStruct(const thing: IXtruct): IXtruct;
        function testNest(const thing: IXtruct2): IXtruct2;
        function testMap(const thing: IThriftDictionary): IThriftDictionary;
        function testStringMap(const thing: IThriftDictionary): IThriftDictionary;
        function testSet(const thing: IHashSet): IHashSet;
        function testList(const thing: IThriftList): IThriftList;
        function testEnum(thing: TNumberz): TNumberz;
        function testTypedef(const thing: TUserId): TUserId;
        function testMapMap(hello: Integer): IThriftDictionary;
        function testInsanity(const argument: IInsanity): IThriftDictionary;
        function testMulti(arg0: ShortInt; arg1: Integer; const arg2: Int64; const arg3: IThriftDictionary; arg4: TNumberz; const arg5: TUserId): IXtruct;
        procedure testException(const arg: string);
        function testMultiException(const arg0: string; const arg1: string): IXtruct;
        procedure testOneway(secondsToSleep: Integer);
      public
        procedure send_testVoid();
        procedure recv_testVoid();
        procedure send_testString(const thing: string);
        function recv_testString(): string;
        procedure send_testByte(thing: ShortInt);
        function recv_testByte(): ShortInt;
        procedure send_testI32(thing: Integer);
        function recv_testI32(): Integer;
        procedure send_testI64(const thing: Int64);
        function recv_testI64(): Int64;
        procedure send_testDouble(const thing: Double);
        function recv_testDouble(): Double;
        procedure send_testStruct(const thing: IXtruct);
        function recv_testStruct(): IXtruct;
        procedure send_testNest(const thing: IXtruct2);
        function recv_testNest(): IXtruct2;
        procedure send_testMap(const thing: IThriftDictionary);
        function recv_testMap(): IThriftDictionary;
        procedure send_testStringMap(const thing: IThriftDictionary);
        function recv_testStringMap(): IThriftDictionary;
        procedure send_testSet(const thing: IHashSet);
        function recv_testSet(): IHashSet;
        procedure send_testList(const thing: IThriftList);
        function recv_testList(): IThriftList;
        procedure send_testEnum(thing: TNumberz);
        function recv_testEnum(): TNumberz;
        procedure send_testTypedef(const thing: TUserId);
        function recv_testTypedef(): TUserId;
        procedure send_testMapMap(hello: Integer);
        function recv_testMapMap(): IThriftDictionary;
        procedure send_testInsanity(const argument: IInsanity);
        function recv_testInsanity(): IThriftDictionary;
        procedure send_testMulti(arg0: ShortInt; arg1: Integer; const arg2: Int64; const arg3: IThriftDictionary; arg4: TNumberz; const arg5: TUserId);
        function recv_testMulti(): IXtruct;
        procedure send_testException(const arg: string);
        procedure recv_testException();
        procedure send_testMultiException(const arg0: string; const arg1: string);
        function recv_testMultiException(): IXtruct;
        procedure send_testOneway(secondsToSleep: Integer);
      end;

      TProcessorImpl = class( TInterfacedObject, IProcessor)
      public
        constructor Create( iface_: Iface );
        destructor Destroy; override;
      private
        iface_: Iface;
      protected
        type
          TProcessFunction = {reference to }procedure( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface) of object;
      protected
        processMap_: IThriftDictionary;{IThriftDictionary<string, TProcessFunction>;}
      public
        function Process( const iprot: IProtocol; const oprot: IProtocol): Boolean;
        procedure testVoid_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure testString_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure testByte_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure testI32_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure testI64_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure testDouble_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure testStruct_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure testNest_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure testMap_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure testStringMap_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure testSet_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure testList_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure testEnum_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure testTypedef_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure testMapMap_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure testInsanity_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure testMulti_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure testException_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure testMultiException_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure testOneway_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
      end;

      ITestVoid_args = interface(IBase)
      end;

      TTestVoid_argsImpl = class(TInterfacedObject, IBase, ITestVoid_args)
      private
        
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);
      end;

      ITestVoid_result = interface(IBase)
      end;

      TTestVoid_resultImpl = class(TInterfacedObject, IBase, ITestVoid_result)
      private
        
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);
      end;

      ITestString_args = interface(IBase)
        function GetThing: string;
        procedure SetThing( const Value: string);

        property Thing: string read GetThing write SetThing;

        function Get__isset_Thing: Boolean;

        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      TTestString_argsImpl = class(TInterfacedObject, IBase, ITestString_args)
      private
        FThing: string;
        
        F__isset_Thing: Boolean;
        
        function GetThing: string;
        procedure SetThing( const Value: string);

        function Get__isset_Thing: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Thing: string read GetThing write SetThing;

        // isset
        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      ITestString_result = interface(IBase)
        function GetSuccess: string;
        procedure SetSuccess( const Value: string);

        property Success: string read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TTestString_resultImpl = class(TInterfacedObject, IBase, ITestString_result)
      private
        FSuccess: string;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: string;
        procedure SetSuccess( const Value: string);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: string read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      ITestByte_args = interface(IBase)
        function GetThing: ShortInt;
        procedure SetThing( const Value: ShortInt);

        property Thing: ShortInt read GetThing write SetThing;

        function Get__isset_Thing: Boolean;

        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      TTestByte_argsImpl = class(TInterfacedObject, IBase, ITestByte_args)
      private
        FThing: ShortInt;
        
        F__isset_Thing: Boolean;
        
        function GetThing: ShortInt;
        procedure SetThing( const Value: ShortInt);

        function Get__isset_Thing: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Thing: ShortInt read GetThing write SetThing;

        // isset
        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      ITestByte_result = interface(IBase)
        function GetSuccess: ShortInt;
        procedure SetSuccess( const Value: ShortInt);

        property Success: ShortInt read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TTestByte_resultImpl = class(TInterfacedObject, IBase, ITestByte_result)
      private
        FSuccess: ShortInt;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: ShortInt;
        procedure SetSuccess( const Value: ShortInt);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: ShortInt read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      ITestI32_args = interface(IBase)
        function GetThing: Integer;
        procedure SetThing( const Value: Integer);

        property Thing: Integer read GetThing write SetThing;

        function Get__isset_Thing: Boolean;

        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      TTestI32_argsImpl = class(TInterfacedObject, IBase, ITestI32_args)
      private
        FThing: Integer;
        
        F__isset_Thing: Boolean;
        
        function GetThing: Integer;
        procedure SetThing( const Value: Integer);

        function Get__isset_Thing: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Thing: Integer read GetThing write SetThing;

        // isset
        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      ITestI32_result = interface(IBase)
        function GetSuccess: Integer;
        procedure SetSuccess( const Value: Integer);

        property Success: Integer read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TTestI32_resultImpl = class(TInterfacedObject, IBase, ITestI32_result)
      private
        FSuccess: Integer;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: Integer;
        procedure SetSuccess( const Value: Integer);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: Integer read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      ITestI64_args = interface(IBase)
        function GetThing: Int64;
        procedure SetThing( const Value: Int64);

        property Thing: Int64 read GetThing write SetThing;

        function Get__isset_Thing: Boolean;

        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      TTestI64_argsImpl = class(TInterfacedObject, IBase, ITestI64_args)
      private
        FThing: Int64;
        
        F__isset_Thing: Boolean;
        
        function GetThing: Int64;
        procedure SetThing( const Value: Int64);

        function Get__isset_Thing: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Thing: Int64 read GetThing write SetThing;

        // isset
        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      ITestI64_result = interface(IBase)
        function GetSuccess: Int64;
        procedure SetSuccess( const Value: Int64);

        property Success: Int64 read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TTestI64_resultImpl = class(TInterfacedObject, IBase, ITestI64_result)
      private
        FSuccess: Int64;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: Int64;
        procedure SetSuccess( const Value: Int64);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: Int64 read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      ITestDouble_args = interface(IBase)
        function GetThing: Double;
        procedure SetThing( const Value: Double);

        property Thing: Double read GetThing write SetThing;

        function Get__isset_Thing: Boolean;

        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      TTestDouble_argsImpl = class(TInterfacedObject, IBase, ITestDouble_args)
      private
        FThing: Double;
        
        F__isset_Thing: Boolean;
        
        function GetThing: Double;
        procedure SetThing( const Value: Double);

        function Get__isset_Thing: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Thing: Double read GetThing write SetThing;

        // isset
        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      ITestDouble_result = interface(IBase)
        function GetSuccess: Double;
        procedure SetSuccess( const Value: Double);

        property Success: Double read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TTestDouble_resultImpl = class(TInterfacedObject, IBase, ITestDouble_result)
      private
        FSuccess: Double;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: Double;
        procedure SetSuccess( const Value: Double);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: Double read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      ITestStruct_args = interface(IBase)
        function GetThing: IXtruct;
        procedure SetThing( const Value: IXtruct);

        property Thing: IXtruct read GetThing write SetThing;

        function Get__isset_Thing: Boolean;

        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      TTestStruct_argsImpl = class(TInterfacedObject, IBase, ITestStruct_args)
      private
        FThing: IXtruct;
        
        F__isset_Thing: Boolean;
        
        function GetThing: IXtruct;
        procedure SetThing( const Value: IXtruct);

        function Get__isset_Thing: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Thing: IXtruct read GetThing write SetThing;

        // isset
        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      ITestStruct_result = interface(IBase)
        function GetSuccess: IXtruct;
        procedure SetSuccess( const Value: IXtruct);

        property Success: IXtruct read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TTestStruct_resultImpl = class(TInterfacedObject, IBase, ITestStruct_result)
      private
        FSuccess: IXtruct;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: IXtruct;
        procedure SetSuccess( const Value: IXtruct);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: IXtruct read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      ITestNest_args = interface(IBase)
        function GetThing: IXtruct2;
        procedure SetThing( const Value: IXtruct2);

        property Thing: IXtruct2 read GetThing write SetThing;

        function Get__isset_Thing: Boolean;

        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      TTestNest_argsImpl = class(TInterfacedObject, IBase, ITestNest_args)
      private
        FThing: IXtruct2;
        
        F__isset_Thing: Boolean;
        
        function GetThing: IXtruct2;
        procedure SetThing( const Value: IXtruct2);

        function Get__isset_Thing: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Thing: IXtruct2 read GetThing write SetThing;

        // isset
        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      ITestNest_result = interface(IBase)
        function GetSuccess: IXtruct2;
        procedure SetSuccess( const Value: IXtruct2);

        property Success: IXtruct2 read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TTestNest_resultImpl = class(TInterfacedObject, IBase, ITestNest_result)
      private
        FSuccess: IXtruct2;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: IXtruct2;
        procedure SetSuccess( const Value: IXtruct2);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: IXtruct2 read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      ITestMap_args = interface(IBase)
        function GetThing: IThriftDictionary;
        procedure SetThing( const Value: IThriftDictionary);

        property Thing: IThriftDictionary read GetThing write SetThing;

        function Get__isset_Thing: Boolean;

        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      TTestMap_argsImpl = class(TInterfacedObject, IBase, ITestMap_args)
      private
        FThing: IThriftDictionary;
        
        F__isset_Thing: Boolean;
        
        function GetThing: IThriftDictionary;
        procedure SetThing( const Value: IThriftDictionary);

        function Get__isset_Thing: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Thing: IThriftDictionary read GetThing write SetThing;

        // isset
        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      ITestMap_result = interface(IBase)
        function GetSuccess: IThriftDictionary;
        procedure SetSuccess( const Value: IThriftDictionary);

        property Success: IThriftDictionary read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TTestMap_resultImpl = class(TInterfacedObject, IBase, ITestMap_result)
      private
        FSuccess: IThriftDictionary;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: IThriftDictionary;
        procedure SetSuccess( const Value: IThriftDictionary);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: IThriftDictionary read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      ITestStringMap_args = interface(IBase)
        function GetThing: IThriftDictionary;
        procedure SetThing( const Value: IThriftDictionary);

        property Thing: IThriftDictionary read GetThing write SetThing;

        function Get__isset_Thing: Boolean;

        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      TTestStringMap_argsImpl = class(TInterfacedObject, IBase, ITestStringMap_args)
      private
        FThing: IThriftDictionary;
        
        F__isset_Thing: Boolean;
        
        function GetThing: IThriftDictionary;
        procedure SetThing( const Value: IThriftDictionary);

        function Get__isset_Thing: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Thing: IThriftDictionary read GetThing write SetThing;

        // isset
        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      ITestStringMap_result = interface(IBase)
        function GetSuccess: IThriftDictionary;
        procedure SetSuccess( const Value: IThriftDictionary);

        property Success: IThriftDictionary read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TTestStringMap_resultImpl = class(TInterfacedObject, IBase, ITestStringMap_result)
      private
        FSuccess: IThriftDictionary;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: IThriftDictionary;
        procedure SetSuccess( const Value: IThriftDictionary);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: IThriftDictionary read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      ITestSet_args = interface(IBase)
        function GetThing: IHashSet;
        procedure SetThing( const Value: IHashSet);

        property Thing: IHashSet read GetThing write SetThing;

        function Get__isset_Thing: Boolean;

        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      TTestSet_argsImpl = class(TInterfacedObject, IBase, ITestSet_args)
      private
        FThing: IHashSet;
        
        F__isset_Thing: Boolean;
        
        function GetThing: IHashSet;
        procedure SetThing( const Value: IHashSet);

        function Get__isset_Thing: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Thing: IHashSet read GetThing write SetThing;

        // isset
        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      ITestSet_result = interface(IBase)
        function GetSuccess: IHashSet;
        procedure SetSuccess( const Value: IHashSet);

        property Success: IHashSet read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TTestSet_resultImpl = class(TInterfacedObject, IBase, ITestSet_result)
      private
        FSuccess: IHashSet;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: IHashSet;
        procedure SetSuccess( const Value: IHashSet);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: IHashSet read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      ITestList_args = interface(IBase)
        function GetThing: IThriftList;
        procedure SetThing( const Value: IThriftList);

        property Thing: IThriftList read GetThing write SetThing;

        function Get__isset_Thing: Boolean;

        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      TTestList_argsImpl = class(TInterfacedObject, IBase, ITestList_args)
      private
        FThing: IThriftList;
        
        F__isset_Thing: Boolean;
        
        function GetThing: IThriftList;
        procedure SetThing( const Value: IThriftList);

        function Get__isset_Thing: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Thing: IThriftList read GetThing write SetThing;

        // isset
        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      ITestList_result = interface(IBase)
        function GetSuccess: IThriftList;
        procedure SetSuccess( const Value: IThriftList);

        property Success: IThriftList read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TTestList_resultImpl = class(TInterfacedObject, IBase, ITestList_result)
      private
        FSuccess: IThriftList;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: IThriftList;
        procedure SetSuccess( const Value: IThriftList);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: IThriftList read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      ITestEnum_args = interface(IBase)
        function GetThing: TNumberz;
        procedure SetThing( const Value: TNumberz);

        property Thing: TNumberz read GetThing write SetThing;

        function Get__isset_Thing: Boolean;

        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      TTestEnum_argsImpl = class(TInterfacedObject, IBase, ITestEnum_args)
      private
        FThing: TNumberz;
        
        F__isset_Thing: Boolean;
        
        function GetThing: TNumberz;
        procedure SetThing( const Value: TNumberz);

        function Get__isset_Thing: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Thing: TNumberz read GetThing write SetThing;

        // isset
        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      ITestEnum_result = interface(IBase)
        function GetSuccess: TNumberz;
        procedure SetSuccess( const Value: TNumberz);

        property Success: TNumberz read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TTestEnum_resultImpl = class(TInterfacedObject, IBase, ITestEnum_result)
      private
        FSuccess: TNumberz;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: TNumberz;
        procedure SetSuccess( const Value: TNumberz);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: TNumberz read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      ITestTypedef_args = interface(IBase)
        function GetThing: TUserId;
        procedure SetThing( const Value: TUserId);

        property Thing: TUserId read GetThing write SetThing;

        function Get__isset_Thing: Boolean;

        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      TTestTypedef_argsImpl = class(TInterfacedObject, IBase, ITestTypedef_args)
      private
        FThing: TUserId;
        
        F__isset_Thing: Boolean;
        
        function GetThing: TUserId;
        procedure SetThing( const Value: TUserId);

        function Get__isset_Thing: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Thing: TUserId read GetThing write SetThing;

        // isset
        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      ITestTypedef_result = interface(IBase)
        function GetSuccess: TUserId;
        procedure SetSuccess( const Value: TUserId);

        property Success: TUserId read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TTestTypedef_resultImpl = class(TInterfacedObject, IBase, ITestTypedef_result)
      private
        FSuccess: TUserId;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: TUserId;
        procedure SetSuccess( const Value: TUserId);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: TUserId read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      ITestMapMap_args = interface(IBase)
        function GetHello: Integer;
        procedure SetHello( const Value: Integer);

        property Hello: Integer read GetHello write SetHello;

        function Get__isset_Hello: Boolean;

        property __isset_Hello: Boolean read Get__isset_Hello;
      end;

      TTestMapMap_argsImpl = class(TInterfacedObject, IBase, ITestMapMap_args)
      private
        FHello: Integer;
        
        F__isset_Hello: Boolean;
        
        function GetHello: Integer;
        procedure SetHello( const Value: Integer);

        function Get__isset_Hello: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Hello: Integer read GetHello write SetHello;

        // isset
        property __isset_Hello: Boolean read Get__isset_Hello;
      end;

      ITestMapMap_result = interface(IBase)
        function GetSuccess: IThriftDictionary;
        procedure SetSuccess( const Value: IThriftDictionary);

        property Success: IThriftDictionary read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TTestMapMap_resultImpl = class(TInterfacedObject, IBase, ITestMapMap_result)
      private
        FSuccess: IThriftDictionary;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: IThriftDictionary;
        procedure SetSuccess( const Value: IThriftDictionary);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: IThriftDictionary read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      ITestInsanity_args = interface(IBase)
        function GetArgument: IInsanity;
        procedure SetArgument( const Value: IInsanity);

        property Argument: IInsanity read GetArgument write SetArgument;

        function Get__isset_Argument: Boolean;

        property __isset_Argument: Boolean read Get__isset_Argument;
      end;

      TTestInsanity_argsImpl = class(TInterfacedObject, IBase, ITestInsanity_args)
      private
        FArgument: IInsanity;
        
        F__isset_Argument: Boolean;
        
        function GetArgument: IInsanity;
        procedure SetArgument( const Value: IInsanity);

        function Get__isset_Argument: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Argument: IInsanity read GetArgument write SetArgument;

        // isset
        property __isset_Argument: Boolean read Get__isset_Argument;
      end;

      ITestInsanity_result = interface(IBase)
        function GetSuccess: IThriftDictionary;
        procedure SetSuccess( const Value: IThriftDictionary);

        property Success: IThriftDictionary read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TTestInsanity_resultImpl = class(TInterfacedObject, IBase, ITestInsanity_result)
      private
        FSuccess: IThriftDictionary;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: IThriftDictionary;
        procedure SetSuccess( const Value: IThriftDictionary);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: IThriftDictionary read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      ITestMulti_args = interface(IBase)
        function GetArg0: ShortInt;
        procedure SetArg0( const Value: ShortInt);
        function GetArg1: Integer;
        procedure SetArg1( const Value: Integer);
        function GetArg2: Int64;
        procedure SetArg2( const Value: Int64);
        function GetArg3: IThriftDictionary;
        procedure SetArg3( const Value: IThriftDictionary);
        function GetArg4: TNumberz;
        procedure SetArg4( const Value: TNumberz);
        function GetArg5: TUserId;
        procedure SetArg5( const Value: TUserId);

        property Arg0: ShortInt read GetArg0 write SetArg0;
        property Arg1: Integer read GetArg1 write SetArg1;
        property Arg2: Int64 read GetArg2 write SetArg2;
        property Arg3: IThriftDictionary read GetArg3 write SetArg3;
        property Arg4: TNumberz read GetArg4 write SetArg4;
        property Arg5: TUserId read GetArg5 write SetArg5;

        function Get__isset_Arg0: Boolean;
        function Get__isset_Arg1: Boolean;
        function Get__isset_Arg2: Boolean;
        function Get__isset_Arg3: Boolean;
        function Get__isset_Arg4: Boolean;
        function Get__isset_Arg5: Boolean;

        property __isset_Arg0: Boolean read Get__isset_Arg0;
        property __isset_Arg1: Boolean read Get__isset_Arg1;
        property __isset_Arg2: Boolean read Get__isset_Arg2;
        property __isset_Arg3: Boolean read Get__isset_Arg3;
        property __isset_Arg4: Boolean read Get__isset_Arg4;
        property __isset_Arg5: Boolean read Get__isset_Arg5;
      end;

      TTestMulti_argsImpl = class(TInterfacedObject, IBase, ITestMulti_args)
      private
        FArg0: ShortInt;
        FArg1: Integer;
        FArg2: Int64;
        FArg3: IThriftDictionary;
        FArg4: TNumberz;
        FArg5: TUserId;
        
        F__isset_Arg0: Boolean;
        F__isset_Arg1: Boolean;
        F__isset_Arg2: Boolean;
        F__isset_Arg3: Boolean;
        F__isset_Arg4: Boolean;
        F__isset_Arg5: Boolean;
        
        function GetArg0: ShortInt;
        procedure SetArg0( const Value: ShortInt);
        function GetArg1: Integer;
        procedure SetArg1( const Value: Integer);
        function GetArg2: Int64;
        procedure SetArg2( const Value: Int64);
        function GetArg3: IThriftDictionary;
        procedure SetArg3( const Value: IThriftDictionary);
        function GetArg4: TNumberz;
        procedure SetArg4( const Value: TNumberz);
        function GetArg5: TUserId;
        procedure SetArg5( const Value: TUserId);

        function Get__isset_Arg0: Boolean;
        function Get__isset_Arg1: Boolean;
        function Get__isset_Arg2: Boolean;
        function Get__isset_Arg3: Boolean;
        function Get__isset_Arg4: Boolean;
        function Get__isset_Arg5: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Arg0: ShortInt read GetArg0 write SetArg0;
        property Arg1: Integer read GetArg1 write SetArg1;
        property Arg2: Int64 read GetArg2 write SetArg2;
        property Arg3: IThriftDictionary read GetArg3 write SetArg3;
        property Arg4: TNumberz read GetArg4 write SetArg4;
        property Arg5: TUserId read GetArg5 write SetArg5;

        // isset
        property __isset_Arg0: Boolean read Get__isset_Arg0;
        property __isset_Arg1: Boolean read Get__isset_Arg1;
        property __isset_Arg2: Boolean read Get__isset_Arg2;
        property __isset_Arg3: Boolean read Get__isset_Arg3;
        property __isset_Arg4: Boolean read Get__isset_Arg4;
        property __isset_Arg5: Boolean read Get__isset_Arg5;
      end;

      ITestMulti_result = interface(IBase)
        function GetSuccess: IXtruct;
        procedure SetSuccess( const Value: IXtruct);

        property Success: IXtruct read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TTestMulti_resultImpl = class(TInterfacedObject, IBase, ITestMulti_result)
      private
        FSuccess: IXtruct;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: IXtruct;
        procedure SetSuccess( const Value: IXtruct);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: IXtruct read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      ITestException_args = interface(IBase)
        function GetArg: string;
        procedure SetArg( const Value: string);

        property Arg: string read GetArg write SetArg;

        function Get__isset_Arg: Boolean;

        property __isset_Arg: Boolean read Get__isset_Arg;
      end;

      TTestException_argsImpl = class(TInterfacedObject, IBase, ITestException_args)
      private
        FArg: string;
        
        F__isset_Arg: Boolean;
        
        function GetArg: string;
        procedure SetArg( const Value: string);

        function Get__isset_Arg: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Arg: string read GetArg write SetArg;

        // isset
        property __isset_Arg: Boolean read Get__isset_Arg;
      end;

      ITestException_result = interface(IBase)
        function GetErr1: TXception.IXceptionFactory;
        procedure SetErr1( const Value: TXception.IXceptionFactory);

        property Err1: TXception.IXceptionFactory read GetErr1 write SetErr1;

        function Get__isset_Err1: Boolean;

        property __isset_Err1: Boolean read Get__isset_Err1;
      end;

      TTestException_resultImpl = class(TInterfacedObject, IBase, ITestException_result)
      private
        FErr1: TXception.IXceptionFactory;
        
        F__isset_Err1: Boolean;
        
        function GetErr1: TXception.IXceptionFactory;
        procedure SetErr1( const Value: TXception.IXceptionFactory);

        function Get__isset_Err1: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Err1: TXception.IXceptionFactory read GetErr1 write SetErr1;

        // isset
        property __isset_Err1: Boolean read Get__isset_Err1;
      end;

      ITestMultiException_args = interface(IBase)
        function GetArg0: string;
        procedure SetArg0( const Value: string);
        function GetArg1: string;
        procedure SetArg1( const Value: string);

        property Arg0: string read GetArg0 write SetArg0;
        property Arg1: string read GetArg1 write SetArg1;

        function Get__isset_Arg0: Boolean;
        function Get__isset_Arg1: Boolean;

        property __isset_Arg0: Boolean read Get__isset_Arg0;
        property __isset_Arg1: Boolean read Get__isset_Arg1;
      end;

      TTestMultiException_argsImpl = class(TInterfacedObject, IBase, ITestMultiException_args)
      private
        FArg0: string;
        FArg1: string;
        
        F__isset_Arg0: Boolean;
        F__isset_Arg1: Boolean;
        
        function GetArg0: string;
        procedure SetArg0( const Value: string);
        function GetArg1: string;
        procedure SetArg1( const Value: string);

        function Get__isset_Arg0: Boolean;
        function Get__isset_Arg1: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Arg0: string read GetArg0 write SetArg0;
        property Arg1: string read GetArg1 write SetArg1;

        // isset
        property __isset_Arg0: Boolean read Get__isset_Arg0;
        property __isset_Arg1: Boolean read Get__isset_Arg1;
      end;

      ITestMultiException_result = interface(IBase)
        function GetSuccess: IXtruct;
        procedure SetSuccess( const Value: IXtruct);
        function GetErr1: TXception.IXceptionFactory;
        procedure SetErr1( const Value: TXception.IXceptionFactory);
        function GetErr2: TXception2.IXception2Factory;
        procedure SetErr2( const Value: TXception2.IXception2Factory);

        property Success: IXtruct read GetSuccess write SetSuccess;
        property Err1: TXception.IXceptionFactory read GetErr1 write SetErr1;
        property Err2: TXception2.IXception2Factory read GetErr2 write SetErr2;

        function Get__isset_Success: Boolean;
        function Get__isset_Err1: Boolean;
        function Get__isset_Err2: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
        property __isset_Err1: Boolean read Get__isset_Err1;
        property __isset_Err2: Boolean read Get__isset_Err2;
      end;

      TTestMultiException_resultImpl = class(TInterfacedObject, IBase, ITestMultiException_result)
      private
        FSuccess: IXtruct;
        FErr1: TXception.IXceptionFactory;
        FErr2: TXception2.IXception2Factory;
        
        F__isset_Success: Boolean;
        F__isset_Err1: Boolean;
        F__isset_Err2: Boolean;
        
        function GetSuccess: IXtruct;
        procedure SetSuccess( const Value: IXtruct);
        function GetErr1: TXception.IXceptionFactory;
        procedure SetErr1( const Value: TXception.IXceptionFactory);
        function GetErr2: TXception2.IXception2Factory;
        procedure SetErr2( const Value: TXception2.IXception2Factory);

        function Get__isset_Success: Boolean;
        function Get__isset_Err1: Boolean;
        function Get__isset_Err2: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: IXtruct read GetSuccess write SetSuccess;
        property Err1: TXception.IXceptionFactory read GetErr1 write SetErr1;
        property Err2: TXception2.IXception2Factory read GetErr2 write SetErr2;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
        property __isset_Err1: Boolean read Get__isset_Err1;
        property __isset_Err2: Boolean read Get__isset_Err2;
      end;

      ITestOneway_args = interface(IBase)
        function GetSecondsToSleep: Integer;
        procedure SetSecondsToSleep( const Value: Integer);

        property SecondsToSleep: Integer read GetSecondsToSleep write SetSecondsToSleep;

        function Get__isset_SecondsToSleep: Boolean;

        property __isset_SecondsToSleep: Boolean read Get__isset_SecondsToSleep;
      end;

      TTestOneway_argsImpl = class(TInterfacedObject, IBase, ITestOneway_args)
      private
        FSecondsToSleep: Integer;
        
        F__isset_SecondsToSleep: Boolean;
        
        function GetSecondsToSleep: Integer;
        procedure SetSecondsToSleep( const Value: Integer);

        function Get__isset_SecondsToSleep: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property SecondsToSleep: Integer read GetSecondsToSleep write SetSecondsToSleep;

        // isset
        property __isset_SecondsToSleep: Boolean read Get__isset_SecondsToSleep;
      end;

  end;
  
  TSecondService = class
  public
    type
      Iface = interface
        procedure blahBlah();
      end;

      TClient = class( TInterfacedObject, Iface)
      public
        constructor Create( prot: IProtocol); overload;
        constructor Create( const iprot: IProtocol; const oprot: IProtocol); overload;
      protected
        iprot_: IProtocol;
        oprot_: IProtocol;
        seqid_: Integer;
      public
        property InputProtocol: IProtocol read iprot_;
        property OutputProtocol: IProtocol read oprot_;
      protected
        // Iface
        procedure blahBlah();
      public
        procedure send_blahBlah();
        procedure recv_blahBlah();
      end;

      TProcessorImpl = class( TInterfacedObject, IProcessor)
      public
        constructor Create( iface_: Iface );
        destructor Destroy; override;
      private
        iface_: Iface;
      protected
        type
          TProcessFunction = {reference to }procedure( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface) of object;
      protected
        processMap_: IThriftDictionary;{IThriftDictionary<string, TProcessFunction>;}
      public
        function Process( const iprot: IProtocol; const oprot: IProtocol): Boolean;
        procedure blahBlah_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
      end;

      IBlahBlah_args = interface(IBase)
      end;

      TBlahBlah_argsImpl = class(TInterfacedObject, IBase, IBlahBlah_args)
      private
        
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);
      end;

      IBlahBlah_result = interface(IBase)
      end;

      TBlahBlah_resultImpl = class(TInterfacedObject, IBase, IBlahBlah_result)
      private
        
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);
      end;

  end;
  
  TConstants = class
  private
    class var FmyNumberz: TNumberz;
  public
    class property myNumberz: TNumberz read FmyNumberz;
    //{$IF CompilerVersion >= 21.0}
    {$IFDEF CompilerVersion_g21}
    class constructor Create;
    class destructor Destroy;
    {$ENDIF}
  end;

implementation

constructor TBonkImpl.Create;
begin
  inherited;
end;

destructor TBonkImpl.Destroy;
begin
  inherited;
end;

function TBonkImpl.GetMessage: string;
begin
  Result := FMessage;
end;

procedure TBonkImpl.SetMessage( const Value: string);
begin
  F__isset_Message := True;
  FMessage := Value;
end;

function TBonkImpl.Get__isset_Message: Boolean;
begin
  Result := F__isset_Message;
end;

function TBonkImpl.GetType_: Integer;
begin
  Result := FType_;
end;

procedure TBonkImpl.SetType_( const Value: Integer);
begin
  F__isset_Type_ := True;
  FType_ := Value;
end;

function TBonkImpl.Get__isset_Type_: Boolean;
begin
  Result := F__isset_Type_;
end;

procedure TBonkImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}String_) then
          begin
            Message := iprot.ReadString();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            Type_ := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TBonkImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('Bonk');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Message) then
  begin
    field_.Name := 'message';
    field_.Type_  := {TType.}String_;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteString(Message);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Type_) then
  begin
    field_.Name := 'type';
    field_.Type_  := {TType.}I32;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Type_);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TBonkImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Message: ');
    sb.Append(Message);
    sb.Append(',Type_: ');
    sb.Append(Type_);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TBoolsImpl.Create;
begin
  inherited;
end;

destructor TBoolsImpl.Destroy;
begin
  inherited;
end;

function TBoolsImpl.GetIm_true: Boolean;
begin
  Result := FIm_true;
end;

procedure TBoolsImpl.SetIm_true( const Value: Boolean);
begin
  F__isset_Im_true := True;
  FIm_true := Value;
end;

function TBoolsImpl.Get__isset_Im_true: Boolean;
begin
  Result := F__isset_Im_true;
end;

function TBoolsImpl.GetIm_false: Boolean;
begin
  Result := FIm_false;
end;

procedure TBoolsImpl.SetIm_false( const Value: Boolean);
begin
  F__isset_Im_false := True;
  FIm_false := Value;
end;

function TBoolsImpl.Get__isset_Im_false: Boolean;
begin
  Result := F__isset_Im_false;
end;

procedure TBoolsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}Bool_) then
          begin
            Im_true := iprot.ReadBool();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = {TType.}Bool_) then
          begin
            Im_false := iprot.ReadBool();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TBoolsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('Bools');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Im_true) then
  begin
    field_.Name := 'im_true';
    field_.Type_  := {TType.}Bool_;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteBool(Im_true);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Im_false) then
  begin
    field_.Name := 'im_false';
    field_.Type_  := {TType.}Bool_;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    oprot.WriteBool(Im_false);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TBoolsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Im_true: ');
    sb.Append(Im_true);
    sb.Append(',Im_false: ');
    sb.Append(Im_false);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TXtructImpl.Create;
begin
  inherited;
end;

destructor TXtructImpl.Destroy;
begin
  inherited;
end;

function TXtructImpl.GetString_thing: string;
begin
  Result := FString_thing;
end;

procedure TXtructImpl.SetString_thing( const Value: string);
begin
  F__isset_String_thing := True;
  FString_thing := Value;
end;

function TXtructImpl.Get__isset_String_thing: Boolean;
begin
  Result := F__isset_String_thing;
end;

function TXtructImpl.GetByte_thing: ShortInt;
begin
  Result := FByte_thing;
end;

procedure TXtructImpl.SetByte_thing( const Value: ShortInt);
begin
  F__isset_Byte_thing := True;
  FByte_thing := Value;
end;

function TXtructImpl.Get__isset_Byte_thing: Boolean;
begin
  Result := F__isset_Byte_thing;
end;

function TXtructImpl.GetI32_thing: Integer;
begin
  Result := FI32_thing;
end;

procedure TXtructImpl.SetI32_thing( const Value: Integer);
begin
  F__isset_I32_thing := True;
  FI32_thing := Value;
end;

function TXtructImpl.Get__isset_I32_thing: Boolean;
begin
  Result := F__isset_I32_thing;
end;

function TXtructImpl.GetI64_thing: Int64;
begin
  Result := FI64_thing;
end;

procedure TXtructImpl.SetI64_thing( const Value: Int64);
begin
  F__isset_I64_thing := True;
  FI64_thing := Value;
end;

function TXtructImpl.Get__isset_I64_thing: Boolean;
begin
  Result := F__isset_I64_thing;
end;

procedure TXtructImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}String_) then
          begin
            String_thing := iprot.ReadString();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        4: begin
          if (field_.Type_ = {TType.}Byte_) then
          begin
            Byte_thing := iprot.ReadByte();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        9: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            I32_thing := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        11: begin
          if (field_.Type_ = {TType.}I64) then
          begin
            I64_thing := iprot.ReadI64();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TXtructImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('Xtruct');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_String_thing) then
  begin
    field_.Name := 'string_thing';
    field_.Type_  := {TType.}String_;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteString(String_thing);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Byte_thing) then
  begin
    field_.Name := 'byte_thing';
    field_.Type_  := {TType.}Byte_;
    field_.ID := 4;
    oprot.WriteFieldBegin(field_);
    oprot.WriteByte(Byte_thing);
    oprot.WriteFieldEnd();
  end;
  if (__isset_I32_thing) then
  begin
    field_.Name := 'i32_thing';
    field_.Type_  := {TType.}I32;
    field_.ID := 9;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(I32_thing);
    oprot.WriteFieldEnd();
  end;
  if (__isset_I64_thing) then
  begin
    field_.Name := 'i64_thing';
    field_.Type_  := {TType.}I64;
    field_.ID := 11;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI64(I64_thing);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TXtructImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('String_thing: ');
    sb.Append(String_thing);
    sb.Append(',Byte_thing: ');
    sb.Append(Byte_thing);
    sb.Append(',I32_thing: ');
    sb.Append(I32_thing);
    sb.Append(',I64_thing: ');
    sb.Append(I64_thing);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TXtruct2Impl.Create;
begin
  inherited;
end;

destructor TXtruct2Impl.Destroy;
begin
  inherited;
end;

function TXtruct2Impl.GetByte_thing: ShortInt;
begin
  Result := FByte_thing;
end;

procedure TXtruct2Impl.SetByte_thing( const Value: ShortInt);
begin
  F__isset_Byte_thing := True;
  FByte_thing := Value;
end;

function TXtruct2Impl.Get__isset_Byte_thing: Boolean;
begin
  Result := F__isset_Byte_thing;
end;

function TXtruct2Impl.GetStruct_thing: IXtruct;
begin
  Result := FStruct_thing;
end;

procedure TXtruct2Impl.SetStruct_thing( const Value: IXtruct);
begin
  F__isset_Struct_thing := True;
  FStruct_thing := Value;
end;

function TXtruct2Impl.Get__isset_Struct_thing: Boolean;
begin
  Result := F__isset_Struct_thing;
end;

function TXtruct2Impl.GetI32_thing: Integer;
begin
  Result := FI32_thing;
end;

procedure TXtruct2Impl.SetI32_thing( const Value: Integer);
begin
  F__isset_I32_thing := True;
  FI32_thing := Value;
end;

function TXtruct2Impl.Get__isset_I32_thing: Boolean;
begin
  Result := F__isset_I32_thing;
end;

procedure TXtruct2Impl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}Byte_) then
          begin
            Byte_thing := iprot.ReadByte();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            Struct_thing := TXtructImpl.Create;
            Struct_thing.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        3: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            I32_thing := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TXtruct2Impl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('Xtruct2');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Byte_thing) then
  begin
    field_.Name := 'byte_thing';
    field_.Type_  := {TType.}Byte_;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteByte(Byte_thing);
    oprot.WriteFieldEnd();
  end;
  if (Struct_thing <> nil) and __isset_Struct_thing then
  begin
    field_.Name := 'struct_thing';
    field_.Type_  := {TType.}Struct;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    Struct_thing.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  if (__isset_I32_thing) then
  begin
    field_.Name := 'i32_thing';
    field_.Type_  := {TType.}I32;
    field_.ID := 3;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(I32_thing);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TXtruct2Impl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Byte_thing: ');
    sb.Append(Byte_thing);
    sb.Append(',Struct_thing: ');
    if (Struct_thing = nil) then sb.Append('<null>') else sb.Append(Struct_thing.ToString());
    sb.Append(',I32_thing: ');
    sb.Append(I32_thing);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TXtruct3Impl.Create;
begin
  inherited;
end;

destructor TXtruct3Impl.Destroy;
begin
  inherited;
end;

function TXtruct3Impl.GetString_thing: string;
begin
  Result := FString_thing;
end;

procedure TXtruct3Impl.SetString_thing( const Value: string);
begin
  F__isset_String_thing := True;
  FString_thing := Value;
end;

function TXtruct3Impl.Get__isset_String_thing: Boolean;
begin
  Result := F__isset_String_thing;
end;

function TXtruct3Impl.GetChanged: Integer;
begin
  Result := FChanged;
end;

procedure TXtruct3Impl.SetChanged( const Value: Integer);
begin
  F__isset_Changed := True;
  FChanged := Value;
end;

function TXtruct3Impl.Get__isset_Changed: Boolean;
begin
  Result := F__isset_Changed;
end;

function TXtruct3Impl.GetI32_thing: Integer;
begin
  Result := FI32_thing;
end;

procedure TXtruct3Impl.SetI32_thing( const Value: Integer);
begin
  F__isset_I32_thing := True;
  FI32_thing := Value;
end;

function TXtruct3Impl.Get__isset_I32_thing: Boolean;
begin
  Result := F__isset_I32_thing;
end;

function TXtruct3Impl.GetI64_thing: Int64;
begin
  Result := FI64_thing;
end;

procedure TXtruct3Impl.SetI64_thing( const Value: Int64);
begin
  F__isset_I64_thing := True;
  FI64_thing := Value;
end;

function TXtruct3Impl.Get__isset_I64_thing: Boolean;
begin
  Result := F__isset_I64_thing;
end;

procedure TXtruct3Impl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}String_) then
          begin
            String_thing := iprot.ReadString();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        4: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            Changed := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        9: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            I32_thing := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        11: begin
          if (field_.Type_ = {TType.}I64) then
          begin
            I64_thing := iprot.ReadI64();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TXtruct3Impl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('Xtruct3');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_String_thing) then
  begin
    field_.Name := 'string_thing';
    field_.Type_  := {TType.}String_;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteString(String_thing);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Changed) then
  begin
    field_.Name := 'changed';
    field_.Type_  := {TType.}I32;
    field_.ID := 4;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Changed);
    oprot.WriteFieldEnd();
  end;
  if (__isset_I32_thing) then
  begin
    field_.Name := 'i32_thing';
    field_.Type_  := {TType.}I32;
    field_.ID := 9;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(I32_thing);
    oprot.WriteFieldEnd();
  end;
  if (__isset_I64_thing) then
  begin
    field_.Name := 'i64_thing';
    field_.Type_  := {TType.}I64;
    field_.ID := 11;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI64(I64_thing);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TXtruct3Impl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('String_thing: ');
    sb.Append(String_thing);
    sb.Append(',Changed: ');
    sb.Append(Changed);
    sb.Append(',I32_thing: ');
    sb.Append(I32_thing);
    sb.Append(',I64_thing: ');
    sb.Append(I64_thing);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TInsanityImpl.Create;
begin
  inherited;
end;

destructor TInsanityImpl.Destroy;
begin
  inherited;
end;

function TInsanityImpl.GetUserMap: IThriftDictionary;
begin
  Result := FUserMap;
end;

procedure TInsanityImpl.SetUserMap( const Value: IThriftDictionary);
begin
  F__isset_UserMap := True;
  FUserMap := Value;
end;

function TInsanityImpl.Get__isset_UserMap: Boolean;
begin
  Result := F__isset_UserMap;
end;

function TInsanityImpl.GetXtructs: IThriftList;
begin
  Result := FXtructs;
end;

procedure TInsanityImpl.SetXtructs( const Value: IThriftList);
begin
  F__isset_Xtructs := True;
  FXtructs := Value;
end;

function TInsanityImpl.Get__isset_Xtructs: Boolean;
begin
  Result := F__isset_Xtructs;
end;

procedure TInsanityImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _map0: IMap;
  _i1: Integer;
  _key2: TNumberz;
  _val3: TUserId;
  _list4: IList;
  _i5: Integer;
  _elem6: IXtruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}Map) then
          begin
            UserMap := TThriftDictionaryImpl.Create;
            _map0 := iprot.ReadMapBegin();
            for _i1 := 0 to _map0.Count - 1 do
            begin
              _key2 := TNumberz(iprot.ReadI32());
              _val3 := iprot.ReadI64();
              UserMap.AddOrSetValue( _key2, _val3);
            end;
            iprot.ReadMapEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = {TType.}List) then
          begin
            Xtructs := TThriftListImpl.Create;
            _list4 := iprot.ReadListBegin();
            for _i5 := 0 to _list4.Count - 1 do
            begin
              _elem6 := TXtructImpl.Create;
              _elem6.Read(iprot);
              Xtructs.Add(_elem6);
            end;
            iprot.ReadListEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TInsanityImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  map7 : IMap;
  ik9:integer;
  ikn10:integer;
  _iter8: TNumberz;
  list_11 : IList;
  ik13:integer;
  ikn14:integer;
  _iter12: IXtruct;
begin
  struc := TStructImpl.Create('Insanity');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (UserMap <> nil) and __isset_UserMap then
  begin
    field_.Name := 'userMap';
    field_.Type_  := {TType.}Map;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    map7 := TMapImpl.Create( {TType.}I32, {TType.}I64, UserMap.Count);
    oprot.WriteMapBegin( map7);
    ikn10:=UserMap.Count;
    for ik9:=0 to ikn10 do 
    begin
    _iter8:=UserMap.Keys[ik9];
      oprot.WriteI32(Integer(_iter8));
      oprot.WriteI64(UserMap[_iter8]);
    end;
    oprot.WriteMapEnd();
    oprot.WriteFieldEnd();
  end;
  if (Xtructs <> nil) and __isset_Xtructs then
  begin
    field_.Name := 'xtructs';
    field_.Type_  := {TType.}List;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    list_11 := TListImpl.Create({TType.}Struct, Xtructs.Count);
    oprot.WriteListBegin( list_11);
    ikn14:=Xtructs.Count;
    for ik13:=0 to ikn14 do 
    begin
    _iter12:=Xtructs.Items[ik13];
      _iter12.Write(oprot);
    end;
    oprot.WriteListEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TInsanityImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('UserMap: ');
    sb.Append(UserMap);
    sb.Append(',Xtructs: ');
    sb.Append(Xtructs);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TCrazyNestingImpl.Create;
begin
  inherited;
end;

destructor TCrazyNestingImpl.Destroy;
begin
  inherited;
end;

function TCrazyNestingImpl.GetString_field: string;
begin
  Result := FString_field;
end;

procedure TCrazyNestingImpl.SetString_field( const Value: string);
begin
  F__isset_String_field := True;
  FString_field := Value;
end;

function TCrazyNestingImpl.Get__isset_String_field: Boolean;
begin
  Result := F__isset_String_field;
end;

function TCrazyNestingImpl.GetSet_field: IHashSet;
begin
  Result := FSet_field;
end;

procedure TCrazyNestingImpl.SetSet_field( const Value: IHashSet);
begin
  F__isset_Set_field := True;
  FSet_field := Value;
end;

function TCrazyNestingImpl.Get__isset_Set_field: Boolean;
begin
  Result := F__isset_Set_field;
end;

function TCrazyNestingImpl.GetList_field: IThriftList;
begin
  Result := FList_field;
end;

procedure TCrazyNestingImpl.SetList_field( const Value: IThriftList);
begin
  FList_field := Value;
end;

function TCrazyNestingImpl.GetBinary_field: TBytes;
begin
  Result := FBinary_field;
end;

procedure TCrazyNestingImpl.SetBinary_field( const Value: TBytes);
begin
  F__isset_Binary_field := True;
  FBinary_field := Value;
end;

function TCrazyNestingImpl.Get__isset_Binary_field: Boolean;
begin
  Result := F__isset_Binary_field;
end;

procedure TCrazyNestingImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _req_isset_List_field : Boolean;
  _set15: ISet;
  _i16: Integer;
  _elem17: IInsanity;
  _list18: IList;
  _i19: Integer;
  _elem20: IThriftDictionary;
  _map21: IMap;
  _i22: Integer;
  _key23: IHashSet;
  _val24: IThriftDictionary;
  _set25: ISet;
  _i26: Integer;
  _elem27: Integer;
  _map28: IMap;
  _i29: Integer;
  _key30: Integer;
  _val31: IHashSet;
  _set32: ISet;
  _i33: Integer;
  _elem34: IThriftList;
  _list35: IList;
  _i36: Integer;
  _elem37: IThriftDictionary;
  _map38: IMap;
  _i39: Integer;
  _key40: IInsanity;
  _val41: string;

begin
  _req_isset_List_field := FALSE;
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}String_) then
          begin
            String_field := iprot.ReadString();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = {TType.}Set_) then
          begin
            Set_field := THashSetImpl.Create;
            _set15 := iprot.ReadSetBegin();
            for _i16 := 0 to _set15.Count - 1 do
            begin
              _elem17 := TInsanityImpl.Create;
              _elem17.Read(iprot);
              Set_field.Add(_elem17);
            end;
            iprot.ReadSetEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        3: begin
          if (field_.Type_ = {TType.}List) then
          begin
            List_field := TThriftListImpl.Create;
            _list18 := iprot.ReadListBegin();
            for _i19 := 0 to _list18.Count - 1 do
            begin
              _elem20 := TThriftDictionaryImpl.Create;
              _map21 := iprot.ReadMapBegin();
              for _i22 := 0 to _map21.Count - 1 do
              begin
                _key23 := THashSetImpl.Create;
                _set25 := iprot.ReadSetBegin();
                for _i26 := 0 to _set25.Count - 1 do
                begin
                  _elem27 := iprot.ReadI32();
                  _key23.Add(_elem27);
                end;
                iprot.ReadSetEnd();
                _val24 := TThriftDictionaryImpl.Create;
                _map28 := iprot.ReadMapBegin();
                for _i29 := 0 to _map28.Count - 1 do
                begin
                  _key30 := iprot.ReadI32();
                  _val31 := THashSetImpl.Create;
                  _set32 := iprot.ReadSetBegin();
                  for _i33 := 0 to _set32.Count - 1 do
                  begin
                    _elem34 := TThriftListImpl.Create;
                    _list35 := iprot.ReadListBegin();
                    for _i36 := 0 to _list35.Count - 1 do
                    begin
                      _elem37 := TThriftDictionaryImpl.Create;
                      _map38 := iprot.ReadMapBegin();
                      for _i39 := 0 to _map38.Count - 1 do
                      begin
                        _key40 := TInsanityImpl.Create;
                        _key40.Read(iprot);
                        _val41 := iprot.ReadString();
                        _elem37.AddOrSetValue( _key40, _val41);
                      end;
                      iprot.ReadMapEnd();
                      _elem34.Add(_elem37);
                    end;
                    iprot.ReadListEnd();
                    _val31.Add(_elem34);
                  end;
                  iprot.ReadSetEnd();
                  _val24.AddOrSetValue( _key30, _val31);
                end;
                iprot.ReadMapEnd();
                _elem20.AddOrSetValue( _key23, _val24);
              end;
              iprot.ReadMapEnd();
              List_field.Add(_elem20);
            end;
            iprot.ReadListEnd();
            _req_isset_List_field := TRUE;
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        4: begin
          if (field_.Type_ = {TType.}String_) then
          begin
            Binary_field := iprot.ReadBinary();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
  if not _req_isset_List_field
  then raise TProtocolException.Create( TProtocolException.INVALID_DATA, 'List_field');
end;

procedure TCrazyNestingImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  set_42 : ISet;
  ik44:integer;
  ikn45:integer;
  _iter43: IInsanity;
  list_46 : IList;
  ik48:integer;
  ikn49:integer;
  _iter47: IThriftDictionary;
  map50 : IMap;
  ik52:integer;
  ikn53:integer;
  _iter51: IHashSet;
  set_54 : ISet;
  ik56:integer;
  ikn57:integer;
  _iter55: Integer;
  map58 : IMap;
  ik60:integer;
  ikn61:integer;
  _iter59: Integer;
  set_62 : ISet;
  ik64:integer;
  ikn65:integer;
  _iter63: IThriftList;
  list_66 : IList;
  ik68:integer;
  ikn69:integer;
  _iter67: IThriftDictionary;
  map70 : IMap;
  ik72:integer;
  ikn73:integer;
  _iter71: IInsanity;
begin
  struc := TStructImpl.Create('CrazyNesting');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_String_field) then
  begin
    field_.Name := 'string_field';
    field_.Type_  := {TType.}String_;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteString(String_field);
    oprot.WriteFieldEnd();
  end;
  if (Set_field <> nil) and __isset_Set_field then
  begin
    field_.Name := 'set_field';
    field_.Type_  := {TType.}Set_;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    set_42 := TSetImpl.Create({TType.}Struct, Set_field.Count);
    oprot.WriteSetBegin( set_42);
    ikn45:=Set_field.Count;
    for ik44:=0 to ikn45 do 
    begin
    _iter43:=Set_field.Items[ik44];
      _iter43.Write(oprot);
    end;
    oprot.WriteSetEnd();
    oprot.WriteFieldEnd();
  end;
  if (List_field <> nil) then
  begin
    field_.Name := 'list_field';
    field_.Type_  := {TType.}List;
    field_.ID := 3;
    oprot.WriteFieldBegin(field_);
    list_46 := TListImpl.Create({TType.}Map, List_field.Count);
    oprot.WriteListBegin( list_46);
    ikn49:=List_field.Count;
    for ik48:=0 to ikn49 do 
    begin
    _iter47:=List_field.Items[ik48];
      map50 := TMapImpl.Create( {TType.}Set_, {TType.}Map, _iter47.Count);
      oprot.WriteMapBegin( map50);
      ikn53:=_iter47.Count;
      for ik52:=0 to ikn53 do 
      begin
      _iter51:=_iter47.Keys[ik52];
        set_54 := TSetImpl.Create({TType.}I32, _iter51.Count);
        oprot.WriteSetBegin( set_54);
        ikn57:=_iter51.Count;
        for ik56:=0 to ikn57 do 
        begin
        _iter55:=_iter51.Items[ik56];
          oprot.WriteI32(_iter55);
        end;
        oprot.WriteSetEnd();
        map58 := TMapImpl.Create( {TType.}I32, {TType.}Set_, _iter47[_iter51].Count);
        oprot.WriteMapBegin( map58);
        ikn61:=_iter47[_iter51].Count;
        for ik60:=0 to ikn61 do 
        begin
        _iter59:=_iter47[_iter51].Keys[ik60];
          oprot.WriteI32(_iter59);
          set_62 := TSetImpl.Create({TType.}List, _iter47[_iter51][_iter59].Count);
          oprot.WriteSetBegin( set_62);
          ikn65:=_iter47[_iter51][_iter59].Count;
          for ik64:=0 to ikn65 do 
          begin
          _iter63:=_iter47[_iter51][_iter59].Items[ik64];
            list_66 := TListImpl.Create({TType.}Map, _iter63.Count);
            oprot.WriteListBegin( list_66);
            ikn69:=_iter63.Count;
            for ik68:=0 to ikn69 do 
            begin
            _iter67:=_iter63.Items[ik68];
              map70 := TMapImpl.Create( {TType.}Struct, {TType.}String_, _iter67.Count);
              oprot.WriteMapBegin( map70);
              ikn73:=_iter67.Count;
              for ik72:=0 to ikn73 do 
              begin
              _iter71:=_iter67.Keys[ik72];
                _iter71.Write(oprot);
                oprot.WriteString(_iter67[_iter71]);
              end;
              oprot.WriteMapEnd();
            end;
            oprot.WriteListEnd();
          end;
          oprot.WriteSetEnd();
        end;
        oprot.WriteMapEnd();
      end;
      oprot.WriteMapEnd();
    end;
    oprot.WriteListEnd();
    oprot.WriteFieldEnd();
  end;
  if (__isset_Binary_field) then
  begin
    field_.Name := 'binary_field';
    field_.Type_  := {TType.}String_;
    field_.ID := 4;
    oprot.WriteFieldBegin(field_);
    oprot.WriteBinary(Binary_field);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TCrazyNestingImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('String_field: ');
    sb.Append(String_field);
    sb.Append(',Set_field: ');
    sb.Append(Set_field);
    sb.Append(',List_field: ');
    sb.Append(List_field);
    sb.Append(',Binary_field: ');
    sb.Append(Binary_field);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TXception.TXceptionFactoryImpl.Create;
begin
  inherited;
end;

destructor TXception.TXceptionFactoryImpl.Destroy;
begin
  inherited;
end;

function TXception.TXceptionFactoryImpl.GetErrorCode: Integer;
begin
  Result := FErrorCode;
end;

procedure TXception.TXceptionFactoryImpl.SetErrorCode( const Value: Integer);
begin
  F__isset_ErrorCode := True;
  FErrorCode := Value;
end;

function TXception.TXceptionFactoryImpl.Get__isset_ErrorCode: Boolean;
begin
  Result := F__isset_ErrorCode;
end;

function TXception.TXceptionFactoryImpl.GetMessage_: string;
begin
  Result := FMessage_;
end;

procedure TXception.TXceptionFactoryImpl.SetMessage_( const Value: string);
begin
  F__isset_Message_ := True;
  FMessage_ := Value;
end;

function TXception.TXceptionFactoryImpl.Get__isset_Message_: Boolean;
begin
  Result := F__isset_Message_;
end;

procedure TXception.TXceptionFactoryImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            ErrorCode := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = {TType.}String_) then
          begin
            Message_ := iprot.ReadString();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TXception.TXceptionFactoryImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('Xception');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_ErrorCode) then
  begin
    field_.Name := 'errorCode';
    field_.Type_  := {TType.}I32;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(ErrorCode);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Message_) then
  begin
    field_.Name := 'message';
    field_.Type_  := {TType.}String_;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    oprot.WriteString(Message_);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TXception.TXceptionFactoryImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('ErrorCode: ');
    sb.Append(ErrorCode);
    sb.Append(',Message_: ');
    sb.Append(Message_);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

function TXception.TXceptionFactoryImpl.CreateException: TXception;
begin
  Result := TXception.Create;
  Result.XceptionFactory := Self;
  if __isset_ErrorCode then
  begin
    Result.ErrorCode := ErrorCode;
  end;
  if __isset_Message_ then
  begin
    Result.Message_ := Message_;
  end;
  Result.UpdateMessageProperty;
end;

constructor TXception.Create;
begin
  inherited Create('');
  FXceptionFactory := TXceptionFactoryImpl.Create;
end;

constructor TXception.Create( AErrorCode: Integer; const AMessage: string);
begin
  Create;
  ErrorCode := AErrorCode;
  Message_ := AMessage;
  UpdateMessageProperty;
end;

destructor TXception.Destroy;
begin
  inherited;
end;

function TXception.GetErrorCode: Integer;
begin
  Result := FErrorCode;
end;

procedure TXception.SetErrorCode( const Value: Integer);
begin
  F__isset_ErrorCode := True;
  FErrorCode := Value;
  FXceptionFactory.ErrorCode := Value;
end;

function TXception.Get__isset_ErrorCode: Boolean;
begin
  Result := F__isset_ErrorCode;
end;

function TXception.GetMessage_: string;
begin
  Result := FMessage_;
end;

procedure TXception.SetMessage_( const Value: string);
begin
  F__isset_Message_ := True;
  FMessage_ := Value;
  FXceptionFactory.Message_ := Value;
end;

function TXception.Get__isset_Message_: Boolean;
begin
  Result := F__isset_Message_;
end;

function TXception.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('ErrorCode: ');
    sb.Append(ErrorCode);
    sb.Append(',Message_: ');
    sb.Append(Message_);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TXception2.TXception2FactoryImpl.Create;
begin
  inherited;
end;

destructor TXception2.TXception2FactoryImpl.Destroy;
begin
  inherited;
end;

function TXception2.TXception2FactoryImpl.GetErrorCode: Integer;
begin
  Result := FErrorCode;
end;

procedure TXception2.TXception2FactoryImpl.SetErrorCode( const Value: Integer);
begin
  F__isset_ErrorCode := True;
  FErrorCode := Value;
end;

function TXception2.TXception2FactoryImpl.Get__isset_ErrorCode: Boolean;
begin
  Result := F__isset_ErrorCode;
end;

function TXception2.TXception2FactoryImpl.GetStruct_thing: IXtruct;
begin
  Result := FStruct_thing;
end;

procedure TXception2.TXception2FactoryImpl.SetStruct_thing( const Value: IXtruct);
begin
  F__isset_Struct_thing := True;
  FStruct_thing := Value;
end;

function TXception2.TXception2FactoryImpl.Get__isset_Struct_thing: Boolean;
begin
  Result := F__isset_Struct_thing;
end;

procedure TXception2.TXception2FactoryImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            ErrorCode := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            Struct_thing := TXtructImpl.Create;
            Struct_thing.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TXception2.TXception2FactoryImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('Xception2');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_ErrorCode) then
  begin
    field_.Name := 'errorCode';
    field_.Type_  := {TType.}I32;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(ErrorCode);
    oprot.WriteFieldEnd();
  end;
  if (Struct_thing <> nil) and __isset_Struct_thing then
  begin
    field_.Name := 'struct_thing';
    field_.Type_  := {TType.}Struct;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    Struct_thing.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TXception2.TXception2FactoryImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('ErrorCode: ');
    sb.Append(ErrorCode);
    sb.Append(',Struct_thing: ');
    if (Struct_thing = nil) then sb.Append('<null>') else sb.Append(Struct_thing.ToString());
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

function TXception2.TXception2FactoryImpl.CreateException: TXception2;
begin
  Result := TXception2.Create;
  Result.Xception2Factory := Self;
  if __isset_ErrorCode then
  begin
    Result.ErrorCode := ErrorCode;
  end;
  if __isset_Struct_thing then
  begin
    Result.Struct_thing := Struct_thing;
  end;
  Result.UpdateMessageProperty;
end;

constructor TXception2.Create;
begin
  inherited Create('');
  FXception2Factory := TXception2FactoryImpl.Create;
end;

constructor TXception2.Create( AErrorCode: Integer; const AStruct_thing: IXtruct);
begin
  Create;
  ErrorCode := AErrorCode;
  Struct_thing := AStruct_thing;
  UpdateMessageProperty;
end;

destructor TXception2.Destroy;
begin
  inherited;
end;

function TXception2.GetErrorCode: Integer;
begin
  Result := FErrorCode;
end;

procedure TXception2.SetErrorCode( const Value: Integer);
begin
  F__isset_ErrorCode := True;
  FErrorCode := Value;
  FXception2Factory.ErrorCode := Value;
end;

function TXception2.Get__isset_ErrorCode: Boolean;
begin
  Result := F__isset_ErrorCode;
end;

function TXception2.GetStruct_thing: IXtruct;
begin
  Result := FStruct_thing;
end;

procedure TXception2.SetStruct_thing( const Value: IXtruct);
begin
  F__isset_Struct_thing := True;
  FStruct_thing := Value;
  FXception2Factory.Struct_thing := Value;
end;

function TXception2.Get__isset_Struct_thing: Boolean;
begin
  Result := F__isset_Struct_thing;
end;

function TXception2.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('ErrorCode: ');
    sb.Append(ErrorCode);
    sb.Append(',Struct_thing: ');
    if (Struct_thing = nil) then sb.Append('<null>') else sb.Append(Struct_thing.ToString());
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TEmptyStructImpl.Create;
begin
  inherited;
end;

destructor TEmptyStructImpl.Destroy;
begin
  inherited;
end;

procedure TEmptyStructImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      TProtocolUtil.Skip(iprot, field_.Type_);
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TEmptyStructImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
begin
  struc := TStructImpl.Create('EmptyStruct');
  oprot.WriteStructBegin(struc);
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TEmptyStructImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TOneFieldImpl.Create;
begin
  inherited;
end;

destructor TOneFieldImpl.Destroy;
begin
  inherited;
end;

function TOneFieldImpl.GetField: IEmptyStruct;
begin
  Result := FField;
end;

procedure TOneFieldImpl.SetField( const Value: IEmptyStruct);
begin
  F__isset_Field := True;
  FField := Value;
end;

function TOneFieldImpl.Get__isset_Field: Boolean;
begin
  Result := F__isset_Field;
end;

procedure TOneFieldImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            Field := TEmptyStructImpl.Create;
            Field.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TOneFieldImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('OneField');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Field <> nil) and __isset_Field then
  begin
    field_.Name := 'field';
    field_.Type_  := {TType.}Struct;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    Field.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TOneFieldImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Field: ');
    if (Field = nil) then sb.Append('<null>') else sb.Append(Field.ToString());
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TVersioningTestV1Impl.Create;
begin
  inherited;
end;

destructor TVersioningTestV1Impl.Destroy;
begin
  inherited;
end;

function TVersioningTestV1Impl.GetBegin_in_both: Integer;
begin
  Result := FBegin_in_both;
end;

procedure TVersioningTestV1Impl.SetBegin_in_both( const Value: Integer);
begin
  F__isset_Begin_in_both := True;
  FBegin_in_both := Value;
end;

function TVersioningTestV1Impl.Get__isset_Begin_in_both: Boolean;
begin
  Result := F__isset_Begin_in_both;
end;

function TVersioningTestV1Impl.GetOld_string: string;
begin
  Result := FOld_string;
end;

procedure TVersioningTestV1Impl.SetOld_string( const Value: string);
begin
  F__isset_Old_string := True;
  FOld_string := Value;
end;

function TVersioningTestV1Impl.Get__isset_Old_string: Boolean;
begin
  Result := F__isset_Old_string;
end;

function TVersioningTestV1Impl.GetEnd_in_both: Integer;
begin
  Result := FEnd_in_both;
end;

procedure TVersioningTestV1Impl.SetEnd_in_both( const Value: Integer);
begin
  F__isset_End_in_both := True;
  FEnd_in_both := Value;
end;

function TVersioningTestV1Impl.Get__isset_End_in_both: Boolean;
begin
  Result := F__isset_End_in_both;
end;

procedure TVersioningTestV1Impl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            Begin_in_both := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        3: begin
          if (field_.Type_ = {TType.}String_) then
          begin
            Old_string := iprot.ReadString();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        12: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            End_in_both := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TVersioningTestV1Impl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('VersioningTestV1');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Begin_in_both) then
  begin
    field_.Name := 'begin_in_both';
    field_.Type_  := {TType.}I32;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Begin_in_both);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Old_string) then
  begin
    field_.Name := 'old_string';
    field_.Type_  := {TType.}String_;
    field_.ID := 3;
    oprot.WriteFieldBegin(field_);
    oprot.WriteString(Old_string);
    oprot.WriteFieldEnd();
  end;
  if (__isset_End_in_both) then
  begin
    field_.Name := 'end_in_both';
    field_.Type_  := {TType.}I32;
    field_.ID := 12;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(End_in_both);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TVersioningTestV1Impl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Begin_in_both: ');
    sb.Append(Begin_in_both);
    sb.Append(',Old_string: ');
    sb.Append(Old_string);
    sb.Append(',End_in_both: ');
    sb.Append(End_in_both);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TVersioningTestV2Impl.Create;
begin
  inherited;
end;

destructor TVersioningTestV2Impl.Destroy;
begin
  inherited;
end;

function TVersioningTestV2Impl.GetBegin_in_both: Integer;
begin
  Result := FBegin_in_both;
end;

procedure TVersioningTestV2Impl.SetBegin_in_both( const Value: Integer);
begin
  F__isset_Begin_in_both := True;
  FBegin_in_both := Value;
end;

function TVersioningTestV2Impl.Get__isset_Begin_in_both: Boolean;
begin
  Result := F__isset_Begin_in_both;
end;

function TVersioningTestV2Impl.GetNewint: Integer;
begin
  Result := FNewint;
end;

procedure TVersioningTestV2Impl.SetNewint( const Value: Integer);
begin
  F__isset_Newint := True;
  FNewint := Value;
end;

function TVersioningTestV2Impl.Get__isset_Newint: Boolean;
begin
  Result := F__isset_Newint;
end;

function TVersioningTestV2Impl.GetNewbyte: ShortInt;
begin
  Result := FNewbyte;
end;

procedure TVersioningTestV2Impl.SetNewbyte( const Value: ShortInt);
begin
  F__isset_Newbyte := True;
  FNewbyte := Value;
end;

function TVersioningTestV2Impl.Get__isset_Newbyte: Boolean;
begin
  Result := F__isset_Newbyte;
end;

function TVersioningTestV2Impl.GetNewshort: SmallInt;
begin
  Result := FNewshort;
end;

procedure TVersioningTestV2Impl.SetNewshort( const Value: SmallInt);
begin
  F__isset_Newshort := True;
  FNewshort := Value;
end;

function TVersioningTestV2Impl.Get__isset_Newshort: Boolean;
begin
  Result := F__isset_Newshort;
end;

function TVersioningTestV2Impl.GetNewlong: Int64;
begin
  Result := FNewlong;
end;

procedure TVersioningTestV2Impl.SetNewlong( const Value: Int64);
begin
  F__isset_Newlong := True;
  FNewlong := Value;
end;

function TVersioningTestV2Impl.Get__isset_Newlong: Boolean;
begin
  Result := F__isset_Newlong;
end;

function TVersioningTestV2Impl.GetNewdouble: Double;
begin
  Result := FNewdouble;
end;

procedure TVersioningTestV2Impl.SetNewdouble( const Value: Double);
begin
  F__isset_Newdouble := True;
  FNewdouble := Value;
end;

function TVersioningTestV2Impl.Get__isset_Newdouble: Boolean;
begin
  Result := F__isset_Newdouble;
end;

function TVersioningTestV2Impl.GetNewstruct: IBonk;
begin
  Result := FNewstruct;
end;

procedure TVersioningTestV2Impl.SetNewstruct( const Value: IBonk);
begin
  F__isset_Newstruct := True;
  FNewstruct := Value;
end;

function TVersioningTestV2Impl.Get__isset_Newstruct: Boolean;
begin
  Result := F__isset_Newstruct;
end;

function TVersioningTestV2Impl.GetNewlist: IThriftList;
begin
  Result := FNewlist;
end;

procedure TVersioningTestV2Impl.SetNewlist( const Value: IThriftList);
begin
  F__isset_Newlist := True;
  FNewlist := Value;
end;

function TVersioningTestV2Impl.Get__isset_Newlist: Boolean;
begin
  Result := F__isset_Newlist;
end;

function TVersioningTestV2Impl.GetNewset: IHashSet;
begin
  Result := FNewset;
end;

procedure TVersioningTestV2Impl.SetNewset( const Value: IHashSet);
begin
  F__isset_Newset := True;
  FNewset := Value;
end;

function TVersioningTestV2Impl.Get__isset_Newset: Boolean;
begin
  Result := F__isset_Newset;
end;

function TVersioningTestV2Impl.GetNewmap: IThriftDictionary;
begin
  Result := FNewmap;
end;

procedure TVersioningTestV2Impl.SetNewmap( const Value: IThriftDictionary);
begin
  F__isset_Newmap := True;
  FNewmap := Value;
end;

function TVersioningTestV2Impl.Get__isset_Newmap: Boolean;
begin
  Result := F__isset_Newmap;
end;

function TVersioningTestV2Impl.GetNewstring: string;
begin
  Result := FNewstring;
end;

procedure TVersioningTestV2Impl.SetNewstring( const Value: string);
begin
  F__isset_Newstring := True;
  FNewstring := Value;
end;

function TVersioningTestV2Impl.Get__isset_Newstring: Boolean;
begin
  Result := F__isset_Newstring;
end;

function TVersioningTestV2Impl.GetEnd_in_both: Integer;
begin
  Result := FEnd_in_both;
end;

procedure TVersioningTestV2Impl.SetEnd_in_both( const Value: Integer);
begin
  F__isset_End_in_both := True;
  FEnd_in_both := Value;
end;

function TVersioningTestV2Impl.Get__isset_End_in_both: Boolean;
begin
  Result := F__isset_End_in_both;
end;

procedure TVersioningTestV2Impl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _list74: IList;
  _i75: Integer;
  _elem76: Integer;
  _set77: ISet;
  _i78: Integer;
  _elem79: Integer;
  _map80: IMap;
  _i81: Integer;
  _key82: Integer;
  _val83: Integer;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            Begin_in_both := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            Newint := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        3: begin
          if (field_.Type_ = {TType.}Byte_) then
          begin
            Newbyte := iprot.ReadByte();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        4: begin
          if (field_.Type_ = {TType.}I16) then
          begin
            Newshort := iprot.ReadI16();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        5: begin
          if (field_.Type_ = {TType.}I64) then
          begin
            Newlong := iprot.ReadI64();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        6: begin
          if (field_.Type_ = {TType.}Double_) then
          begin
            Newdouble := iprot.ReadDouble();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        7: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            Newstruct := TBonkImpl.Create;
            Newstruct.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        8: begin
          if (field_.Type_ = {TType.}List) then
          begin
            Newlist := TThriftListImpl.Create;
            _list74 := iprot.ReadListBegin();
            for _i75 := 0 to _list74.Count - 1 do
            begin
              _elem76 := iprot.ReadI32();
              Newlist.Add(_elem76);
            end;
            iprot.ReadListEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        9: begin
          if (field_.Type_ = {TType.}Set_) then
          begin
            Newset := THashSetImpl.Create;
            _set77 := iprot.ReadSetBegin();
            for _i78 := 0 to _set77.Count - 1 do
            begin
              _elem79 := iprot.ReadI32();
              Newset.Add(_elem79);
            end;
            iprot.ReadSetEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        10: begin
          if (field_.Type_ = {TType.}Map) then
          begin
            Newmap := TThriftDictionaryImpl.Create;
            _map80 := iprot.ReadMapBegin();
            for _i81 := 0 to _map80.Count - 1 do
            begin
              _key82 := iprot.ReadI32();
              _val83 := iprot.ReadI32();
              Newmap.AddOrSetValue( _key82, _val83);
            end;
            iprot.ReadMapEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        11: begin
          if (field_.Type_ = {TType.}String_) then
          begin
            Newstring := iprot.ReadString();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        12: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            End_in_both := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TVersioningTestV2Impl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  list_84 : IList;
  ik86:integer;
  ikn87:integer;
  _iter85: Integer;
  set_88 : ISet;
  ik90:integer;
  ikn91:integer;
  _iter89: Integer;
  map92 : IMap;
  ik94:integer;
  ikn95:integer;
  _iter93: Integer;
begin
  struc := TStructImpl.Create('VersioningTestV2');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Begin_in_both) then
  begin
    field_.Name := 'begin_in_both';
    field_.Type_  := {TType.}I32;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Begin_in_both);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Newint) then
  begin
    field_.Name := 'newint';
    field_.Type_  := {TType.}I32;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Newint);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Newbyte) then
  begin
    field_.Name := 'newbyte';
    field_.Type_  := {TType.}Byte_;
    field_.ID := 3;
    oprot.WriteFieldBegin(field_);
    oprot.WriteByte(Newbyte);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Newshort) then
  begin
    field_.Name := 'newshort';
    field_.Type_  := {TType.}I16;
    field_.ID := 4;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI16(Newshort);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Newlong) then
  begin
    field_.Name := 'newlong';
    field_.Type_  := {TType.}I64;
    field_.ID := 5;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI64(Newlong);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Newdouble) then
  begin
    field_.Name := 'newdouble';
    field_.Type_  := {TType.}Double_;
    field_.ID := 6;
    oprot.WriteFieldBegin(field_);
    oprot.WriteDouble(Newdouble);
    oprot.WriteFieldEnd();
  end;
  if (Newstruct <> nil) and __isset_Newstruct then
  begin
    field_.Name := 'newstruct';
    field_.Type_  := {TType.}Struct;
    field_.ID := 7;
    oprot.WriteFieldBegin(field_);
    Newstruct.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  if (Newlist <> nil) and __isset_Newlist then
  begin
    field_.Name := 'newlist';
    field_.Type_  := {TType.}List;
    field_.ID := 8;
    oprot.WriteFieldBegin(field_);
    list_84 := TListImpl.Create({TType.}I32, Newlist.Count);
    oprot.WriteListBegin( list_84);
    ikn87:=Newlist.Count;
    for ik86:=0 to ikn87 do 
    begin
    _iter85:=Newlist.Items[ik86];
      oprot.WriteI32(_iter85);
    end;
    oprot.WriteListEnd();
    oprot.WriteFieldEnd();
  end;
  if (Newset <> nil) and __isset_Newset then
  begin
    field_.Name := 'newset';
    field_.Type_  := {TType.}Set_;
    field_.ID := 9;
    oprot.WriteFieldBegin(field_);
    set_88 := TSetImpl.Create({TType.}I32, Newset.Count);
    oprot.WriteSetBegin( set_88);
    ikn91:=Newset.Count;
    for ik90:=0 to ikn91 do 
    begin
    _iter89:=Newset.Items[ik90];
      oprot.WriteI32(_iter89);
    end;
    oprot.WriteSetEnd();
    oprot.WriteFieldEnd();
  end;
  if (Newmap <> nil) and __isset_Newmap then
  begin
    field_.Name := 'newmap';
    field_.Type_  := {TType.}Map;
    field_.ID := 10;
    oprot.WriteFieldBegin(field_);
    map92 := TMapImpl.Create( {TType.}I32, {TType.}I32, Newmap.Count);
    oprot.WriteMapBegin( map92);
    ikn95:=Newmap.Count;
    for ik94:=0 to ikn95 do 
    begin
    _iter93:=Newmap.Keys[ik94];
      oprot.WriteI32(_iter93);
      oprot.WriteI32(Newmap[_iter93]);
    end;
    oprot.WriteMapEnd();
    oprot.WriteFieldEnd();
  end;
  if (__isset_Newstring) then
  begin
    field_.Name := 'newstring';
    field_.Type_  := {TType.}String_;
    field_.ID := 11;
    oprot.WriteFieldBegin(field_);
    oprot.WriteString(Newstring);
    oprot.WriteFieldEnd();
  end;
  if (__isset_End_in_both) then
  begin
    field_.Name := 'end_in_both';
    field_.Type_  := {TType.}I32;
    field_.ID := 12;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(End_in_both);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TVersioningTestV2Impl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Begin_in_both: ');
    sb.Append(Begin_in_both);
    sb.Append(',Newint: ');
    sb.Append(Newint);
    sb.Append(',Newbyte: ');
    sb.Append(Newbyte);
    sb.Append(',Newshort: ');
    sb.Append(Newshort);
    sb.Append(',Newlong: ');
    sb.Append(Newlong);
    sb.Append(',Newdouble: ');
    sb.Append(Newdouble);
    sb.Append(',Newstruct: ');
    if (Newstruct = nil) then sb.Append('<null>') else sb.Append(Newstruct.ToString());
    sb.Append(',Newlist: ');
    sb.Append(Newlist);
    sb.Append(',Newset: ');
    sb.Append(Newset);
    sb.Append(',Newmap: ');
    sb.Append(Newmap);
    sb.Append(',Newstring: ');
    sb.Append(Newstring);
    sb.Append(',End_in_both: ');
    sb.Append(End_in_both);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TListTypeVersioningV1Impl.Create;
begin
  inherited;
end;

destructor TListTypeVersioningV1Impl.Destroy;
begin
  inherited;
end;

function TListTypeVersioningV1Impl.GetMyints: IThriftList;
begin
  Result := FMyints;
end;

procedure TListTypeVersioningV1Impl.SetMyints( const Value: IThriftList);
begin
  F__isset_Myints := True;
  FMyints := Value;
end;

function TListTypeVersioningV1Impl.Get__isset_Myints: Boolean;
begin
  Result := F__isset_Myints;
end;

function TListTypeVersioningV1Impl.GetHello: string;
begin
  Result := FHello;
end;

procedure TListTypeVersioningV1Impl.SetHello( const Value: string);
begin
  F__isset_Hello := True;
  FHello := Value;
end;

function TListTypeVersioningV1Impl.Get__isset_Hello: Boolean;
begin
  Result := F__isset_Hello;
end;

procedure TListTypeVersioningV1Impl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _list96: IList;
  _i97: Integer;
  _elem98: Integer;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}List) then
          begin
            Myints := TThriftListImpl.Create;
            _list96 := iprot.ReadListBegin();
            for _i97 := 0 to _list96.Count - 1 do
            begin
              _elem98 := iprot.ReadI32();
              Myints.Add(_elem98);
            end;
            iprot.ReadListEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = {TType.}String_) then
          begin
            Hello := iprot.ReadString();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TListTypeVersioningV1Impl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  list_99 : IList;
  ik101:integer;
  ikn102:integer;
  _iter100: Integer;
begin
  struc := TStructImpl.Create('ListTypeVersioningV1');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Myints <> nil) and __isset_Myints then
  begin
    field_.Name := 'myints';
    field_.Type_  := {TType.}List;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    list_99 := TListImpl.Create({TType.}I32, Myints.Count);
    oprot.WriteListBegin( list_99);
    ikn102:=Myints.Count;
    for ik101:=0 to ikn102 do 
    begin
    _iter100:=Myints.Items[ik101];
      oprot.WriteI32(_iter100);
    end;
    oprot.WriteListEnd();
    oprot.WriteFieldEnd();
  end;
  if (__isset_Hello) then
  begin
    field_.Name := 'hello';
    field_.Type_  := {TType.}String_;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    oprot.WriteString(Hello);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TListTypeVersioningV1Impl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Myints: ');
    sb.Append(Myints);
    sb.Append(',Hello: ');
    sb.Append(Hello);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TListTypeVersioningV2Impl.Create;
begin
  inherited;
end;

destructor TListTypeVersioningV2Impl.Destroy;
begin
  inherited;
end;

function TListTypeVersioningV2Impl.GetStrings: IThriftList;
begin
  Result := FStrings;
end;

procedure TListTypeVersioningV2Impl.SetStrings( const Value: IThriftList);
begin
  F__isset_Strings := True;
  FStrings := Value;
end;

function TListTypeVersioningV2Impl.Get__isset_Strings: Boolean;
begin
  Result := F__isset_Strings;
end;

function TListTypeVersioningV2Impl.GetHello: string;
begin
  Result := FHello;
end;

procedure TListTypeVersioningV2Impl.SetHello( const Value: string);
begin
  F__isset_Hello := True;
  FHello := Value;
end;

function TListTypeVersioningV2Impl.Get__isset_Hello: Boolean;
begin
  Result := F__isset_Hello;
end;

procedure TListTypeVersioningV2Impl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _list103: IList;
  _i104: Integer;
  _elem105: string;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}List) then
          begin
            Strings := TThriftListImpl.Create;
            _list103 := iprot.ReadListBegin();
            for _i104 := 0 to _list103.Count - 1 do
            begin
              _elem105 := iprot.ReadString();
              Strings.Add(_elem105);
            end;
            iprot.ReadListEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = {TType.}String_) then
          begin
            Hello := iprot.ReadString();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TListTypeVersioningV2Impl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  list_106 : IList;
  ik108:integer;
  ikn109:integer;
  _iter107: string;
begin
  struc := TStructImpl.Create('ListTypeVersioningV2');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Strings <> nil) and __isset_Strings then
  begin
    field_.Name := 'strings';
    field_.Type_  := {TType.}List;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    list_106 := TListImpl.Create({TType.}String_, Strings.Count);
    oprot.WriteListBegin( list_106);
    ikn109:=Strings.Count;
    for ik108:=0 to ikn109 do 
    begin
    _iter107:=Strings.Items[ik108];
      oprot.WriteString(_iter107);
    end;
    oprot.WriteListEnd();
    oprot.WriteFieldEnd();
  end;
  if (__isset_Hello) then
  begin
    field_.Name := 'hello';
    field_.Type_  := {TType.}String_;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    oprot.WriteString(Hello);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TListTypeVersioningV2Impl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Strings: ');
    sb.Append(Strings);
    sb.Append(',Hello: ');
    sb.Append(Hello);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TGuessProtocolStructImpl.Create;
begin
  inherited;
end;

destructor TGuessProtocolStructImpl.Destroy;
begin
  inherited;
end;

function TGuessProtocolStructImpl.GetMap_field: IThriftDictionary;
begin
  Result := FMap_field;
end;

procedure TGuessProtocolStructImpl.SetMap_field( const Value: IThriftDictionary);
begin
  F__isset_Map_field := True;
  FMap_field := Value;
end;

function TGuessProtocolStructImpl.Get__isset_Map_field: Boolean;
begin
  Result := F__isset_Map_field;
end;

procedure TGuessProtocolStructImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _map110: IMap;
  _i111: Integer;
  _key112: string;
  _val113: string;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        7: begin
          if (field_.Type_ = {TType.}Map) then
          begin
            Map_field := TThriftDictionaryImpl.Create;
            _map110 := iprot.ReadMapBegin();
            for _i111 := 0 to _map110.Count - 1 do
            begin
              _key112 := iprot.ReadString();
              _val113 := iprot.ReadString();
              Map_field.AddOrSetValue( _key112, _val113);
            end;
            iprot.ReadMapEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TGuessProtocolStructImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  map114 : IMap;
  ik116:integer;
  ikn117:integer;
  _iter115: string;
begin
  struc := TStructImpl.Create('GuessProtocolStruct');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Map_field <> nil) and __isset_Map_field then
  begin
    field_.Name := 'map_field';
    field_.Type_  := {TType.}Map;
    field_.ID := 7;
    oprot.WriteFieldBegin(field_);
    map114 := TMapImpl.Create( {TType.}String_, {TType.}String_, Map_field.Count);
    oprot.WriteMapBegin( map114);
    ikn117:=Map_field.Count;
    for ik116:=0 to ikn117 do 
    begin
    _iter115:=Map_field.Keys[ik116];
      oprot.WriteString(_iter115);
      oprot.WriteString(Map_field[_iter115]);
    end;
    oprot.WriteMapEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TGuessProtocolStructImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Map_field: ');
    sb.Append(Map_field);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TLargeDeltasImpl.Create;
begin
  inherited;
end;

destructor TLargeDeltasImpl.Destroy;
begin
  inherited;
end;

function TLargeDeltasImpl.GetB1: IBools;
begin
  Result := FB1;
end;

procedure TLargeDeltasImpl.SetB1( const Value: IBools);
begin
  F__isset_B1 := True;
  FB1 := Value;
end;

function TLargeDeltasImpl.Get__isset_B1: Boolean;
begin
  Result := F__isset_B1;
end;

function TLargeDeltasImpl.GetB10: IBools;
begin
  Result := FB10;
end;

procedure TLargeDeltasImpl.SetB10( const Value: IBools);
begin
  F__isset_B10 := True;
  FB10 := Value;
end;

function TLargeDeltasImpl.Get__isset_B10: Boolean;
begin
  Result := F__isset_B10;
end;

function TLargeDeltasImpl.GetB100: IBools;
begin
  Result := FB100;
end;

procedure TLargeDeltasImpl.SetB100( const Value: IBools);
begin
  F__isset_B100 := True;
  FB100 := Value;
end;

function TLargeDeltasImpl.Get__isset_B100: Boolean;
begin
  Result := F__isset_B100;
end;

function TLargeDeltasImpl.GetCheck_true: Boolean;
begin
  Result := FCheck_true;
end;

procedure TLargeDeltasImpl.SetCheck_true( const Value: Boolean);
begin
  F__isset_Check_true := True;
  FCheck_true := Value;
end;

function TLargeDeltasImpl.Get__isset_Check_true: Boolean;
begin
  Result := F__isset_Check_true;
end;

function TLargeDeltasImpl.GetB1000: IBools;
begin
  Result := FB1000;
end;

procedure TLargeDeltasImpl.SetB1000( const Value: IBools);
begin
  F__isset_B1000 := True;
  FB1000 := Value;
end;

function TLargeDeltasImpl.Get__isset_B1000: Boolean;
begin
  Result := F__isset_B1000;
end;

function TLargeDeltasImpl.GetCheck_false: Boolean;
begin
  Result := FCheck_false;
end;

procedure TLargeDeltasImpl.SetCheck_false( const Value: Boolean);
begin
  F__isset_Check_false := True;
  FCheck_false := Value;
end;

function TLargeDeltasImpl.Get__isset_Check_false: Boolean;
begin
  Result := F__isset_Check_false;
end;

function TLargeDeltasImpl.GetVertwo2000: IVersioningTestV2;
begin
  Result := FVertwo2000;
end;

procedure TLargeDeltasImpl.SetVertwo2000( const Value: IVersioningTestV2);
begin
  F__isset_Vertwo2000 := True;
  FVertwo2000 := Value;
end;

function TLargeDeltasImpl.Get__isset_Vertwo2000: Boolean;
begin
  Result := F__isset_Vertwo2000;
end;

function TLargeDeltasImpl.GetA_set2500: IHashSet;
begin
  Result := FA_set2500;
end;

procedure TLargeDeltasImpl.SetA_set2500( const Value: IHashSet);
begin
  F__isset_A_set2500 := True;
  FA_set2500 := Value;
end;

function TLargeDeltasImpl.Get__isset_A_set2500: Boolean;
begin
  Result := F__isset_A_set2500;
end;

function TLargeDeltasImpl.GetVertwo3000: IVersioningTestV2;
begin
  Result := FVertwo3000;
end;

procedure TLargeDeltasImpl.SetVertwo3000( const Value: IVersioningTestV2);
begin
  F__isset_Vertwo3000 := True;
  FVertwo3000 := Value;
end;

function TLargeDeltasImpl.Get__isset_Vertwo3000: Boolean;
begin
  Result := F__isset_Vertwo3000;
end;

function TLargeDeltasImpl.GetBig_numbers: IThriftList;
begin
  Result := FBig_numbers;
end;

procedure TLargeDeltasImpl.SetBig_numbers( const Value: IThriftList);
begin
  F__isset_Big_numbers := True;
  FBig_numbers := Value;
end;

function TLargeDeltasImpl.Get__isset_Big_numbers: Boolean;
begin
  Result := F__isset_Big_numbers;
end;

procedure TLargeDeltasImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _set118: ISet;
  _i119: Integer;
  _elem120: string;
  _list121: IList;
  _i122: Integer;
  _elem123: Integer;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            B1 := TBoolsImpl.Create;
            B1.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        10: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            B10 := TBoolsImpl.Create;
            B10.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        100: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            B100 := TBoolsImpl.Create;
            B100.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        500: begin
          if (field_.Type_ = {TType.}Bool_) then
          begin
            Check_true := iprot.ReadBool();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        1000: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            B1000 := TBoolsImpl.Create;
            B1000.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        1500: begin
          if (field_.Type_ = {TType.}Bool_) then
          begin
            Check_false := iprot.ReadBool();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2000: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            Vertwo2000 := TVersioningTestV2Impl.Create;
            Vertwo2000.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2500: begin
          if (field_.Type_ = {TType.}Set_) then
          begin
            A_set2500 := THashSetImpl.Create;
            _set118 := iprot.ReadSetBegin();
            for _i119 := 0 to _set118.Count - 1 do
            begin
              _elem120 := iprot.ReadString();
              A_set2500.Add(_elem120);
            end;
            iprot.ReadSetEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        3000: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            Vertwo3000 := TVersioningTestV2Impl.Create;
            Vertwo3000.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        4000: begin
          if (field_.Type_ = {TType.}List) then
          begin
            Big_numbers := TThriftListImpl.Create;
            _list121 := iprot.ReadListBegin();
            for _i122 := 0 to _list121.Count - 1 do
            begin
              _elem123 := iprot.ReadI32();
              Big_numbers.Add(_elem123);
            end;
            iprot.ReadListEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TLargeDeltasImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  set_124 : ISet;
  ik126:integer;
  ikn127:integer;
  _iter125: string;
  list_128 : IList;
  ik130:integer;
  ikn131:integer;
  _iter129: Integer;
begin
  struc := TStructImpl.Create('LargeDeltas');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (B1 <> nil) and __isset_B1 then
  begin
    field_.Name := 'b1';
    field_.Type_  := {TType.}Struct;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    B1.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  if (B10 <> nil) and __isset_B10 then
  begin
    field_.Name := 'b10';
    field_.Type_  := {TType.}Struct;
    field_.ID := 10;
    oprot.WriteFieldBegin(field_);
    B10.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  if (B100 <> nil) and __isset_B100 then
  begin
    field_.Name := 'b100';
    field_.Type_  := {TType.}Struct;
    field_.ID := 100;
    oprot.WriteFieldBegin(field_);
    B100.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Check_true) then
  begin
    field_.Name := 'check_true';
    field_.Type_  := {TType.}Bool_;
    field_.ID := 500;
    oprot.WriteFieldBegin(field_);
    oprot.WriteBool(Check_true);
    oprot.WriteFieldEnd();
  end;
  if (B1000 <> nil) and __isset_B1000 then
  begin
    field_.Name := 'b1000';
    field_.Type_  := {TType.}Struct;
    field_.ID := 1000;
    oprot.WriteFieldBegin(field_);
    B1000.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Check_false) then
  begin
    field_.Name := 'check_false';
    field_.Type_  := {TType.}Bool_;
    field_.ID := 1500;
    oprot.WriteFieldBegin(field_);
    oprot.WriteBool(Check_false);
    oprot.WriteFieldEnd();
  end;
  if (Vertwo2000 <> nil) and __isset_Vertwo2000 then
  begin
    field_.Name := 'vertwo2000';
    field_.Type_  := {TType.}Struct;
    field_.ID := 2000;
    oprot.WriteFieldBegin(field_);
    Vertwo2000.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  if (A_set2500 <> nil) and __isset_A_set2500 then
  begin
    field_.Name := 'a_set2500';
    field_.Type_  := {TType.}Set_;
    field_.ID := 2500;
    oprot.WriteFieldBegin(field_);
    set_124 := TSetImpl.Create({TType.}String_, A_set2500.Count);
    oprot.WriteSetBegin( set_124);
    ikn127:=A_set2500.Count;
    for ik126:=0 to ikn127 do 
    begin
    _iter125:=A_set2500.Items[ik126];
      oprot.WriteString(_iter125);
    end;
    oprot.WriteSetEnd();
    oprot.WriteFieldEnd();
  end;
  if (Vertwo3000 <> nil) and __isset_Vertwo3000 then
  begin
    field_.Name := 'vertwo3000';
    field_.Type_  := {TType.}Struct;
    field_.ID := 3000;
    oprot.WriteFieldBegin(field_);
    Vertwo3000.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  if (Big_numbers <> nil) and __isset_Big_numbers then
  begin
    field_.Name := 'big_numbers';
    field_.Type_  := {TType.}List;
    field_.ID := 4000;
    oprot.WriteFieldBegin(field_);
    list_128 := TListImpl.Create({TType.}I32, Big_numbers.Count);
    oprot.WriteListBegin( list_128);
    ikn131:=Big_numbers.Count;
    for ik130:=0 to ikn131 do 
    begin
    _iter129:=Big_numbers.Items[ik130];
      oprot.WriteI32(_iter129);
    end;
    oprot.WriteListEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TLargeDeltasImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('B1: ');
    if (B1 = nil) then sb.Append('<null>') else sb.Append(B1.ToString());
    sb.Append(',B10: ');
    if (B10 = nil) then sb.Append('<null>') else sb.Append(B10.ToString());
    sb.Append(',B100: ');
    if (B100 = nil) then sb.Append('<null>') else sb.Append(B100.ToString());
    sb.Append(',Check_true: ');
    sb.Append(Check_true);
    sb.Append(',B1000: ');
    if (B1000 = nil) then sb.Append('<null>') else sb.Append(B1000.ToString());
    sb.Append(',Check_false: ');
    sb.Append(Check_false);
    sb.Append(',Vertwo2000: ');
    if (Vertwo2000 = nil) then sb.Append('<null>') else sb.Append(Vertwo2000.ToString());
    sb.Append(',A_set2500: ');
    sb.Append(A_set2500);
    sb.Append(',Vertwo3000: ');
    if (Vertwo3000 = nil) then sb.Append('<null>') else sb.Append(Vertwo3000.ToString());
    sb.Append(',Big_numbers: ');
    sb.Append(Big_numbers);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TNestedListsI32x2Impl.Create;
begin
  inherited;
end;

destructor TNestedListsI32x2Impl.Destroy;
begin
  inherited;
end;

function TNestedListsI32x2Impl.GetIntegerlist: IThriftList;
begin
  Result := FIntegerlist;
end;

procedure TNestedListsI32x2Impl.SetIntegerlist( const Value: IThriftList);
begin
  F__isset_Integerlist := True;
  FIntegerlist := Value;
end;

function TNestedListsI32x2Impl.Get__isset_Integerlist: Boolean;
begin
  Result := F__isset_Integerlist;
end;

procedure TNestedListsI32x2Impl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _list132: IList;
  _i133: Integer;
  _elem134: IThriftList;
  _list135: IList;
  _i136: Integer;
  _elem137: Integer;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}List) then
          begin
            Integerlist := TThriftListImpl.Create;
            _list132 := iprot.ReadListBegin();
            for _i133 := 0 to _list132.Count - 1 do
            begin
              _elem134 := TThriftListImpl.Create;
              _list135 := iprot.ReadListBegin();
              for _i136 := 0 to _list135.Count - 1 do
              begin
                _elem137 := iprot.ReadI32();
                _elem134.Add(_elem137);
              end;
              iprot.ReadListEnd();
              Integerlist.Add(_elem134);
            end;
            iprot.ReadListEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TNestedListsI32x2Impl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  list_138 : IList;
  ik140:integer;
  ikn141:integer;
  _iter139: IThriftList;
  list_142 : IList;
  ik144:integer;
  ikn145:integer;
  _iter143: Integer;
begin
  struc := TStructImpl.Create('NestedListsI32x2');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Integerlist <> nil) and __isset_Integerlist then
  begin
    field_.Name := 'integerlist';
    field_.Type_  := {TType.}List;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    list_138 := TListImpl.Create({TType.}List, Integerlist.Count);
    oprot.WriteListBegin( list_138);
    ikn141:=Integerlist.Count;
    for ik140:=0 to ikn141 do 
    begin
    _iter139:=Integerlist.Items[ik140];
      list_142 := TListImpl.Create({TType.}I32, _iter139.Count);
      oprot.WriteListBegin( list_142);
      ikn145:=_iter139.Count;
      for ik144:=0 to ikn145 do 
      begin
      _iter143:=_iter139.Items[ik144];
        oprot.WriteI32(_iter143);
      end;
      oprot.WriteListEnd();
    end;
    oprot.WriteListEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TNestedListsI32x2Impl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Integerlist: ');
    sb.Append(Integerlist);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TNestedListsI32x3Impl.Create;
begin
  inherited;
end;

destructor TNestedListsI32x3Impl.Destroy;
begin
  inherited;
end;

function TNestedListsI32x3Impl.GetIntegerlist: IThriftList;
begin
  Result := FIntegerlist;
end;

procedure TNestedListsI32x3Impl.SetIntegerlist( const Value: IThriftList);
begin
  F__isset_Integerlist := True;
  FIntegerlist := Value;
end;

function TNestedListsI32x3Impl.Get__isset_Integerlist: Boolean;
begin
  Result := F__isset_Integerlist;
end;

procedure TNestedListsI32x3Impl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _list146: IList;
  _i147: Integer;
  _elem148: IThriftList;
  _list149: IList;
  _i150: Integer;
  _elem151: IThriftList;
  _list152: IList;
  _i153: Integer;
  _elem154: Integer;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}List) then
          begin
            Integerlist := TThriftListImpl.Create;
            _list146 := iprot.ReadListBegin();
            for _i147 := 0 to _list146.Count - 1 do
            begin
              _elem148 := TThriftListImpl.Create;
              _list149 := iprot.ReadListBegin();
              for _i150 := 0 to _list149.Count - 1 do
              begin
                _elem151 := TThriftListImpl.Create;
                _list152 := iprot.ReadListBegin();
                for _i153 := 0 to _list152.Count - 1 do
                begin
                  _elem154 := iprot.ReadI32();
                  _elem151.Add(_elem154);
                end;
                iprot.ReadListEnd();
                _elem148.Add(_elem151);
              end;
              iprot.ReadListEnd();
              Integerlist.Add(_elem148);
            end;
            iprot.ReadListEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TNestedListsI32x3Impl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  list_155 : IList;
  ik157:integer;
  ikn158:integer;
  _iter156: IThriftList;
  list_159 : IList;
  ik161:integer;
  ikn162:integer;
  _iter160: IThriftList;
  list_163 : IList;
  ik165:integer;
  ikn166:integer;
  _iter164: Integer;
begin
  struc := TStructImpl.Create('NestedListsI32x3');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Integerlist <> nil) and __isset_Integerlist then
  begin
    field_.Name := 'integerlist';
    field_.Type_  := {TType.}List;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    list_155 := TListImpl.Create({TType.}List, Integerlist.Count);
    oprot.WriteListBegin( list_155);
    ikn158:=Integerlist.Count;
    for ik157:=0 to ikn158 do 
    begin
    _iter156:=Integerlist.Items[ik157];
      list_159 := TListImpl.Create({TType.}List, _iter156.Count);
      oprot.WriteListBegin( list_159);
      ikn162:=_iter156.Count;
      for ik161:=0 to ikn162 do 
      begin
      _iter160:=_iter156.Items[ik161];
        list_163 := TListImpl.Create({TType.}I32, _iter160.Count);
        oprot.WriteListBegin( list_163);
        ikn166:=_iter160.Count;
        for ik165:=0 to ikn166 do 
        begin
        _iter164:=_iter160.Items[ik165];
          oprot.WriteI32(_iter164);
        end;
        oprot.WriteListEnd();
      end;
      oprot.WriteListEnd();
    end;
    oprot.WriteListEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TNestedListsI32x3Impl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Integerlist: ');
    sb.Append(Integerlist);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TNestedMixedx2Impl.Create;
begin
  inherited;
end;

destructor TNestedMixedx2Impl.Destroy;
begin
  inherited;
end;

function TNestedMixedx2Impl.GetInt_set_list: IThriftList;
begin
  Result := FInt_set_list;
end;

procedure TNestedMixedx2Impl.SetInt_set_list( const Value: IThriftList);
begin
  F__isset_Int_set_list := True;
  FInt_set_list := Value;
end;

function TNestedMixedx2Impl.Get__isset_Int_set_list: Boolean;
begin
  Result := F__isset_Int_set_list;
end;

function TNestedMixedx2Impl.GetMap_int_strset: IThriftDictionary;
begin
  Result := FMap_int_strset;
end;

procedure TNestedMixedx2Impl.SetMap_int_strset( const Value: IThriftDictionary);
begin
  F__isset_Map_int_strset := True;
  FMap_int_strset := Value;
end;

function TNestedMixedx2Impl.Get__isset_Map_int_strset: Boolean;
begin
  Result := F__isset_Map_int_strset;
end;

function TNestedMixedx2Impl.GetMap_int_strset_list: IThriftList;
begin
  Result := FMap_int_strset_list;
end;

procedure TNestedMixedx2Impl.SetMap_int_strset_list( const Value: IThriftList);
begin
  F__isset_Map_int_strset_list := True;
  FMap_int_strset_list := Value;
end;

function TNestedMixedx2Impl.Get__isset_Map_int_strset_list: Boolean;
begin
  Result := F__isset_Map_int_strset_list;
end;

procedure TNestedMixedx2Impl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _list167: IList;
  _i168: Integer;
  _elem169: IHashSet;
  _set170: ISet;
  _i171: Integer;
  _elem172: Integer;
  _map173: IMap;
  _i174: Integer;
  _key175: Integer;
  _val176: IHashSet;
  _set177: ISet;
  _i178: Integer;
  _elem179: string;
  _list180: IList;
  _i181: Integer;
  _elem182: IThriftDictionary;
  _map183: IMap;
  _i184: Integer;
  _key185: Integer;
  _val186: IHashSet;
  _set187: ISet;
  _i188: Integer;
  _elem189: string;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}List) then
          begin
            Int_set_list := TThriftListImpl.Create;
            _list167 := iprot.ReadListBegin();
            for _i168 := 0 to _list167.Count - 1 do
            begin
              _elem169 := THashSetImpl.Create;
              _set170 := iprot.ReadSetBegin();
              for _i171 := 0 to _set170.Count - 1 do
              begin
                _elem172 := iprot.ReadI32();
                _elem169.Add(_elem172);
              end;
              iprot.ReadSetEnd();
              Int_set_list.Add(_elem169);
            end;
            iprot.ReadListEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = {TType.}Map) then
          begin
            Map_int_strset := TThriftDictionaryImpl.Create;
            _map173 := iprot.ReadMapBegin();
            for _i174 := 0 to _map173.Count - 1 do
            begin
              _key175 := iprot.ReadI32();
              _val176 := THashSetImpl.Create;
              _set177 := iprot.ReadSetBegin();
              for _i178 := 0 to _set177.Count - 1 do
              begin
                _elem179 := iprot.ReadString();
                _val176.Add(_elem179);
              end;
              iprot.ReadSetEnd();
              Map_int_strset.AddOrSetValue( _key175, _val176);
            end;
            iprot.ReadMapEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        3: begin
          if (field_.Type_ = {TType.}List) then
          begin
            Map_int_strset_list := TThriftListImpl.Create;
            _list180 := iprot.ReadListBegin();
            for _i181 := 0 to _list180.Count - 1 do
            begin
              _elem182 := TThriftDictionaryImpl.Create;
              _map183 := iprot.ReadMapBegin();
              for _i184 := 0 to _map183.Count - 1 do
              begin
                _key185 := iprot.ReadI32();
                _val186 := THashSetImpl.Create;
                _set187 := iprot.ReadSetBegin();
                for _i188 := 0 to _set187.Count - 1 do
                begin
                  _elem189 := iprot.ReadString();
                  _val186.Add(_elem189);
                end;
                iprot.ReadSetEnd();
                _elem182.AddOrSetValue( _key185, _val186);
              end;
              iprot.ReadMapEnd();
              Map_int_strset_list.Add(_elem182);
            end;
            iprot.ReadListEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TNestedMixedx2Impl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  list_190 : IList;
  ik192:integer;
  ikn193:integer;
  _iter191: IHashSet;
  set_194 : ISet;
  ik196:integer;
  ikn197:integer;
  _iter195: Integer;
  map198 : IMap;
  ik200:integer;
  ikn201:integer;
  _iter199: Integer;
  set_202 : ISet;
  ik204:integer;
  ikn205:integer;
  _iter203: string;
  list_206 : IList;
  ik208:integer;
  ikn209:integer;
  _iter207: IThriftDictionary;
  map210 : IMap;
  ik212:integer;
  ikn213:integer;
  _iter211: Integer;
  set_214 : ISet;
  ik216:integer;
  ikn217:integer;
  _iter215: string;
begin
  struc := TStructImpl.Create('NestedMixedx2');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Int_set_list <> nil) and __isset_Int_set_list then
  begin
    field_.Name := 'int_set_list';
    field_.Type_  := {TType.}List;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    list_190 := TListImpl.Create({TType.}Set_, Int_set_list.Count);
    oprot.WriteListBegin( list_190);
    ikn193:=Int_set_list.Count;
    for ik192:=0 to ikn193 do 
    begin
    _iter191:=Int_set_list.Items[ik192];
      set_194 := TSetImpl.Create({TType.}I32, _iter191.Count);
      oprot.WriteSetBegin( set_194);
      ikn197:=_iter191.Count;
      for ik196:=0 to ikn197 do 
      begin
      _iter195:=_iter191.Items[ik196];
        oprot.WriteI32(_iter195);
      end;
      oprot.WriteSetEnd();
    end;
    oprot.WriteListEnd();
    oprot.WriteFieldEnd();
  end;
  if (Map_int_strset <> nil) and __isset_Map_int_strset then
  begin
    field_.Name := 'map_int_strset';
    field_.Type_  := {TType.}Map;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    map198 := TMapImpl.Create( {TType.}I32, {TType.}Set_, Map_int_strset.Count);
    oprot.WriteMapBegin( map198);
    ikn201:=Map_int_strset.Count;
    for ik200:=0 to ikn201 do 
    begin
    _iter199:=Map_int_strset.Keys[ik200];
      oprot.WriteI32(_iter199);
      set_202 := TSetImpl.Create({TType.}String_, Map_int_strset[_iter199].Count);
      oprot.WriteSetBegin( set_202);
      ikn205:=Map_int_strset[_iter199].Count;
      for ik204:=0 to ikn205 do 
      begin
      _iter203:=Map_int_strset[_iter199].Items[ik204];
        oprot.WriteString(_iter203);
      end;
      oprot.WriteSetEnd();
    end;
    oprot.WriteMapEnd();
    oprot.WriteFieldEnd();
  end;
  if (Map_int_strset_list <> nil) and __isset_Map_int_strset_list then
  begin
    field_.Name := 'map_int_strset_list';
    field_.Type_  := {TType.}List;
    field_.ID := 3;
    oprot.WriteFieldBegin(field_);
    list_206 := TListImpl.Create({TType.}Map, Map_int_strset_list.Count);
    oprot.WriteListBegin( list_206);
    ikn209:=Map_int_strset_list.Count;
    for ik208:=0 to ikn209 do 
    begin
    _iter207:=Map_int_strset_list.Items[ik208];
      map210 := TMapImpl.Create( {TType.}I32, {TType.}Set_, _iter207.Count);
      oprot.WriteMapBegin( map210);
      ikn213:=_iter207.Count;
      for ik212:=0 to ikn213 do 
      begin
      _iter211:=_iter207.Keys[ik212];
        oprot.WriteI32(_iter211);
        set_214 := TSetImpl.Create({TType.}String_, _iter207[_iter211].Count);
        oprot.WriteSetBegin( set_214);
        ikn217:=_iter207[_iter211].Count;
        for ik216:=0 to ikn217 do 
        begin
        _iter215:=_iter207[_iter211].Items[ik216];
          oprot.WriteString(_iter215);
        end;
        oprot.WriteSetEnd();
      end;
      oprot.WriteMapEnd();
    end;
    oprot.WriteListEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TNestedMixedx2Impl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Int_set_list: ');
    sb.Append(Int_set_list);
    sb.Append(',Map_int_strset: ');
    sb.Append(Map_int_strset);
    sb.Append(',Map_int_strset_list: ');
    sb.Append(Map_int_strset_list);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TListBonksImpl.Create;
begin
  inherited;
end;

destructor TListBonksImpl.Destroy;
begin
  inherited;
end;

function TListBonksImpl.GetBonk: IThriftList;
begin
  Result := FBonk;
end;

procedure TListBonksImpl.SetBonk( const Value: IThriftList);
begin
  F__isset_Bonk := True;
  FBonk := Value;
end;

function TListBonksImpl.Get__isset_Bonk: Boolean;
begin
  Result := F__isset_Bonk;
end;

procedure TListBonksImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _list218: IList;
  _i219: Integer;
  _elem220: IBonk;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}List) then
          begin
            Bonk := TThriftListImpl.Create;
            _list218 := iprot.ReadListBegin();
            for _i219 := 0 to _list218.Count - 1 do
            begin
              _elem220 := TBonkImpl.Create;
              _elem220.Read(iprot);
              Bonk.Add(_elem220);
            end;
            iprot.ReadListEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TListBonksImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  list_221 : IList;
  ik223:integer;
  ikn224:integer;
  _iter222: IBonk;
begin
  struc := TStructImpl.Create('ListBonks');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Bonk <> nil) and __isset_Bonk then
  begin
    field_.Name := 'bonk';
    field_.Type_  := {TType.}List;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    list_221 := TListImpl.Create({TType.}Struct, Bonk.Count);
    oprot.WriteListBegin( list_221);
    ikn224:=Bonk.Count;
    for ik223:=0 to ikn224 do 
    begin
    _iter222:=Bonk.Items[ik223];
      _iter222.Write(oprot);
    end;
    oprot.WriteListEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TListBonksImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Bonk: ');
    sb.Append(Bonk);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TNestedListsBonkImpl.Create;
begin
  inherited;
end;

destructor TNestedListsBonkImpl.Destroy;
begin
  inherited;
end;

function TNestedListsBonkImpl.GetBonk: IThriftList;
begin
  Result := FBonk;
end;

procedure TNestedListsBonkImpl.SetBonk( const Value: IThriftList);
begin
  F__isset_Bonk := True;
  FBonk := Value;
end;

function TNestedListsBonkImpl.Get__isset_Bonk: Boolean;
begin
  Result := F__isset_Bonk;
end;

procedure TNestedListsBonkImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _list225: IList;
  _i226: Integer;
  _elem227: IThriftList;
  _list228: IList;
  _i229: Integer;
  _elem230: IThriftList;
  _list231: IList;
  _i232: Integer;
  _elem233: IBonk;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}List) then
          begin
            Bonk := TThriftListImpl.Create;
            _list225 := iprot.ReadListBegin();
            for _i226 := 0 to _list225.Count - 1 do
            begin
              _elem227 := TThriftListImpl.Create;
              _list228 := iprot.ReadListBegin();
              for _i229 := 0 to _list228.Count - 1 do
              begin
                _elem230 := TThriftListImpl.Create;
                _list231 := iprot.ReadListBegin();
                for _i232 := 0 to _list231.Count - 1 do
                begin
                  _elem233 := TBonkImpl.Create;
                  _elem233.Read(iprot);
                  _elem230.Add(_elem233);
                end;
                iprot.ReadListEnd();
                _elem227.Add(_elem230);
              end;
              iprot.ReadListEnd();
              Bonk.Add(_elem227);
            end;
            iprot.ReadListEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TNestedListsBonkImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  list_234 : IList;
  ik236:integer;
  ikn237:integer;
  _iter235: IThriftList;
  list_238 : IList;
  ik240:integer;
  ikn241:integer;
  _iter239: IThriftList;
  list_242 : IList;
  ik244:integer;
  ikn245:integer;
  _iter243: IBonk;
begin
  struc := TStructImpl.Create('NestedListsBonk');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Bonk <> nil) and __isset_Bonk then
  begin
    field_.Name := 'bonk';
    field_.Type_  := {TType.}List;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    list_234 := TListImpl.Create({TType.}List, Bonk.Count);
    oprot.WriteListBegin( list_234);
    ikn237:=Bonk.Count;
    for ik236:=0 to ikn237 do 
    begin
    _iter235:=Bonk.Items[ik236];
      list_238 := TListImpl.Create({TType.}List, _iter235.Count);
      oprot.WriteListBegin( list_238);
      ikn241:=_iter235.Count;
      for ik240:=0 to ikn241 do 
      begin
      _iter239:=_iter235.Items[ik240];
        list_242 := TListImpl.Create({TType.}Struct, _iter239.Count);
        oprot.WriteListBegin( list_242);
        ikn245:=_iter239.Count;
        for ik244:=0 to ikn245 do 
        begin
        _iter243:=_iter239.Items[ik244];
          _iter243.Write(oprot);
        end;
        oprot.WriteListEnd();
      end;
      oprot.WriteListEnd();
    end;
    oprot.WriteListEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TNestedListsBonkImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Bonk: ');
    sb.Append(Bonk);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TBoolTestImpl.Create;
begin
  inherited;
  FB := True;
  F__isset_B := True;
  FS := 'true';
  F__isset_S := True;
end;

destructor TBoolTestImpl.Destroy;
begin
  inherited;
end;

function TBoolTestImpl.GetB: Boolean;
begin
  Result := FB;
end;

procedure TBoolTestImpl.SetB( const Value: Boolean);
begin
  F__isset_B := True;
  FB := Value;
end;

function TBoolTestImpl.Get__isset_B: Boolean;
begin
  Result := F__isset_B;
end;

function TBoolTestImpl.GetS: string;
begin
  Result := FS;
end;

procedure TBoolTestImpl.SetS( const Value: string);
begin
  F__isset_S := True;
  FS := Value;
end;

function TBoolTestImpl.Get__isset_S: Boolean;
begin
  Result := F__isset_S;
end;

procedure TBoolTestImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}Bool_) then
          begin
            B := iprot.ReadBool();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = {TType.}String_) then
          begin
            S := iprot.ReadString();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TBoolTestImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('BoolTest');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_B) then
  begin
    field_.Name := 'b';
    field_.Type_  := {TType.}Bool_;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteBool(B);
    oprot.WriteFieldEnd();
  end;
  if (__isset_S) then
  begin
    field_.Name := 's';
    field_.Type_  := {TType.}String_;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    oprot.WriteString(S);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TBoolTestImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('B: ');
    sb.Append(B);
    sb.Append(',S: ');
    sb.Append(S);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TStructAImpl.Create;
begin
  inherited;
end;

destructor TStructAImpl.Destroy;
begin
  inherited;
end;

function TStructAImpl.GetS: string;
begin
  Result := FS;
end;

procedure TStructAImpl.SetS( const Value: string);
begin
  FS := Value;
end;

procedure TStructAImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _req_isset_S : Boolean;

begin
  _req_isset_S := FALSE;
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}String_) then
          begin
            S := iprot.ReadString();
            _req_isset_S := TRUE;
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
  if not _req_isset_S
  then raise TProtocolException.Create( TProtocolException.INVALID_DATA, 'S');
end;

procedure TStructAImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('StructA');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  // required field
  field_.Name := 's';
  field_.Type_  := {TType.}String_;
  field_.ID := 1;
  oprot.WriteFieldBegin(field_);
  oprot.WriteString(S);
  oprot.WriteFieldEnd();
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TStructAImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('S: ');
    sb.Append(S);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TStructBImpl.Create;
begin
  inherited;
end;

destructor TStructBImpl.Destroy;
begin
  inherited;
end;

function TStructBImpl.GetAa: IStructA;
begin
  Result := FAa;
end;

procedure TStructBImpl.SetAa( const Value: IStructA);
begin
  F__isset_Aa := True;
  FAa := Value;
end;

function TStructBImpl.Get__isset_Aa: Boolean;
begin
  Result := F__isset_Aa;
end;

function TStructBImpl.GetAb: IStructA;
begin
  Result := FAb;
end;

procedure TStructBImpl.SetAb( const Value: IStructA);
begin
  FAb := Value;
end;

procedure TStructBImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _req_isset_Ab : Boolean;

begin
  _req_isset_Ab := FALSE;
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            Aa := TStructAImpl.Create;
            Aa.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            Ab := TStructAImpl.Create;
            Ab.Read(iprot);
            _req_isset_Ab := TRUE;
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
  if not _req_isset_Ab
  then raise TProtocolException.Create( TProtocolException.INVALID_DATA, 'Ab');
end;

procedure TStructBImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('StructB');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Aa <> nil) and __isset_Aa then
  begin
    field_.Name := 'aa';
    field_.Type_  := {TType.}Struct;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    Aa.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  if (Ab <> nil) then
  begin
    field_.Name := 'ab';
    field_.Type_  := {TType.}Struct;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    Ab.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TStructBImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Aa: ');
    if (Aa = nil) then sb.Append('<null>') else sb.Append(Aa.ToString());
    sb.Append(',Ab: ');
    if (Ab = nil) then sb.Append('<null>') else sb.Append(Ab.ToString());
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TClient.Create( prot: IProtocol);
begin
  Create( prot, prot );
end;

constructor TThriftTest.TClient.Create( const iprot: IProtocol; const oprot: IProtocol);
begin
  iprot_ := iprot;
  oprot_ := oprot;
end;

procedure TThriftTest.TClient.testVoid();
begin
  send_testVoid();
  recv_testVoid();
end;

procedure TThriftTest.TClient.send_testVoid();
var
  args : ITestVoid_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('testVoid', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TTestVoid_argsImpl.Create();
  args.Write(oprot_);
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

procedure TThriftTest.TClient.recv_testVoid();
var
  msg : IMessage;
  x : TApplicationException;
  ret : ITestVoid_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TTestVoid_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
end;

function TThriftTest.TClient.testString(const thing: string): string;
begin
  send_testString(thing);
  Result := recv_testString();
end;

procedure TThriftTest.TClient.send_testString(const thing: string);
var
  args : ITestString_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('testString', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TTestString_argsImpl.Create();
  args.Thing := thing;
  args.Write(oprot_);
  args.Thing := '';
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TThriftTest.TClient.recv_testString(): string;
var
  msg : IMessage;
  x : TApplicationException;
  ret : ITestString_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TTestString_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'testString failed: unknown result');
end;

function TThriftTest.TClient.testByte(thing: ShortInt): ShortInt;
begin
  send_testByte(thing);
  Result := recv_testByte();
end;

procedure TThriftTest.TClient.send_testByte(thing: ShortInt);
var
  args : ITestByte_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('testByte', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TTestByte_argsImpl.Create();
  args.Thing := thing;
  args.Write(oprot_);
  args.Thing := 0;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TThriftTest.TClient.recv_testByte(): ShortInt;
var
  msg : IMessage;
  x : TApplicationException;
  ret : ITestByte_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TTestByte_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'testByte failed: unknown result');
end;

function TThriftTest.TClient.testI32(thing: Integer): Integer;
begin
  send_testI32(thing);
  Result := recv_testI32();
end;

procedure TThriftTest.TClient.send_testI32(thing: Integer);
var
  args : ITestI32_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('testI32', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TTestI32_argsImpl.Create();
  args.Thing := thing;
  args.Write(oprot_);
  args.Thing := 0;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TThriftTest.TClient.recv_testI32(): Integer;
var
  msg : IMessage;
  x : TApplicationException;
  ret : ITestI32_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TTestI32_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'testI32 failed: unknown result');
end;

function TThriftTest.TClient.testI64(const thing: Int64): Int64;
begin
  send_testI64(thing);
  Result := recv_testI64();
end;

procedure TThriftTest.TClient.send_testI64(const thing: Int64);
var
  args : ITestI64_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('testI64', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TTestI64_argsImpl.Create();
  args.Thing := thing;
  args.Write(oprot_);
  args.Thing := 0;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TThriftTest.TClient.recv_testI64(): Int64;
var
  msg : IMessage;
  x : TApplicationException;
  ret : ITestI64_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TTestI64_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'testI64 failed: unknown result');
end;

function TThriftTest.TClient.testDouble(const thing: Double): Double;
begin
  send_testDouble(thing);
  Result := recv_testDouble();
end;

procedure TThriftTest.TClient.send_testDouble(const thing: Double);
var
  args : ITestDouble_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('testDouble', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TTestDouble_argsImpl.Create();
  args.Thing := thing;
  args.Write(oprot_);
  args.Thing := 0.0;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TThriftTest.TClient.recv_testDouble(): Double;
var
  msg : IMessage;
  x : TApplicationException;
  ret : ITestDouble_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TTestDouble_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'testDouble failed: unknown result');
end;

function TThriftTest.TClient.testStruct(const thing: IXtruct): IXtruct;
begin
  send_testStruct(thing);
  Result := recv_testStruct();
end;

procedure TThriftTest.TClient.send_testStruct(const thing: IXtruct);
var
  args : ITestStruct_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('testStruct', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TTestStruct_argsImpl.Create();
  args.Thing := thing;
  args.Write(oprot_);
  args.Thing := nil;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TThriftTest.TClient.recv_testStruct(): IXtruct;
var
  msg : IMessage;
  x : TApplicationException;
  ret : ITestStruct_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TTestStruct_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    ret.Success := nil;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'testStruct failed: unknown result');
end;

function TThriftTest.TClient.testNest(const thing: IXtruct2): IXtruct2;
begin
  send_testNest(thing);
  Result := recv_testNest();
end;

procedure TThriftTest.TClient.send_testNest(const thing: IXtruct2);
var
  args : ITestNest_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('testNest', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TTestNest_argsImpl.Create();
  args.Thing := thing;
  args.Write(oprot_);
  args.Thing := nil;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TThriftTest.TClient.recv_testNest(): IXtruct2;
var
  msg : IMessage;
  x : TApplicationException;
  ret : ITestNest_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TTestNest_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    ret.Success := nil;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'testNest failed: unknown result');
end;

function TThriftTest.TClient.testMap(const thing: IThriftDictionary): IThriftDictionary;
begin
  send_testMap(thing);
  Result := recv_testMap();
end;

procedure TThriftTest.TClient.send_testMap(const thing: IThriftDictionary);
var
  args : ITestMap_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('testMap', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TTestMap_argsImpl.Create();
  args.Thing := thing;
  args.Write(oprot_);
  args.Thing := nil;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TThriftTest.TClient.recv_testMap(): IThriftDictionary;
var
  msg : IMessage;
  x : TApplicationException;
  ret : ITestMap_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TTestMap_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    ret.Success := nil;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'testMap failed: unknown result');
end;

function TThriftTest.TClient.testStringMap(const thing: IThriftDictionary): IThriftDictionary;
begin
  send_testStringMap(thing);
  Result := recv_testStringMap();
end;

procedure TThriftTest.TClient.send_testStringMap(const thing: IThriftDictionary);
var
  args : ITestStringMap_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('testStringMap', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TTestStringMap_argsImpl.Create();
  args.Thing := thing;
  args.Write(oprot_);
  args.Thing := nil;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TThriftTest.TClient.recv_testStringMap(): IThriftDictionary;
var
  msg : IMessage;
  x : TApplicationException;
  ret : ITestStringMap_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TTestStringMap_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    ret.Success := nil;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'testStringMap failed: unknown result');
end;

function TThriftTest.TClient.testSet(const thing: IHashSet): IHashSet;
begin
  send_testSet(thing);
  Result := recv_testSet();
end;

procedure TThriftTest.TClient.send_testSet(const thing: IHashSet);
var
  args : ITestSet_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('testSet', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TTestSet_argsImpl.Create();
  args.Thing := thing;
  args.Write(oprot_);
  args.Thing := nil;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TThriftTest.TClient.recv_testSet(): IHashSet;
var
  msg : IMessage;
  x : TApplicationException;
  ret : ITestSet_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TTestSet_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    ret.Success := nil;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'testSet failed: unknown result');
end;

function TThriftTest.TClient.testList(const thing: IThriftList): IThriftList;
begin
  send_testList(thing);
  Result := recv_testList();
end;

procedure TThriftTest.TClient.send_testList(const thing: IThriftList);
var
  args : ITestList_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('testList', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TTestList_argsImpl.Create();
  args.Thing := thing;
  args.Write(oprot_);
  args.Thing := nil;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TThriftTest.TClient.recv_testList(): IThriftList;
var
  msg : IMessage;
  x : TApplicationException;
  ret : ITestList_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TTestList_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    ret.Success := nil;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'testList failed: unknown result');
end;

function TThriftTest.TClient.testEnum(thing: TNumberz): TNumberz;
begin
  send_testEnum(thing);
  Result := recv_testEnum();
end;

procedure TThriftTest.TClient.send_testEnum(thing: TNumberz);
var
  args : ITestEnum_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('testEnum', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TTestEnum_argsImpl.Create();
  args.Thing := thing;
  args.Write(oprot_);
  args.Thing := TNumberz(0);
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TThriftTest.TClient.recv_testEnum(): TNumberz;
var
  msg : IMessage;
  x : TApplicationException;
  ret : ITestEnum_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TTestEnum_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'testEnum failed: unknown result');
end;

function TThriftTest.TClient.testTypedef(const thing: TUserId): TUserId;
begin
  send_testTypedef(thing);
  Result := recv_testTypedef();
end;

procedure TThriftTest.TClient.send_testTypedef(const thing: TUserId);
var
  args : ITestTypedef_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('testTypedef', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TTestTypedef_argsImpl.Create();
  args.Thing := thing;
  args.Write(oprot_);
  args.Thing := 0;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TThriftTest.TClient.recv_testTypedef(): TUserId;
var
  msg : IMessage;
  x : TApplicationException;
  ret : ITestTypedef_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TTestTypedef_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'testTypedef failed: unknown result');
end;

function TThriftTest.TClient.testMapMap(hello: Integer): IThriftDictionary;
begin
  send_testMapMap(hello);
  Result := recv_testMapMap();
end;

procedure TThriftTest.TClient.send_testMapMap(hello: Integer);
var
  args : ITestMapMap_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('testMapMap', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TTestMapMap_argsImpl.Create();
  args.Hello := hello;
  args.Write(oprot_);
  args.Hello := 0;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TThriftTest.TClient.recv_testMapMap(): IThriftDictionary;
var
  msg : IMessage;
  x : TApplicationException;
  ret : ITestMapMap_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TTestMapMap_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    ret.Success := nil;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'testMapMap failed: unknown result');
end;

function TThriftTest.TClient.testInsanity(const argument: IInsanity): IThriftDictionary;
begin
  send_testInsanity(argument);
  Result := recv_testInsanity();
end;

procedure TThriftTest.TClient.send_testInsanity(const argument: IInsanity);
var
  args : ITestInsanity_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('testInsanity', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TTestInsanity_argsImpl.Create();
  args.Argument := argument;
  args.Write(oprot_);
  args.Argument := nil;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TThriftTest.TClient.recv_testInsanity(): IThriftDictionary;
var
  msg : IMessage;
  x : TApplicationException;
  ret : ITestInsanity_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TTestInsanity_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    ret.Success := nil;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'testInsanity failed: unknown result');
end;

function TThriftTest.TClient.testMulti(arg0: ShortInt; arg1: Integer; const arg2: Int64; const arg3: IThriftDictionary; arg4: TNumberz; const arg5: TUserId): IXtruct;
begin
  send_testMulti(arg0, arg1, arg2, arg3, arg4, arg5);
  Result := recv_testMulti();
end;

procedure TThriftTest.TClient.send_testMulti(arg0: ShortInt; arg1: Integer; const arg2: Int64; const arg3: IThriftDictionary; arg4: TNumberz; const arg5: TUserId);
var
  args : ITestMulti_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('testMulti', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TTestMulti_argsImpl.Create();
  args.Arg0 := arg0;
  args.Arg1 := arg1;
  args.Arg2 := arg2;
  args.Arg3 := arg3;
  args.Arg4 := arg4;
  args.Arg5 := arg5;
  args.Write(oprot_);
  args.Arg0 := 0;
  args.Arg1 := 0;
  args.Arg2 := 0;
  args.Arg3 := nil;
  args.Arg4 := TNumberz(0);
  args.Arg5 := 0;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TThriftTest.TClient.recv_testMulti(): IXtruct;
var
  msg : IMessage;
  x : TApplicationException;
  ret : ITestMulti_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TTestMulti_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    ret.Success := nil;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'testMulti failed: unknown result');
end;

procedure TThriftTest.TClient.testException(const arg: string);
begin
  send_testException(arg);
  recv_testException();
end;

procedure TThriftTest.TClient.send_testException(const arg: string);
var
  args : ITestException_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('testException', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TTestException_argsImpl.Create();
  args.Arg := arg;
  args.Write(oprot_);
  args.Arg := '';
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

procedure TThriftTest.TClient.recv_testException();
var
  msg : IMessage;
  ex : Sysutils.Exception;
  x : TApplicationException;
  ret : ITestException_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TTestException_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_Err1) then
  begin
    ex := ret.Err1.CreateException;
    raise ex;
  end;
end;

function TThriftTest.TClient.testMultiException(const arg0: string; const arg1: string): IXtruct;
begin
  send_testMultiException(arg0, arg1);
  Result := recv_testMultiException();
end;

procedure TThriftTest.TClient.send_testMultiException(const arg0: string; const arg1: string);
var
  args : ITestMultiException_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('testMultiException', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TTestMultiException_argsImpl.Create();
  args.Arg0 := arg0;
  args.Arg1 := arg1;
  args.Write(oprot_);
  args.Arg0 := '';
  args.Arg1 := '';
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TThriftTest.TClient.recv_testMultiException(): IXtruct;
var
  msg : IMessage;
  ex : Sysutils.Exception;
  x : TApplicationException;
  ret : ITestMultiException_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TTestMultiException_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    ret.Success := nil;
    Exit;
  end;
  if (ret.__isset_Err1) then
  begin
    ex := ret.Err1.CreateException;
    raise ex;
  end;
  if (ret.__isset_Err2) then
  begin
    ex := ret.Err2.CreateException;
    raise ex;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'testMultiException failed: unknown result');
end;

procedure TThriftTest.TClient.testOneway(secondsToSleep: Integer);
begin
  send_testOneway(secondsToSleep);
end;

procedure TThriftTest.TClient.send_testOneway(secondsToSleep: Integer);
var
  args : ITestOneway_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('testOneway', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TTestOneway_argsImpl.Create();
  args.SecondsToSleep := secondsToSleep;
  args.Write(oprot_);
  args.SecondsToSleep := 0;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

constructor TThriftTest.TProcessorImpl.Create( iface_: Iface );
var
tmpmethod:TProcessFunction;
begin
  inherited Create;
  Self.iface_ := iface_;
  processMap_ := TThriftDictionaryImpl{<string, TProcessFunction>}.Create;
  //processMap_.AddOrSetValue( 'testVoid', testVoid_Process);
  tmpmethod:=Self.testVoid_Process;
  processMap_.AddOrSetValue( 'testVoid',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'testString', testString_Process);
  tmpmethod:=Self.testString_Process;
  processMap_.AddOrSetValue( 'testString',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'testByte', testByte_Process);
  tmpmethod:=Self.testByte_Process;
  processMap_.AddOrSetValue( 'testByte',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'testI32', testI32_Process);
  tmpmethod:=Self.testI32_Process;
  processMap_.AddOrSetValue( 'testI32',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'testI64', testI64_Process);
  tmpmethod:=Self.testI64_Process;
  processMap_.AddOrSetValue( 'testI64',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'testDouble', testDouble_Process);
  tmpmethod:=Self.testDouble_Process;
  processMap_.AddOrSetValue( 'testDouble',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'testStruct', testStruct_Process);
  tmpmethod:=Self.testStruct_Process;
  processMap_.AddOrSetValue( 'testStruct',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'testNest', testNest_Process);
  tmpmethod:=Self.testNest_Process;
  processMap_.AddOrSetValue( 'testNest',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'testMap', testMap_Process);
  tmpmethod:=Self.testMap_Process;
  processMap_.AddOrSetValue( 'testMap',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'testStringMap', testStringMap_Process);
  tmpmethod:=Self.testStringMap_Process;
  processMap_.AddOrSetValue( 'testStringMap',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'testSet', testSet_Process);
  tmpmethod:=Self.testSet_Process;
  processMap_.AddOrSetValue( 'testSet',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'testList', testList_Process);
  tmpmethod:=Self.testList_Process;
  processMap_.AddOrSetValue( 'testList',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'testEnum', testEnum_Process);
  tmpmethod:=Self.testEnum_Process;
  processMap_.AddOrSetValue( 'testEnum',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'testTypedef', testTypedef_Process);
  tmpmethod:=Self.testTypedef_Process;
  processMap_.AddOrSetValue( 'testTypedef',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'testMapMap', testMapMap_Process);
  tmpmethod:=Self.testMapMap_Process;
  processMap_.AddOrSetValue( 'testMapMap',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'testInsanity', testInsanity_Process);
  tmpmethod:=Self.testInsanity_Process;
  processMap_.AddOrSetValue( 'testInsanity',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'testMulti', testMulti_Process);
  tmpmethod:=Self.testMulti_Process;
  processMap_.AddOrSetValue( 'testMulti',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'testException', testException_Process);
  tmpmethod:=Self.testException_Process;
  processMap_.AddOrSetValue( 'testException',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'testMultiException', testMultiException_Process);
  tmpmethod:=Self.testMultiException_Process;
  processMap_.AddOrSetValue( 'testMultiException',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'testOneway', testOneway_Process);
  tmpmethod:=Self.testOneway_Process;
  processMap_.AddOrSetValue( 'testOneway',Pointer(@tmpmethod));
end;

destructor TThriftTest.TProcessorImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TProcessorImpl.Process( const iprot: IProtocol; const oprot: IProtocol): Boolean;
var
  msg : IMessage;
  fn : TProcessFunction;
  fnp : Pointer;
  x : TApplicationException;
begin
  try
    msg := iprot.ReadMessageBegin();
    fn := nil;
    if (not processMap_.TryGetValuePointer(msg.Name, fnp))
    or (fnp=nil) then
    begin
      TProtocolUtil.Skip(iprot, {TType.}Struct);
      iprot.ReadMessageEnd();
      x := TApplicationException.Create({TApplicationException.TExceptionType.}UnknownMethod, 'Invalid method name: ''' + msg.Name + '''');
      msg := TMessageImpl.Create(msg.Name, {TMessageType.}Exception_, msg.SeqID);
      oprot.WriteMessageBegin( msg);
      x.Write(oprot);
      oprot.WriteMessageEnd();
      oprot.Transport.Flush();
      Result := True;
      Exit;
    end;
    //fn:=TProcessFunction(fnp);
    PCardinal(@fn):=fnp;
    fn(msg.SeqID, iprot, oprot,iface_);
  except
    Result := False;
    Exit;
  end;
  Result := True;
end;

// both way processor
procedure TThriftTest.TProcessorImpl.testVoid_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ITestVoid_args;
  msg: IMessage;
  ret: ITestVoid_result;
begin
  args := TTestVoid_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TTestVoid_resultImpl.Create;
  miface_.testVoid();
  msg := TMessageImpl.Create('testVoid', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TThriftTest.TProcessorImpl.testString_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ITestString_args;
  msg: IMessage;
  ret: ITestString_result;
begin
  args := TTestString_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TTestString_resultImpl.Create;
  ret.Success := miface_.testString(args.Thing);
  args.Thing := '';
  msg := TMessageImpl.Create('testString', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TThriftTest.TProcessorImpl.testByte_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ITestByte_args;
  msg: IMessage;
  ret: ITestByte_result;
begin
  args := TTestByte_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TTestByte_resultImpl.Create;
  ret.Success := miface_.testByte(args.Thing);
  args.Thing := 0;
  msg := TMessageImpl.Create('testByte', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TThriftTest.TProcessorImpl.testI32_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ITestI32_args;
  msg: IMessage;
  ret: ITestI32_result;
begin
  args := TTestI32_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TTestI32_resultImpl.Create;
  ret.Success := miface_.testI32(args.Thing);
  args.Thing := 0;
  msg := TMessageImpl.Create('testI32', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TThriftTest.TProcessorImpl.testI64_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ITestI64_args;
  msg: IMessage;
  ret: ITestI64_result;
begin
  args := TTestI64_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TTestI64_resultImpl.Create;
  ret.Success := miface_.testI64(args.Thing);
  args.Thing := 0;
  msg := TMessageImpl.Create('testI64', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TThriftTest.TProcessorImpl.testDouble_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ITestDouble_args;
  msg: IMessage;
  ret: ITestDouble_result;
begin
  args := TTestDouble_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TTestDouble_resultImpl.Create;
  ret.Success := miface_.testDouble(args.Thing);
  args.Thing := 0.0;
  msg := TMessageImpl.Create('testDouble', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TThriftTest.TProcessorImpl.testStruct_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ITestStruct_args;
  msg: IMessage;
  ret: ITestStruct_result;
begin
  args := TTestStruct_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TTestStruct_resultImpl.Create;
  ret.Success := miface_.testStruct(args.Thing);
  args.Thing := nil;
  msg := TMessageImpl.Create('testStruct', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TThriftTest.TProcessorImpl.testNest_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ITestNest_args;
  msg: IMessage;
  ret: ITestNest_result;
begin
  args := TTestNest_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TTestNest_resultImpl.Create;
  ret.Success := miface_.testNest(args.Thing);
  args.Thing := nil;
  msg := TMessageImpl.Create('testNest', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TThriftTest.TProcessorImpl.testMap_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ITestMap_args;
  msg: IMessage;
  ret: ITestMap_result;
begin
  args := TTestMap_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TTestMap_resultImpl.Create;
  ret.Success := miface_.testMap(args.Thing);
  args.Thing := nil;
  msg := TMessageImpl.Create('testMap', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TThriftTest.TProcessorImpl.testStringMap_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ITestStringMap_args;
  msg: IMessage;
  ret: ITestStringMap_result;
begin
  args := TTestStringMap_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TTestStringMap_resultImpl.Create;
  ret.Success := miface_.testStringMap(args.Thing);
  args.Thing := nil;
  msg := TMessageImpl.Create('testStringMap', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TThriftTest.TProcessorImpl.testSet_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ITestSet_args;
  msg: IMessage;
  ret: ITestSet_result;
begin
  args := TTestSet_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TTestSet_resultImpl.Create;
  ret.Success := miface_.testSet(args.Thing);
  args.Thing := nil;
  msg := TMessageImpl.Create('testSet', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TThriftTest.TProcessorImpl.testList_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ITestList_args;
  msg: IMessage;
  ret: ITestList_result;
begin
  args := TTestList_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TTestList_resultImpl.Create;
  ret.Success := miface_.testList(args.Thing);
  args.Thing := nil;
  msg := TMessageImpl.Create('testList', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TThriftTest.TProcessorImpl.testEnum_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ITestEnum_args;
  msg: IMessage;
  ret: ITestEnum_result;
begin
  args := TTestEnum_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TTestEnum_resultImpl.Create;
  ret.Success := miface_.testEnum(args.Thing);
  args.Thing := TNumberz(0);
  msg := TMessageImpl.Create('testEnum', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TThriftTest.TProcessorImpl.testTypedef_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ITestTypedef_args;
  msg: IMessage;
  ret: ITestTypedef_result;
begin
  args := TTestTypedef_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TTestTypedef_resultImpl.Create;
  ret.Success := miface_.testTypedef(args.Thing);
  args.Thing := 0;
  msg := TMessageImpl.Create('testTypedef', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TThriftTest.TProcessorImpl.testMapMap_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ITestMapMap_args;
  msg: IMessage;
  ret: ITestMapMap_result;
begin
  args := TTestMapMap_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TTestMapMap_resultImpl.Create;
  ret.Success := miface_.testMapMap(args.Hello);
  args.Hello := 0;
  msg := TMessageImpl.Create('testMapMap', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TThriftTest.TProcessorImpl.testInsanity_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ITestInsanity_args;
  msg: IMessage;
  ret: ITestInsanity_result;
begin
  args := TTestInsanity_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TTestInsanity_resultImpl.Create;
  ret.Success := miface_.testInsanity(args.Argument);
  args.Argument := nil;
  msg := TMessageImpl.Create('testInsanity', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TThriftTest.TProcessorImpl.testMulti_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ITestMulti_args;
  msg: IMessage;
  ret: ITestMulti_result;
begin
  args := TTestMulti_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TTestMulti_resultImpl.Create;
  ret.Success := miface_.testMulti(args.Arg0, args.Arg1, args.Arg2, args.Arg3, args.Arg4, args.Arg5);
  args.Arg0 := 0;
  args.Arg1 := 0;
  args.Arg2 := 0;
  args.Arg3 := nil;
  args.Arg4 := TNumberz(0);
  args.Arg5 := 0;
  msg := TMessageImpl.Create('testMulti', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TThriftTest.TProcessorImpl.testException_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ITestException_args;
  msg: IMessage;
  ret: ITestException_result;
begin
  args := TTestException_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TTestException_resultImpl.Create;
  try
    miface_.testException(args.Arg);
    args.Arg := '';
  except
    on E: TXception do
    begin
      ret.Err1 := E.XceptionFactory;
    end;
  end;
  msg := TMessageImpl.Create('testException', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TThriftTest.TProcessorImpl.testMultiException_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ITestMultiException_args;
  msg: IMessage;
  ret: ITestMultiException_result;
begin
  args := TTestMultiException_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TTestMultiException_resultImpl.Create;
  try
    ret.Success := miface_.testMultiException(args.Arg0, args.Arg1);
    args.Arg0 := '';
    args.Arg1 := '';
  except
    on E: TXception do
    begin
      ret.Err1 := E.XceptionFactory;
    end;
    on E: TXception2 do
    begin
      ret.Err2 := E.Xception2Factory;
    end;
  end;
  msg := TMessageImpl.Create('testMultiException', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// one way processor
procedure TThriftTest.TProcessorImpl.testOneway_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ITestOneway_args;
begin
  args := TTestOneway_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  miface_.testOneway(args.SecondsToSleep);
  args.SecondsToSleep := 0;
end;

constructor TThriftTest.TTestVoid_argsImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestVoid_argsImpl.Destroy;
begin
  inherited;
end;

procedure TThriftTest.TTestVoid_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      TProtocolUtil.Skip(iprot, field_.Type_);
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestVoid_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
begin
  struc := TStructImpl.Create('testVoid_args');
  oprot.WriteStructBegin(struc);
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestVoid_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestVoid_resultImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestVoid_resultImpl.Destroy;
begin
  inherited;
end;

procedure TThriftTest.TTestVoid_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      TProtocolUtil.Skip(iprot, field_.Type_);
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestVoid_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
begin
  struc := TStructImpl.Create('testVoid_result');
  oprot.WriteStructBegin(struc);
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestVoid_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestString_argsImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestString_argsImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestString_argsImpl.GetThing: string;
begin
  Result := FThing;
end;

procedure TThriftTest.TTestString_argsImpl.SetThing( const Value: string);
begin
  F__isset_Thing := True;
  FThing := Value;
end;

function TThriftTest.TTestString_argsImpl.Get__isset_Thing: Boolean;
begin
  Result := F__isset_Thing;
end;

procedure TThriftTest.TTestString_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}String_) then
          begin
            Thing := iprot.ReadString();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestString_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testString_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Thing) then
  begin
    field_.Name := 'thing';
    field_.Type_  := {TType.}String_;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteString(Thing);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestString_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Thing: ');
    sb.Append(Thing);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestString_resultImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestString_resultImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestString_resultImpl.GetSuccess: string;
begin
  Result := FSuccess;
end;

procedure TThriftTest.TTestString_resultImpl.SetSuccess( const Value: string);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TThriftTest.TTestString_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TThriftTest.TTestString_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}String_) then
          begin
            Success := iprot.ReadString();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestString_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testString_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Success) then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}String_;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    oprot.WriteString(Success);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestString_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    sb.Append(Success);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestByte_argsImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestByte_argsImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestByte_argsImpl.GetThing: ShortInt;
begin
  Result := FThing;
end;

procedure TThriftTest.TTestByte_argsImpl.SetThing( const Value: ShortInt);
begin
  F__isset_Thing := True;
  FThing := Value;
end;

function TThriftTest.TTestByte_argsImpl.Get__isset_Thing: Boolean;
begin
  Result := F__isset_Thing;
end;

procedure TThriftTest.TTestByte_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}Byte_) then
          begin
            Thing := iprot.ReadByte();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestByte_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testByte_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Thing) then
  begin
    field_.Name := 'thing';
    field_.Type_  := {TType.}Byte_;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteByte(Thing);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestByte_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Thing: ');
    sb.Append(Thing);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestByte_resultImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestByte_resultImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestByte_resultImpl.GetSuccess: ShortInt;
begin
  Result := FSuccess;
end;

procedure TThriftTest.TTestByte_resultImpl.SetSuccess( const Value: ShortInt);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TThriftTest.TTestByte_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TThriftTest.TTestByte_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}Byte_) then
          begin
            Success := iprot.ReadByte();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestByte_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testByte_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Success) then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}Byte_;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    oprot.WriteByte(Success);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestByte_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    sb.Append(Success);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestI32_argsImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestI32_argsImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestI32_argsImpl.GetThing: Integer;
begin
  Result := FThing;
end;

procedure TThriftTest.TTestI32_argsImpl.SetThing( const Value: Integer);
begin
  F__isset_Thing := True;
  FThing := Value;
end;

function TThriftTest.TTestI32_argsImpl.Get__isset_Thing: Boolean;
begin
  Result := F__isset_Thing;
end;

procedure TThriftTest.TTestI32_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            Thing := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestI32_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testI32_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Thing) then
  begin
    field_.Name := 'thing';
    field_.Type_  := {TType.}I32;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Thing);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestI32_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Thing: ');
    sb.Append(Thing);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestI32_resultImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestI32_resultImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestI32_resultImpl.GetSuccess: Integer;
begin
  Result := FSuccess;
end;

procedure TThriftTest.TTestI32_resultImpl.SetSuccess( const Value: Integer);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TThriftTest.TTestI32_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TThriftTest.TTestI32_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            Success := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestI32_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testI32_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Success) then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}I32;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Success);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestI32_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    sb.Append(Success);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestI64_argsImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestI64_argsImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestI64_argsImpl.GetThing: Int64;
begin
  Result := FThing;
end;

procedure TThriftTest.TTestI64_argsImpl.SetThing( const Value: Int64);
begin
  F__isset_Thing := True;
  FThing := Value;
end;

function TThriftTest.TTestI64_argsImpl.Get__isset_Thing: Boolean;
begin
  Result := F__isset_Thing;
end;

procedure TThriftTest.TTestI64_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}I64) then
          begin
            Thing := iprot.ReadI64();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestI64_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testI64_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Thing) then
  begin
    field_.Name := 'thing';
    field_.Type_  := {TType.}I64;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI64(Thing);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestI64_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Thing: ');
    sb.Append(Thing);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestI64_resultImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestI64_resultImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestI64_resultImpl.GetSuccess: Int64;
begin
  Result := FSuccess;
end;

procedure TThriftTest.TTestI64_resultImpl.SetSuccess( const Value: Int64);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TThriftTest.TTestI64_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TThriftTest.TTestI64_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}I64) then
          begin
            Success := iprot.ReadI64();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestI64_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testI64_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Success) then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}I64;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI64(Success);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestI64_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    sb.Append(Success);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestDouble_argsImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestDouble_argsImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestDouble_argsImpl.GetThing: Double;
begin
  Result := FThing;
end;

procedure TThriftTest.TTestDouble_argsImpl.SetThing( const Value: Double);
begin
  F__isset_Thing := True;
  FThing := Value;
end;

function TThriftTest.TTestDouble_argsImpl.Get__isset_Thing: Boolean;
begin
  Result := F__isset_Thing;
end;

procedure TThriftTest.TTestDouble_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}Double_) then
          begin
            Thing := iprot.ReadDouble();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestDouble_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testDouble_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Thing) then
  begin
    field_.Name := 'thing';
    field_.Type_  := {TType.}Double_;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteDouble(Thing);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestDouble_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Thing: ');
    sb.Append(Thing);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestDouble_resultImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestDouble_resultImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestDouble_resultImpl.GetSuccess: Double;
begin
  Result := FSuccess;
end;

procedure TThriftTest.TTestDouble_resultImpl.SetSuccess( const Value: Double);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TThriftTest.TTestDouble_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TThriftTest.TTestDouble_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}Double_) then
          begin
            Success := iprot.ReadDouble();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestDouble_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testDouble_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Success) then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}Double_;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    oprot.WriteDouble(Success);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestDouble_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    sb.Append(Success);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestStruct_argsImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestStruct_argsImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestStruct_argsImpl.GetThing: IXtruct;
begin
  Result := FThing;
end;

procedure TThriftTest.TTestStruct_argsImpl.SetThing( const Value: IXtruct);
begin
  F__isset_Thing := True;
  FThing := Value;
end;

function TThriftTest.TTestStruct_argsImpl.Get__isset_Thing: Boolean;
begin
  Result := F__isset_Thing;
end;

procedure TThriftTest.TTestStruct_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            Thing := TXtructImpl.Create;
            Thing.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestStruct_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testStruct_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Thing <> nil) and __isset_Thing then
  begin
    field_.Name := 'thing';
    field_.Type_  := {TType.}Struct;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    Thing.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestStruct_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Thing: ');
    if (Thing = nil) then sb.Append('<null>') else sb.Append(Thing.ToString());
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestStruct_resultImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestStruct_resultImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestStruct_resultImpl.GetSuccess: IXtruct;
begin
  Result := FSuccess;
end;

procedure TThriftTest.TTestStruct_resultImpl.SetSuccess( const Value: IXtruct);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TThriftTest.TTestStruct_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TThriftTest.TTestStruct_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            Success := TXtructImpl.Create;
            Success.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestStruct_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testStruct_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Success <> nil) and __isset_Success then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}Struct;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    Success.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestStruct_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    if (Success = nil) then sb.Append('<null>') else sb.Append(Success.ToString());
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestNest_argsImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestNest_argsImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestNest_argsImpl.GetThing: IXtruct2;
begin
  Result := FThing;
end;

procedure TThriftTest.TTestNest_argsImpl.SetThing( const Value: IXtruct2);
begin
  F__isset_Thing := True;
  FThing := Value;
end;

function TThriftTest.TTestNest_argsImpl.Get__isset_Thing: Boolean;
begin
  Result := F__isset_Thing;
end;

procedure TThriftTest.TTestNest_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            Thing := TXtruct2Impl.Create;
            Thing.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestNest_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testNest_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Thing <> nil) and __isset_Thing then
  begin
    field_.Name := 'thing';
    field_.Type_  := {TType.}Struct;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    Thing.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestNest_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Thing: ');
    if (Thing = nil) then sb.Append('<null>') else sb.Append(Thing.ToString());
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestNest_resultImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestNest_resultImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestNest_resultImpl.GetSuccess: IXtruct2;
begin
  Result := FSuccess;
end;

procedure TThriftTest.TTestNest_resultImpl.SetSuccess( const Value: IXtruct2);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TThriftTest.TTestNest_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TThriftTest.TTestNest_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            Success := TXtruct2Impl.Create;
            Success.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestNest_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testNest_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Success <> nil) and __isset_Success then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}Struct;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    Success.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestNest_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    if (Success = nil) then sb.Append('<null>') else sb.Append(Success.ToString());
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestMap_argsImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestMap_argsImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestMap_argsImpl.GetThing: IThriftDictionary;
begin
  Result := FThing;
end;

procedure TThriftTest.TTestMap_argsImpl.SetThing( const Value: IThriftDictionary);
begin
  F__isset_Thing := True;
  FThing := Value;
end;

function TThriftTest.TTestMap_argsImpl.Get__isset_Thing: Boolean;
begin
  Result := F__isset_Thing;
end;

procedure TThriftTest.TTestMap_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _map246: IMap;
  _i247: Integer;
  _key248: Integer;
  _val249: Integer;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}Map) then
          begin
            Thing := TThriftDictionaryImpl.Create;
            _map246 := iprot.ReadMapBegin();
            for _i247 := 0 to _map246.Count - 1 do
            begin
              _key248 := iprot.ReadI32();
              _val249 := iprot.ReadI32();
              Thing.AddOrSetValue( _key248, _val249);
            end;
            iprot.ReadMapEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestMap_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  map250 : IMap;
  ik252:integer;
  ikn253:integer;
  _iter251: Integer;
begin
  struc := TStructImpl.Create('testMap_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Thing <> nil) and __isset_Thing then
  begin
    field_.Name := 'thing';
    field_.Type_  := {TType.}Map;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    map250 := TMapImpl.Create( {TType.}I32, {TType.}I32, Thing.Count);
    oprot.WriteMapBegin( map250);
    ikn253:=Thing.Count;
    for ik252:=0 to ikn253 do 
    begin
    _iter251:=Thing.Keys[ik252];
      oprot.WriteI32(_iter251);
      oprot.WriteI32(Thing[_iter251]);
    end;
    oprot.WriteMapEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestMap_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Thing: ');
    sb.Append(Thing);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestMap_resultImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestMap_resultImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestMap_resultImpl.GetSuccess: IThriftDictionary;
begin
  Result := FSuccess;
end;

procedure TThriftTest.TTestMap_resultImpl.SetSuccess( const Value: IThriftDictionary);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TThriftTest.TTestMap_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TThriftTest.TTestMap_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _map254: IMap;
  _i255: Integer;
  _key256: Integer;
  _val257: Integer;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}Map) then
          begin
            Success := TThriftDictionaryImpl.Create;
            _map254 := iprot.ReadMapBegin();
            for _i255 := 0 to _map254.Count - 1 do
            begin
              _key256 := iprot.ReadI32();
              _val257 := iprot.ReadI32();
              Success.AddOrSetValue( _key256, _val257);
            end;
            iprot.ReadMapEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestMap_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  map258 : IMap;
  ik260:integer;
  ikn261:integer;
  _iter259: Integer;
begin
  struc := TStructImpl.Create('testMap_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Success <> nil) and __isset_Success then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}Map;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    map258 := TMapImpl.Create( {TType.}I32, {TType.}I32, Success.Count);
    oprot.WriteMapBegin( map258);
    ikn261:=Success.Count;
    for ik260:=0 to ikn261 do 
    begin
    _iter259:=Success.Keys[ik260];
      oprot.WriteI32(_iter259);
      oprot.WriteI32(Success[_iter259]);
    end;
    oprot.WriteMapEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestMap_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    sb.Append(Success);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestStringMap_argsImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestStringMap_argsImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestStringMap_argsImpl.GetThing: IThriftDictionary;
begin
  Result := FThing;
end;

procedure TThriftTest.TTestStringMap_argsImpl.SetThing( const Value: IThriftDictionary);
begin
  F__isset_Thing := True;
  FThing := Value;
end;

function TThriftTest.TTestStringMap_argsImpl.Get__isset_Thing: Boolean;
begin
  Result := F__isset_Thing;
end;

procedure TThriftTest.TTestStringMap_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _map262: IMap;
  _i263: Integer;
  _key264: string;
  _val265: string;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}Map) then
          begin
            Thing := TThriftDictionaryImpl.Create;
            _map262 := iprot.ReadMapBegin();
            for _i263 := 0 to _map262.Count - 1 do
            begin
              _key264 := iprot.ReadString();
              _val265 := iprot.ReadString();
              Thing.AddOrSetValue( _key264, _val265);
            end;
            iprot.ReadMapEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestStringMap_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  map266 : IMap;
  ik268:integer;
  ikn269:integer;
  _iter267: string;
begin
  struc := TStructImpl.Create('testStringMap_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Thing <> nil) and __isset_Thing then
  begin
    field_.Name := 'thing';
    field_.Type_  := {TType.}Map;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    map266 := TMapImpl.Create( {TType.}String_, {TType.}String_, Thing.Count);
    oprot.WriteMapBegin( map266);
    ikn269:=Thing.Count;
    for ik268:=0 to ikn269 do 
    begin
    _iter267:=Thing.Keys[ik268];
      oprot.WriteString(_iter267);
      oprot.WriteString(Thing[_iter267]);
    end;
    oprot.WriteMapEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestStringMap_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Thing: ');
    sb.Append(Thing);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestStringMap_resultImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestStringMap_resultImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestStringMap_resultImpl.GetSuccess: IThriftDictionary;
begin
  Result := FSuccess;
end;

procedure TThriftTest.TTestStringMap_resultImpl.SetSuccess( const Value: IThriftDictionary);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TThriftTest.TTestStringMap_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TThriftTest.TTestStringMap_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _map270: IMap;
  _i271: Integer;
  _key272: string;
  _val273: string;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}Map) then
          begin
            Success := TThriftDictionaryImpl.Create;
            _map270 := iprot.ReadMapBegin();
            for _i271 := 0 to _map270.Count - 1 do
            begin
              _key272 := iprot.ReadString();
              _val273 := iprot.ReadString();
              Success.AddOrSetValue( _key272, _val273);
            end;
            iprot.ReadMapEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestStringMap_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  map274 : IMap;
  ik276:integer;
  ikn277:integer;
  _iter275: string;
begin
  struc := TStructImpl.Create('testStringMap_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Success <> nil) and __isset_Success then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}Map;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    map274 := TMapImpl.Create( {TType.}String_, {TType.}String_, Success.Count);
    oprot.WriteMapBegin( map274);
    ikn277:=Success.Count;
    for ik276:=0 to ikn277 do 
    begin
    _iter275:=Success.Keys[ik276];
      oprot.WriteString(_iter275);
      oprot.WriteString(Success[_iter275]);
    end;
    oprot.WriteMapEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestStringMap_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    sb.Append(Success);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestSet_argsImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestSet_argsImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestSet_argsImpl.GetThing: IHashSet;
begin
  Result := FThing;
end;

procedure TThriftTest.TTestSet_argsImpl.SetThing( const Value: IHashSet);
begin
  F__isset_Thing := True;
  FThing := Value;
end;

function TThriftTest.TTestSet_argsImpl.Get__isset_Thing: Boolean;
begin
  Result := F__isset_Thing;
end;

procedure TThriftTest.TTestSet_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _set278: ISet;
  _i279: Integer;
  _elem280: Integer;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}Set_) then
          begin
            Thing := THashSetImpl.Create;
            _set278 := iprot.ReadSetBegin();
            for _i279 := 0 to _set278.Count - 1 do
            begin
              _elem280 := iprot.ReadI32();
              Thing.Add(_elem280);
            end;
            iprot.ReadSetEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestSet_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  set_281 : ISet;
  ik283:integer;
  ikn284:integer;
  _iter282: Integer;
begin
  struc := TStructImpl.Create('testSet_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Thing <> nil) and __isset_Thing then
  begin
    field_.Name := 'thing';
    field_.Type_  := {TType.}Set_;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    set_281 := TSetImpl.Create({TType.}I32, Thing.Count);
    oprot.WriteSetBegin( set_281);
    ikn284:=Thing.Count;
    for ik283:=0 to ikn284 do 
    begin
    _iter282:=Thing.Items[ik283];
      oprot.WriteI32(_iter282);
    end;
    oprot.WriteSetEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestSet_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Thing: ');
    sb.Append(Thing);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestSet_resultImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestSet_resultImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestSet_resultImpl.GetSuccess: IHashSet;
begin
  Result := FSuccess;
end;

procedure TThriftTest.TTestSet_resultImpl.SetSuccess( const Value: IHashSet);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TThriftTest.TTestSet_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TThriftTest.TTestSet_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _set285: ISet;
  _i286: Integer;
  _elem287: Integer;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}Set_) then
          begin
            Success := THashSetImpl.Create;
            _set285 := iprot.ReadSetBegin();
            for _i286 := 0 to _set285.Count - 1 do
            begin
              _elem287 := iprot.ReadI32();
              Success.Add(_elem287);
            end;
            iprot.ReadSetEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestSet_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  set_288 : ISet;
  ik290:integer;
  ikn291:integer;
  _iter289: Integer;
begin
  struc := TStructImpl.Create('testSet_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Success <> nil) and __isset_Success then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}Set_;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    set_288 := TSetImpl.Create({TType.}I32, Success.Count);
    oprot.WriteSetBegin( set_288);
    ikn291:=Success.Count;
    for ik290:=0 to ikn291 do 
    begin
    _iter289:=Success.Items[ik290];
      oprot.WriteI32(_iter289);
    end;
    oprot.WriteSetEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestSet_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    sb.Append(Success);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestList_argsImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestList_argsImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestList_argsImpl.GetThing: IThriftList;
begin
  Result := FThing;
end;

procedure TThriftTest.TTestList_argsImpl.SetThing( const Value: IThriftList);
begin
  F__isset_Thing := True;
  FThing := Value;
end;

function TThriftTest.TTestList_argsImpl.Get__isset_Thing: Boolean;
begin
  Result := F__isset_Thing;
end;

procedure TThriftTest.TTestList_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _list292: IList;
  _i293: Integer;
  _elem294: Integer;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}List) then
          begin
            Thing := TThriftListImpl.Create;
            _list292 := iprot.ReadListBegin();
            for _i293 := 0 to _list292.Count - 1 do
            begin
              _elem294 := iprot.ReadI32();
              Thing.Add(_elem294);
            end;
            iprot.ReadListEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestList_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  list_295 : IList;
  ik297:integer;
  ikn298:integer;
  _iter296: Integer;
begin
  struc := TStructImpl.Create('testList_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Thing <> nil) and __isset_Thing then
  begin
    field_.Name := 'thing';
    field_.Type_  := {TType.}List;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    list_295 := TListImpl.Create({TType.}I32, Thing.Count);
    oprot.WriteListBegin( list_295);
    ikn298:=Thing.Count;
    for ik297:=0 to ikn298 do 
    begin
    _iter296:=Thing.Items[ik297];
      oprot.WriteI32(_iter296);
    end;
    oprot.WriteListEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestList_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Thing: ');
    sb.Append(Thing);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestList_resultImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestList_resultImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestList_resultImpl.GetSuccess: IThriftList;
begin
  Result := FSuccess;
end;

procedure TThriftTest.TTestList_resultImpl.SetSuccess( const Value: IThriftList);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TThriftTest.TTestList_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TThriftTest.TTestList_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _list299: IList;
  _i300: Integer;
  _elem301: Integer;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}List) then
          begin
            Success := TThriftListImpl.Create;
            _list299 := iprot.ReadListBegin();
            for _i300 := 0 to _list299.Count - 1 do
            begin
              _elem301 := iprot.ReadI32();
              Success.Add(_elem301);
            end;
            iprot.ReadListEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestList_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  list_302 : IList;
  ik304:integer;
  ikn305:integer;
  _iter303: Integer;
begin
  struc := TStructImpl.Create('testList_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Success <> nil) and __isset_Success then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}List;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    list_302 := TListImpl.Create({TType.}I32, Success.Count);
    oprot.WriteListBegin( list_302);
    ikn305:=Success.Count;
    for ik304:=0 to ikn305 do 
    begin
    _iter303:=Success.Items[ik304];
      oprot.WriteI32(_iter303);
    end;
    oprot.WriteListEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestList_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    sb.Append(Success);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestEnum_argsImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestEnum_argsImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestEnum_argsImpl.GetThing: TNumberz;
begin
  Result := FThing;
end;

procedure TThriftTest.TTestEnum_argsImpl.SetThing( const Value: TNumberz);
begin
  F__isset_Thing := True;
  FThing := Value;
end;

function TThriftTest.TTestEnum_argsImpl.Get__isset_Thing: Boolean;
begin
  Result := F__isset_Thing;
end;

procedure TThriftTest.TTestEnum_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            Thing := TNumberz(iprot.ReadI32());
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestEnum_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testEnum_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Thing) then
  begin
    field_.Name := 'thing';
    field_.Type_  := {TType.}I32;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Integer(Thing));
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestEnum_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Thing: ');
    sb.Append(Integer(Thing));
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestEnum_resultImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestEnum_resultImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestEnum_resultImpl.GetSuccess: TNumberz;
begin
  Result := FSuccess;
end;

procedure TThriftTest.TTestEnum_resultImpl.SetSuccess( const Value: TNumberz);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TThriftTest.TTestEnum_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TThriftTest.TTestEnum_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            Success := TNumberz(iprot.ReadI32());
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestEnum_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testEnum_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Success) then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}I32;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Integer(Success));
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestEnum_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    sb.Append(Integer(Success));
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestTypedef_argsImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestTypedef_argsImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestTypedef_argsImpl.GetThing: TUserId;
begin
  Result := FThing;
end;

procedure TThriftTest.TTestTypedef_argsImpl.SetThing( const Value: TUserId);
begin
  F__isset_Thing := True;
  FThing := Value;
end;

function TThriftTest.TTestTypedef_argsImpl.Get__isset_Thing: Boolean;
begin
  Result := F__isset_Thing;
end;

procedure TThriftTest.TTestTypedef_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}I64) then
          begin
            Thing := iprot.ReadI64();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestTypedef_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testTypedef_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Thing) then
  begin
    field_.Name := 'thing';
    field_.Type_  := {TType.}I64;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI64(Thing);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestTypedef_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Thing: ');
    sb.Append(Thing);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestTypedef_resultImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestTypedef_resultImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestTypedef_resultImpl.GetSuccess: TUserId;
begin
  Result := FSuccess;
end;

procedure TThriftTest.TTestTypedef_resultImpl.SetSuccess( const Value: TUserId);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TThriftTest.TTestTypedef_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TThriftTest.TTestTypedef_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}I64) then
          begin
            Success := iprot.ReadI64();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestTypedef_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testTypedef_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Success) then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}I64;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI64(Success);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestTypedef_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    sb.Append(Success);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestMapMap_argsImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestMapMap_argsImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestMapMap_argsImpl.GetHello: Integer;
begin
  Result := FHello;
end;

procedure TThriftTest.TTestMapMap_argsImpl.SetHello( const Value: Integer);
begin
  F__isset_Hello := True;
  FHello := Value;
end;

function TThriftTest.TTestMapMap_argsImpl.Get__isset_Hello: Boolean;
begin
  Result := F__isset_Hello;
end;

procedure TThriftTest.TTestMapMap_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            Hello := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestMapMap_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testMapMap_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Hello) then
  begin
    field_.Name := 'hello';
    field_.Type_  := {TType.}I32;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Hello);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestMapMap_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Hello: ');
    sb.Append(Hello);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestMapMap_resultImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestMapMap_resultImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestMapMap_resultImpl.GetSuccess: IThriftDictionary;
begin
  Result := FSuccess;
end;

procedure TThriftTest.TTestMapMap_resultImpl.SetSuccess( const Value: IThriftDictionary);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TThriftTest.TTestMapMap_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TThriftTest.TTestMapMap_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _map306: IMap;
  _i307: Integer;
  _key308: Integer;
  _val309: IThriftDictionary;
  _map310: IMap;
  _i311: Integer;
  _key312: Integer;
  _val313: Integer;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}Map) then
          begin
            Success := TThriftDictionaryImpl.Create;
            _map306 := iprot.ReadMapBegin();
            for _i307 := 0 to _map306.Count - 1 do
            begin
              _key308 := iprot.ReadI32();
              _val309 := TThriftDictionaryImpl.Create;
              _map310 := iprot.ReadMapBegin();
              for _i311 := 0 to _map310.Count - 1 do
              begin
                _key312 := iprot.ReadI32();
                _val313 := iprot.ReadI32();
                _val309.AddOrSetValue( _key312, _val313);
              end;
              iprot.ReadMapEnd();
              Success.AddOrSetValue( _key308, _val309);
            end;
            iprot.ReadMapEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestMapMap_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  map314 : IMap;
  ik316:integer;
  ikn317:integer;
  _iter315: Integer;
  map318 : IMap;
  ik320:integer;
  ikn321:integer;
  _iter319: Integer;
begin
  struc := TStructImpl.Create('testMapMap_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Success <> nil) and __isset_Success then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}Map;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    map314 := TMapImpl.Create( {TType.}I32, {TType.}Map, Success.Count);
    oprot.WriteMapBegin( map314);
    ikn317:=Success.Count;
    for ik316:=0 to ikn317 do 
    begin
    _iter315:=Success.Keys[ik316];
      oprot.WriteI32(_iter315);
      map318 := TMapImpl.Create( {TType.}I32, {TType.}I32, Success[_iter315].Count);
      oprot.WriteMapBegin( map318);
      ikn321:=Success[_iter315].Count;
      for ik320:=0 to ikn321 do 
      begin
      _iter319:=Success[_iter315].Keys[ik320];
        oprot.WriteI32(_iter319);
        oprot.WriteI32(Success[_iter315][_iter319]);
      end;
      oprot.WriteMapEnd();
    end;
    oprot.WriteMapEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestMapMap_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    sb.Append(Success);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestInsanity_argsImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestInsanity_argsImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestInsanity_argsImpl.GetArgument: IInsanity;
begin
  Result := FArgument;
end;

procedure TThriftTest.TTestInsanity_argsImpl.SetArgument( const Value: IInsanity);
begin
  F__isset_Argument := True;
  FArgument := Value;
end;

function TThriftTest.TTestInsanity_argsImpl.Get__isset_Argument: Boolean;
begin
  Result := F__isset_Argument;
end;

procedure TThriftTest.TTestInsanity_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            Argument := TInsanityImpl.Create;
            Argument.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestInsanity_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testInsanity_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Argument <> nil) and __isset_Argument then
  begin
    field_.Name := 'argument';
    field_.Type_  := {TType.}Struct;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    Argument.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestInsanity_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Argument: ');
    if (Argument = nil) then sb.Append('<null>') else sb.Append(Argument.ToString());
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestInsanity_resultImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestInsanity_resultImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestInsanity_resultImpl.GetSuccess: IThriftDictionary;
begin
  Result := FSuccess;
end;

procedure TThriftTest.TTestInsanity_resultImpl.SetSuccess( const Value: IThriftDictionary);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TThriftTest.TTestInsanity_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TThriftTest.TTestInsanity_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _map322: IMap;
  _i323: Integer;
  _key324: TUserId;
  _val325: IThriftDictionary;
  _map326: IMap;
  _i327: Integer;
  _key328: TNumberz;
  _val329: IInsanity;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}Map) then
          begin
            Success := TThriftDictionaryImpl.Create;
            _map322 := iprot.ReadMapBegin();
            for _i323 := 0 to _map322.Count - 1 do
            begin
              _key324 := iprot.ReadI64();
              _val325 := TThriftDictionaryImpl.Create;
              _map326 := iprot.ReadMapBegin();
              for _i327 := 0 to _map326.Count - 1 do
              begin
                _key328 := TNumberz(iprot.ReadI32());
                _val329 := TInsanityImpl.Create;
                _val329.Read(iprot);
                _val325.AddOrSetValue( _key328, _val329);
              end;
              iprot.ReadMapEnd();
              Success.AddOrSetValue( _key324, _val325);
            end;
            iprot.ReadMapEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestInsanity_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  map330 : IMap;
  ik332:integer;
  ikn333:integer;
  _iter331: TUserId;
  map334 : IMap;
  ik336:integer;
  ikn337:integer;
  _iter335: TNumberz;
begin
  struc := TStructImpl.Create('testInsanity_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Success <> nil) and __isset_Success then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}Map;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    map330 := TMapImpl.Create( {TType.}I64, {TType.}Map, Success.Count);
    oprot.WriteMapBegin( map330);
    ikn333:=Success.Count;
    for ik332:=0 to ikn333 do 
    begin
    _iter331:=Success.Keys[ik332];
      oprot.WriteI64(_iter331);
      map334 := TMapImpl.Create( {TType.}I32, {TType.}Struct, Success[_iter331].Count);
      oprot.WriteMapBegin( map334);
      ikn337:=Success[_iter331].Count;
      for ik336:=0 to ikn337 do 
      begin
      _iter335:=Success[_iter331].Keys[ik336];
        oprot.WriteI32(Integer(_iter335));
        Success[_iter331][_iter335].Write(oprot);
      end;
      oprot.WriteMapEnd();
    end;
    oprot.WriteMapEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestInsanity_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    sb.Append(Success);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestMulti_argsImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestMulti_argsImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestMulti_argsImpl.GetArg0: ShortInt;
begin
  Result := FArg0;
end;

procedure TThriftTest.TTestMulti_argsImpl.SetArg0( const Value: ShortInt);
begin
  F__isset_Arg0 := True;
  FArg0 := Value;
end;

function TThriftTest.TTestMulti_argsImpl.Get__isset_Arg0: Boolean;
begin
  Result := F__isset_Arg0;
end;

function TThriftTest.TTestMulti_argsImpl.GetArg1: Integer;
begin
  Result := FArg1;
end;

procedure TThriftTest.TTestMulti_argsImpl.SetArg1( const Value: Integer);
begin
  F__isset_Arg1 := True;
  FArg1 := Value;
end;

function TThriftTest.TTestMulti_argsImpl.Get__isset_Arg1: Boolean;
begin
  Result := F__isset_Arg1;
end;

function TThriftTest.TTestMulti_argsImpl.GetArg2: Int64;
begin
  Result := FArg2;
end;

procedure TThriftTest.TTestMulti_argsImpl.SetArg2( const Value: Int64);
begin
  F__isset_Arg2 := True;
  FArg2 := Value;
end;

function TThriftTest.TTestMulti_argsImpl.Get__isset_Arg2: Boolean;
begin
  Result := F__isset_Arg2;
end;

function TThriftTest.TTestMulti_argsImpl.GetArg3: IThriftDictionary;
begin
  Result := FArg3;
end;

procedure TThriftTest.TTestMulti_argsImpl.SetArg3( const Value: IThriftDictionary);
begin
  F__isset_Arg3 := True;
  FArg3 := Value;
end;

function TThriftTest.TTestMulti_argsImpl.Get__isset_Arg3: Boolean;
begin
  Result := F__isset_Arg3;
end;

function TThriftTest.TTestMulti_argsImpl.GetArg4: TNumberz;
begin
  Result := FArg4;
end;

procedure TThriftTest.TTestMulti_argsImpl.SetArg4( const Value: TNumberz);
begin
  F__isset_Arg4 := True;
  FArg4 := Value;
end;

function TThriftTest.TTestMulti_argsImpl.Get__isset_Arg4: Boolean;
begin
  Result := F__isset_Arg4;
end;

function TThriftTest.TTestMulti_argsImpl.GetArg5: TUserId;
begin
  Result := FArg5;
end;

procedure TThriftTest.TTestMulti_argsImpl.SetArg5( const Value: TUserId);
begin
  F__isset_Arg5 := True;
  FArg5 := Value;
end;

function TThriftTest.TTestMulti_argsImpl.Get__isset_Arg5: Boolean;
begin
  Result := F__isset_Arg5;
end;

procedure TThriftTest.TTestMulti_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _map338: IMap;
  _i339: Integer;
  _key340: SmallInt;
  _val341: string;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}Byte_) then
          begin
            Arg0 := iprot.ReadByte();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            Arg1 := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        3: begin
          if (field_.Type_ = {TType.}I64) then
          begin
            Arg2 := iprot.ReadI64();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        4: begin
          if (field_.Type_ = {TType.}Map) then
          begin
            Arg3 := TThriftDictionaryImpl.Create;
            _map338 := iprot.ReadMapBegin();
            for _i339 := 0 to _map338.Count - 1 do
            begin
              _key340 := iprot.ReadI16();
              _val341 := iprot.ReadString();
              Arg3.AddOrSetValue( _key340, _val341);
            end;
            iprot.ReadMapEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        5: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            Arg4 := TNumberz(iprot.ReadI32());
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        6: begin
          if (field_.Type_ = {TType.}I64) then
          begin
            Arg5 := iprot.ReadI64();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestMulti_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  map342 : IMap;
  ik344:integer;
  ikn345:integer;
  _iter343: SmallInt;
begin
  struc := TStructImpl.Create('testMulti_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Arg0) then
  begin
    field_.Name := 'arg0';
    field_.Type_  := {TType.}Byte_;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteByte(Arg0);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Arg1) then
  begin
    field_.Name := 'arg1';
    field_.Type_  := {TType.}I32;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Arg1);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Arg2) then
  begin
    field_.Name := 'arg2';
    field_.Type_  := {TType.}I64;
    field_.ID := 3;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI64(Arg2);
    oprot.WriteFieldEnd();
  end;
  if (Arg3 <> nil) and __isset_Arg3 then
  begin
    field_.Name := 'arg3';
    field_.Type_  := {TType.}Map;
    field_.ID := 4;
    oprot.WriteFieldBegin(field_);
    map342 := TMapImpl.Create( {TType.}I16, {TType.}String_, Arg3.Count);
    oprot.WriteMapBegin( map342);
    ikn345:=Arg3.Count;
    for ik344:=0 to ikn345 do 
    begin
    _iter343:=Arg3.Keys[ik344];
      oprot.WriteI16(_iter343);
      oprot.WriteString(Arg3[_iter343]);
    end;
    oprot.WriteMapEnd();
    oprot.WriteFieldEnd();
  end;
  if (__isset_Arg4) then
  begin
    field_.Name := 'arg4';
    field_.Type_  := {TType.}I32;
    field_.ID := 5;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Integer(Arg4));
    oprot.WriteFieldEnd();
  end;
  if (__isset_Arg5) then
  begin
    field_.Name := 'arg5';
    field_.Type_  := {TType.}I64;
    field_.ID := 6;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI64(Arg5);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestMulti_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Arg0: ');
    sb.Append(Arg0);
    sb.Append(',Arg1: ');
    sb.Append(Arg1);
    sb.Append(',Arg2: ');
    sb.Append(Arg2);
    sb.Append(',Arg3: ');
    sb.Append(Arg3);
    sb.Append(',Arg4: ');
    sb.Append(Integer(Arg4));
    sb.Append(',Arg5: ');
    sb.Append(Arg5);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestMulti_resultImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestMulti_resultImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestMulti_resultImpl.GetSuccess: IXtruct;
begin
  Result := FSuccess;
end;

procedure TThriftTest.TTestMulti_resultImpl.SetSuccess( const Value: IXtruct);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TThriftTest.TTestMulti_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TThriftTest.TTestMulti_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            Success := TXtructImpl.Create;
            Success.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestMulti_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testMulti_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Success <> nil) and __isset_Success then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}Struct;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    Success.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestMulti_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    if (Success = nil) then sb.Append('<null>') else sb.Append(Success.ToString());
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestException_argsImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestException_argsImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestException_argsImpl.GetArg: string;
begin
  Result := FArg;
end;

procedure TThriftTest.TTestException_argsImpl.SetArg( const Value: string);
begin
  F__isset_Arg := True;
  FArg := Value;
end;

function TThriftTest.TTestException_argsImpl.Get__isset_Arg: Boolean;
begin
  Result := F__isset_Arg;
end;

procedure TThriftTest.TTestException_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}String_) then
          begin
            Arg := iprot.ReadString();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestException_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testException_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Arg) then
  begin
    field_.Name := 'arg';
    field_.Type_  := {TType.}String_;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteString(Arg);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestException_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Arg: ');
    sb.Append(Arg);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestException_resultImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestException_resultImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestException_resultImpl.GetErr1: TXception.IXceptionFactory;
begin
  Result := FErr1;
end;

procedure TThriftTest.TTestException_resultImpl.SetErr1( const Value: TXception.IXceptionFactory);
begin
  F__isset_Err1 := True;
  FErr1 := Value;
end;

function TThriftTest.TTestException_resultImpl.Get__isset_Err1: Boolean;
begin
  Result := F__isset_Err1;
end;

procedure TThriftTest.TTestException_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            Err1 := TXception.TXceptionFactoryImpl.Create;
            Err1.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestException_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testException_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Err1 <> nil) and __isset_Err1 then
  begin
    field_.Name := 'err1';
    field_.Type_  := {TType.}Struct;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    Err1.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestException_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Err1: ');
    if (Err1 = nil) then sb.Append('<null>') else sb.Append(Err1.ToString());
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestMultiException_argsImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestMultiException_argsImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestMultiException_argsImpl.GetArg0: string;
begin
  Result := FArg0;
end;

procedure TThriftTest.TTestMultiException_argsImpl.SetArg0( const Value: string);
begin
  F__isset_Arg0 := True;
  FArg0 := Value;
end;

function TThriftTest.TTestMultiException_argsImpl.Get__isset_Arg0: Boolean;
begin
  Result := F__isset_Arg0;
end;

function TThriftTest.TTestMultiException_argsImpl.GetArg1: string;
begin
  Result := FArg1;
end;

procedure TThriftTest.TTestMultiException_argsImpl.SetArg1( const Value: string);
begin
  F__isset_Arg1 := True;
  FArg1 := Value;
end;

function TThriftTest.TTestMultiException_argsImpl.Get__isset_Arg1: Boolean;
begin
  Result := F__isset_Arg1;
end;

procedure TThriftTest.TTestMultiException_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}String_) then
          begin
            Arg0 := iprot.ReadString();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = {TType.}String_) then
          begin
            Arg1 := iprot.ReadString();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestMultiException_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testMultiException_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Arg0) then
  begin
    field_.Name := 'arg0';
    field_.Type_  := {TType.}String_;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteString(Arg0);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Arg1) then
  begin
    field_.Name := 'arg1';
    field_.Type_  := {TType.}String_;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    oprot.WriteString(Arg1);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestMultiException_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Arg0: ');
    sb.Append(Arg0);
    sb.Append(',Arg1: ');
    sb.Append(Arg1);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestMultiException_resultImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestMultiException_resultImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestMultiException_resultImpl.GetSuccess: IXtruct;
begin
  Result := FSuccess;
end;

procedure TThriftTest.TTestMultiException_resultImpl.SetSuccess( const Value: IXtruct);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TThriftTest.TTestMultiException_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

function TThriftTest.TTestMultiException_resultImpl.GetErr1: TXception.IXceptionFactory;
begin
  Result := FErr1;
end;

procedure TThriftTest.TTestMultiException_resultImpl.SetErr1( const Value: TXception.IXceptionFactory);
begin
  F__isset_Err1 := True;
  FErr1 := Value;
end;

function TThriftTest.TTestMultiException_resultImpl.Get__isset_Err1: Boolean;
begin
  Result := F__isset_Err1;
end;

function TThriftTest.TTestMultiException_resultImpl.GetErr2: TXception2.IXception2Factory;
begin
  Result := FErr2;
end;

procedure TThriftTest.TTestMultiException_resultImpl.SetErr2( const Value: TXception2.IXception2Factory);
begin
  F__isset_Err2 := True;
  FErr2 := Value;
end;

function TThriftTest.TTestMultiException_resultImpl.Get__isset_Err2: Boolean;
begin
  Result := F__isset_Err2;
end;

procedure TThriftTest.TTestMultiException_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            Success := TXtructImpl.Create;
            Success.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        1: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            Err1 := TXception.TXceptionFactoryImpl.Create;
            Err1.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            Err2 := TXception2.TXception2FactoryImpl.Create;
            Err2.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestMultiException_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testMultiException_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Success <> nil) and __isset_Success then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}Struct;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    Success.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  if (Err1 <> nil) and __isset_Err1 then
  begin
    field_.Name := 'err1';
    field_.Type_  := {TType.}Struct;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    Err1.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  if (Err2 <> nil) and __isset_Err2 then
  begin
    field_.Name := 'err2';
    field_.Type_  := {TType.}Struct;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    Err2.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestMultiException_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    if (Success = nil) then sb.Append('<null>') else sb.Append(Success.ToString());
    sb.Append(',Err1: ');
    if (Err1 = nil) then sb.Append('<null>') else sb.Append(Err1.ToString());
    sb.Append(',Err2: ');
    if (Err2 = nil) then sb.Append('<null>') else sb.Append(Err2.ToString());
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestOneway_argsImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestOneway_argsImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestOneway_argsImpl.GetSecondsToSleep: Integer;
begin
  Result := FSecondsToSleep;
end;

procedure TThriftTest.TTestOneway_argsImpl.SetSecondsToSleep( const Value: Integer);
begin
  F__isset_SecondsToSleep := True;
  FSecondsToSleep := Value;
end;

function TThriftTest.TTestOneway_argsImpl.Get__isset_SecondsToSleep: Boolean;
begin
  Result := F__isset_SecondsToSleep;
end;

procedure TThriftTest.TTestOneway_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            SecondsToSleep := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestOneway_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testOneway_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_SecondsToSleep) then
  begin
    field_.Name := 'secondsToSleep';
    field_.Type_  := {TType.}I32;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(SecondsToSleep);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestOneway_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('SecondsToSleep: ');
    sb.Append(SecondsToSleep);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TSecondService.TClient.Create( prot: IProtocol);
begin
  Create( prot, prot );
end;

constructor TSecondService.TClient.Create( const iprot: IProtocol; const oprot: IProtocol);
begin
  iprot_ := iprot;
  oprot_ := oprot;
end;

procedure TSecondService.TClient.blahBlah();
begin
  send_blahBlah();
  recv_blahBlah();
end;

procedure TSecondService.TClient.send_blahBlah();
var
  args : IBlahBlah_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('blahBlah', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TBlahBlah_argsImpl.Create();
  args.Write(oprot_);
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

procedure TSecondService.TClient.recv_blahBlah();
var
  msg : IMessage;
  x : TApplicationException;
  ret : IBlahBlah_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TBlahBlah_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
end;

constructor TSecondService.TProcessorImpl.Create( iface_: Iface );
var
tmpmethod:TProcessFunction;
begin
  inherited Create;
  Self.iface_ := iface_;
  processMap_ := TThriftDictionaryImpl{<string, TProcessFunction>}.Create;
  //processMap_.AddOrSetValue( 'blahBlah', blahBlah_Process);
  tmpmethod:=Self.blahBlah_Process;
  processMap_.AddOrSetValue( 'blahBlah',Pointer(@tmpmethod));
end;

destructor TSecondService.TProcessorImpl.Destroy;
begin
  inherited;
end;

function TSecondService.TProcessorImpl.Process( const iprot: IProtocol; const oprot: IProtocol): Boolean;
var
  msg : IMessage;
  fn : TProcessFunction;
  fnp : Pointer;
  x : TApplicationException;
begin
  try
    msg := iprot.ReadMessageBegin();
    fn := nil;
    if (not processMap_.TryGetValuePointer(msg.Name, fnp))
    or (fnp=nil) then
    begin
      TProtocolUtil.Skip(iprot, {TType.}Struct);
      iprot.ReadMessageEnd();
      x := TApplicationException.Create({TApplicationException.TExceptionType.}UnknownMethod, 'Invalid method name: ''' + msg.Name + '''');
      msg := TMessageImpl.Create(msg.Name, {TMessageType.}Exception_, msg.SeqID);
      oprot.WriteMessageBegin( msg);
      x.Write(oprot);
      oprot.WriteMessageEnd();
      oprot.Transport.Flush();
      Result := True;
      Exit;
    end;
    //fn:=TProcessFunction(fnp);
    PCardinal(@fn):=fnp;
    fn(msg.SeqID, iprot, oprot,iface_);
  except
    Result := False;
    Exit;
  end;
  Result := True;
end;

// both way processor
procedure TSecondService.TProcessorImpl.blahBlah_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: IBlahBlah_args;
  msg: IMessage;
  ret: IBlahBlah_result;
begin
  args := TBlahBlah_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TBlahBlah_resultImpl.Create;
  miface_.blahBlah();
  msg := TMessageImpl.Create('blahBlah', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

constructor TSecondService.TBlahBlah_argsImpl.Create;
begin
  inherited;
end;

destructor TSecondService.TBlahBlah_argsImpl.Destroy;
begin
  inherited;
end;

procedure TSecondService.TBlahBlah_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      TProtocolUtil.Skip(iprot, field_.Type_);
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TSecondService.TBlahBlah_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
begin
  struc := TStructImpl.Create('blahBlah_args');
  oprot.WriteStructBegin(struc);
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TSecondService.TBlahBlah_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TSecondService.TBlahBlah_resultImpl.Create;
begin
  inherited;
end;

destructor TSecondService.TBlahBlah_resultImpl.Destroy;
begin
  inherited;
end;

procedure TSecondService.TBlahBlah_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      TProtocolUtil.Skip(iprot, field_.Type_);
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TSecondService.TBlahBlah_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
begin
  struc := TStructImpl.Create('blahBlah_result');
  oprot.WriteStructBegin(struc);
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TSecondService.TBlahBlah_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

//{$IF CompilerVersion >= 21.0}
{$IFDEF CompilerVersion_g21}
class constructor TConstants.Create;
begin
  FMyNumberz := TNumberz.ONE;
end;

class destructor TConstants.Destroy;
begin
  inherited;
end;
{$ELSE}
procedure TConstants_Initialize;
begin
  TConstants.FMyNumberz := TNumberz.ONE;
end;

procedure TConstants_Finalize;
begin
end;
{$ENDIF}

//{$IFEND}


initialization
//{$IF CompilerVersion < 21.0}
{$IFDEF CompilerVersion_l21}
  TConstants_Initialize;
{$ENDIF}
//{$IFEND}

finalization
//{$IF CompilerVersion < 21.0}
{$IFDEF CompilerVersion_l21}
  TConstants_Finalize;
{$ENDIF}
//{$IFEND}


end.
